<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pylab.inference API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.inference.DEFAULT_LOG_EVERY">DEFAULT_LOG_EVERY</a></li>
    <li class="mono"><a href="#pylab.inference.REQUIRED_ATTRS">REQUIRED_ATTRS</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.inference.OLS">OLS</a></li>
    <li class="mono"><a href="#pylab.inference.isMCMC">isMCMC</a></li>
    <li class="mono"><a href="#pylab.inference.r_hat">r_hat</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pylab.inference.BaseMCMC">BaseMCMC</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.ids">ids</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.is_in_inference_order">is_in_inference_order</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.names">names</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.run">run</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.save">save</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.set_diagnostic_variables">set_diagnostic_variables</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.set_inference_order">set_inference_order</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.set_tracer">set_tracer</a></li>
    <li class="mono"><a href="#pylab.inference.BaseMCMC.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.inference.Tracer">Tracer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.inference.Tracer.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.close">close</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.copy">copy</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.deepcopy">deepcopy</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.finish_tracing">finish_tracing</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.get_iter">get_iter</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.get_trace">get_trace</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.is_being_traced">is_being_traced</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.open">open</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.save">save</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.set_trace">set_trace</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.write_to_disk">write_to_disk</a></li>
    <li class="mono"><a href="#pylab.inference.Tracer.load">load</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pylab.inference</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference" class="source">
    <pre><code>import sys
import copy
import h5py
import collections
import logging
import time
import shutil

import numpy as np
import numpy.random as npr
import scipy.stats

# import matplotlib.pyplot as plt

from .graph import get_default_graph, isgraph, isnode
from .base import Saveable, istraceable
from .variables import isVariable
from .errors import MathError, UndefinedError, InheritanceError
from . import util

# Constants
DEFAULT_LOG_EVERY = 5
REQUIRED_ATTRS = ['update', 'initialize', 'set_trace', 'add_trace']

def OLS(covariates, observations):
    '''observations = covariates @ beta
    Moore-Penrose pseudoinverse
    '''
    return np.linalg.inv(covariates.T @ covariates) @ covariates.T @ observations

def isMCMC(x):
    '''Checks if the input array is an MCMC inference object

    Parameters
    ----------
    x : any
        Instance we are checking
    
    Returns
    -------
    bool
        True if `x` is a an MCMC inference object
    '''
    return x is not None and issubclass(x.__class__, BaseMCMC)


class BaseMCMC(Saveable):
    '''Base MCMC over a graph. This only runs 1 chain.

    Typical use
    -----------
    You first initialize the object with the graph and parameters you want
    >>> inf = BaseMCMC(burnin=1000, n_samples=2000, graph=G)
    Then you set the inference order
    >>> inf.set_inference_order(['a', 'b', 'c'])
    Then set some diagnostic variables (Optional)
    >>> inf.set_diagnostic_variables(['e'])
    Then we can run the inference
    >>> inf.run(log_every=5, ckpt=100, tracer_filename='./output/tracer.hdf5')

    Inference order
    ---------------
    This datastructure will perform the inference specified in the inference 
    order, which is set using the `set_inference_order` method. Each element
    in `inf_order` must be an ID in `graph` that implements the functions: `update` 
    (how we sample the variable during inference), `set_trace` (how the 
    tracing gets set up), `add_trace` (how the current value gets added to the 
    trace (this is called immediately after `update`)), and `initialize` (
    how the values get initialized before inference).

    If your posterior class directly inherits a class that is a subclass of 
    `pylab.variables.Variable` then the functions `set_trace` and 
    `add_trace` are already implemented for you.

    Sometimes we want to randomize the order that we update variables. For
    example, if I am updating the growth, self_interactions, and interactions,
    I may want to randomize the order that I update them so that there is no
    unintentional bias during inference. In that case I can make a new object 
    called `gLVParams` where the `update` function randomizes the order that
    growth.update(), self_interactions.update(), and interactions.update() 
    functions are called. 

    Parameters
    ----------
    burnin : int
        Number of initial samples to throw away
    n_samples : int
        Total number of samples of the posterior
        Number of posterior samples = n_samples-burnin
    graph : pylab.graph.Graph, Optional
        The graph we want to do the inference over
        If nothing is provided, it grabs the default graph
    '''

    def __init__(self, burnin, n_samples, graph):
        if not util.isint(burnin):
            raise TypeError('`burnin` ({}) must be an int'.format(type(burnin)))
        if not util.isint(n_samples):
            raise TypeError('`n_samples` ({}) must be an int'.format(type(n_samples)))
        if not isgraph(graph):
            raise TypeError('`graph` ({}) must be a pylab.graph.Graph'.format(
                type(graph)))
        if n_samples < burnin:
            raise TypeError('The total number of sample (n_samples) must be'\
                'larger than the burn in (burnin)')

        self.burnin = burnin
        self.n_samples = n_samples
        self.sample_iter = 0
        self.inf_order = None
        self.ran = False
        self.graph=graph
        self.graph.inference = self
        self.diagnostic_variables = None
        self.tracer = None

    def names(self):
        '''Get the names of the nodes in the inference object

        Returns
        -------
        list(str)
        '''
        return list(self.graph.name2id.keys())

    def ids(self):
        '''Get the IDs of the nodes in the inference object

        Returns
        -------
        list(int)
        '''
        return list(self.graph.nodes.keys())

    def set_inference_order(self, order):
        '''`order` is an array of nodes we want to sample in the order
        that we want. Check that they are all in the graph. Can put in the 
        ID or the name

        Parameters
        ----------
        order : array_like(int or str)
            Order to do the inference. This must be the IDs of the nodes and can
            be an ID (int) or the name (str)
        '''
        if not util.isarray(order):
            raise TypeError('order ({}) must be an array'.format(order))

        ret = []
        for nid in order:
            if nid not in self.graph:
                raise ValueError('Node ({}) not found in graph ({})'.format(
                    nid, self.names()))
            node = self.graph[nid]

            for attr in REQUIRED_ATTRS:
                if hasattr(node, attr):
                    if not callable(getattr(node, attr)):
                        raise UndefinedError('node ({}) must have `{}` be callable'.format(
                            node.name, attr))
                else:
                    raise UndefinedError('node ({}) must have the function `{}`'.format(
                        node.name, attr))
            ret.append(node.id)
        self.inf_order = ret

    def is_in_inference_order(self, var):
        '''Checks if the variable is in the inference order

        Parameters
        ----------
        var : int, str, pylab.variables.Variable
            Identifier for the variable
            If it is an int - it is assumed this is the id of the variable
            If is is a str - it is assumed this is the name of the variable

        Returns
        -------
        bool
        '''
        if not isVariable(var):
            if var not in self.graph:
                raise IndexError('`var` ({}) ({}) not recognized in graph'.format(type(var), var))
            var = self.graph[var].id
        else:
            var = var.id
        return var in self.inf_order

    def set_diagnostic_variables(self, vars):
        '''A list of variables that you want to track over time. These variables
        do not necessarily have to be variables that we are tracing, rather they
        can be any variable that changes over time in the inference. However,
        the variables that we are tracing need to be a subclass of
        pylab.variables.Variable

        We manually override the tracing for each of the variables.

        Parameters
        ----------
        vars : array_like, set, 1-dim
            - A list of the variables you want to track (the actual object)
            - The elements in the list should be of type pylab.variables.Variable
        '''
        # wrap vars as an iterable if it is not
        if not hasattr(vars, '__iter__'):
            vars = [vars]

        if len(vars) == 0:
            raise ValueError('No values in `vars`')

        # Check parameters passed in
        for var in vars:
            if not isVariable(var):
                raise InheritanceError('Each variable passed in should be of a subclass of' \
                    ' `pylab.variables.Variable`. This is of type `{}`'.format(
                        var.__class__.__name__))

        # Add variables to dictionary
        self.diagnostic_variables = {}
        for var in vars:
            if var.name in self.diagnostic_variables:
                raise ValueError('Two different diagnostic variables cannot have ' \
                    'the same name.')
            self.diagnostic_variables[var.name] = var

    def set_tracer(self, filename, ckpt=100):
        '''Sets up the tracing object

        Parameters
        ----------
        filename : str, None
            File location to save the hdf5 object
        ckpt : int, None
            Saves the current progress of the inference chain every `ckpt` iterations
            If None then there is no intermediate checkpointing
        '''
        if ckpt is None:
            ckpt = self.n_samples
        self.tracer_filename = filename
        self.ckpt = ckpt
        self.tracer = Tracer(mcmc=self, filename=filename)

    def run(self, log_every=1):
        '''Run the inference.

        Parameters
        ----------
        log_every : int, None
            Logs the values of the variables you are learning every `log_every` iterations.
            If the logger is set to DEBUG then override to log every iteration.
        
        Returns
        -------
        pylab.inference.BaseMCMC
            Output from the inference, self
        '''
        try:
            if self.inf_order is None:
                raise UndefinedError('Cannot run mcmc until you have set the inference order.' \
                    ' Set with the function `self.set_inference_order`.')
            if self.tracer is None:
                raise ValueError('Tracer not set. Set with the function `set_tracer`.')

            total_time = time.time()
            if log_every is None:
                log_every = DEFAULT_LOG_EVERY

            start = time.time()
            for i in range(self.n_samples):
                self.sample_iter = i

                # Log where necessary
                if i % log_every == 0:
                    logging.info('\n\nInference iteration {}/{}, time: {}'.format(
                        i, self.n_samples, time.time() - start))
                    start = time.time()
                    for id in self.inf_order:
                        if type(id) == list:
                            for id_ in id:
                                logging.info('{}: {}'.format(self.graph.nodes[id_].name,
                                    str(self.graph.nodes[id_])))
                        else:
                            logging.info('{}: {}'.format(self.graph.nodes[id].name,
                                str(self.graph.nodes[id])))

                # Sample posterior in the order indicated and add the trace
                for _id in self.inf_order:
                    try:
                        if i == 0:
                            self.graph.nodes[_id].add_init_value()
                        self.graph.nodes[_id].update()
                        self.graph.nodes[_id].add_trace()
                    except:
                        logging.critical('Crashed in `{}`'.format(self.graph[_id].name))
                        raise

                # Save diagnostic variables where necessary
                if self.diagnostic_variables is not None:
                    for name in self.diagnostic_variables:
                        if self.diagnostic_variables[name].sample_iter == self.sample_iter:
                            self.diagnostic_variables[name].add_trace()

            # Finish the tracing
            self.graph.tracer.finish_tracing()
            self.ran = True
            logging.info('Inference total time: {}/Gibb step'.format(
                (time.time() - total_time)/self.n_samples))
            
            return self
        except:
            for a in self.graph._persistent_pntr:
                a.kill()
            raise


class Tracer(Saveable): 
    '''This sets up the graph to be traced using h5py.

    Able to checkpoint the values of the graph through inference.
    Write the data to disk. The only variables that are traced are the 
    variables in the set `being_traced`.

    There might be other processes/threads that are reading the current 
    chain to plot it intermittently, so we create the file in SWMR 
    (Single Writer, Multiple Reader) mode which will make the 
    file always readable (never ina  corrupt state from writing).

    Parameters
    ----------
    mcmc : pylab.inference.BaseMCMC
        This is the inference object that we are tracing
    filename : str
        This is where to save it
    '''
    def __init__(self, mcmc, filename):
        # Check parameters and set up the attributes
        self.mcmc = mcmc
        self.graph = self.mcmc.graph
        self.graph.tracer = self
        self.mcmc.tracer = self

        if not util.isstr(filename):
            raise TypeError('filename ({}) must be a str'.format(type(filename)))
        self.filename = filename
        self.f = h5py.File(self.filename, 'w', libver='latest')
        self.being_traced = set()

        self.f.attrs['burnin'] = self.mcmc.burnin
        self.f.attrs['n_samples'] = self.mcmc.n_samples
        self.f.attrs['ckpt'] = self.mcmc.ckpt

        self.burnin = self.mcmc.burnin
        self.n_samples = self.mcmc.n_samples
        self.ckpt = self.mcmc.ckpt

        # Get the inference order and diagnostic variables
        ret = []
        for nid in self.mcmc.inf_order:
            ret.append(self.mcmc.graph[nid].name)
        self.f.attrs['inf_order'] = ret
        if self.mcmc.diagnostic_variables is not None:
            a = list(self.mcmc.diagnostic_variables.keys())
        else:
            a = []
        self.f.attrs['diagnostic_variables'] = a
        logging.info('Setting Single Write, Multiple Read Mode')
        self.f.swmr_mode = True # single writer, multiple reader mode
        self.close()

        # Add all of the variables being traced to the file
        logging.info('Setting the trace of learned parameters')
        logging.info('#######################################')
        for nid in self.mcmc.inf_order:
            logging.info('Setting the trace of {}'.format(self.graph[nid].name))
            self.graph[nid].set_trace()
        logging.info('Setting the trace for diagnostic variables')
        logging.info('##########################################')
        if self.mcmc.diagnostic_variables is not None:
            for nid in self.mcmc.diagnostic_variables:
                logging.info('Setting the trace of {}'.format(self.graph[nid].name))
                self.graph[nid].set_trace()

    # def __enter__(self):
    #     self.f = h5py.File(self.filename, 'r+')
    #     return self.f

    # def __exit__(self, type, value, traceback):
    #     self.close()

    def close(self):
        self.f.close()
        self.f = None

    def open(self):
        self.f = h5py.File(self.filename, 'r+', libver='latest')

    def copy(self):
        '''Return a copy of the object but do not copy the underlying hdf5 object
        '''
        new_obj = type(self)(mcmc=self.mcmc, filename=self.filename)
        new_obj.__dict__.update(self.__dict__)
        return new_obj

    def deepcopy(self, hdf5_dst=None):
        '''Return a deepcopy of the object and copy the underlying hdf5 object as well

        Parameters
        ----------
        hdf5_dst : str, None
            Destination to copy the hdf5 object. If Nothing is provided then we 
            will just append '_copy' to the name of the current filename
        '''
        if hdf5_dst is None:
            dst = self.filename.replace('.hdf5', '_copy.hdf5')
        else:
            if not util.isstr(hdf5_dst):
                raise TypeError('`hdf5_dst` ({}) must be a str')
            dst = hdf5_dst


        new_obj = copy.deepcopy(self)
        new_obj.filename = dst
        shutil.copyfile(src=self.filename, dst=new_obj.filename)
        return new_obj

    def is_being_traced(self, var):
        '''Checks if the variable is being traced

        Parameters
        ----------
        var : int, str, pylab.graph.Node
            An ID of a graph object or the object

        Returns
        -------
        bool
        '''
        if isnode(var):
            var = var.name
        else:
            if var in self.graph:
                var = self.graph[var].name
            else:
                raise IndexError('`var` ({}) ({}) not recognized in graph'.format(type(var), var))
        return var in self.being_traced

    def set_trace(self, name, shape, dtype):
        '''Set up a dataset for the variable. If a group is specified, it will 
        add it to the group

        Parameters
        ----------
        name : str
            This is the name of the variable.        
        shape : tuple, None
            This is the shape of the variable. This should not include the 
            trace length, that is added in this function. If it is a scalar,
            then the shape is None
        dtype : Type
            This is the type of the trace
        group : str, h5py.Group
            This is the group you want it added to 
        '''
        if name in self.being_traced:
            logging.info('Skipping adding the trace of `{}` because it is already being' \
                ' traced ({})'.format(name, list(self.being_traced)))
            return
        if not util.isstr(name):
            raise TypeError('`name` ({}) must be a str'.format(type(name)))
        if not (util.istuple(shape) or shape is None):
            raise TypeError('`shape` ({}) must be a tuple or None'.format(type(shape)))
        if not util.istype(dtype):
            raise TypeError('`dtype` ({}) ({}) must be a Type'.format(dtype, type(dtype)))
        self.open()
        
        if shape is not None:
            shape = (self.n_samples, ) + shape
        else:
            shape = (self.n_samples, )
        dset = self.f.create_dataset(name=name, shape=shape, dtype=dtype, chunks=True)
        dset.attrs['end_iter'] = 0
        self.being_traced.add(name)
        self.close()

    def write_to_disk(self, name):
        '''Append the RAM trace of the variable `name` into disk. Copies the data
        from RAM (self.graph[name]/trace) into disk memory.

        Parameters
        ----------
        name : str
            Name of the variable we are writing 
        '''
        self.open()
        dset = self.f[name]
        i = dset.attrs['end_iter']
        node = self.graph[name]
        l = node.ckpt_iter
        
        # print('\nwriting to disk,', name)
        # print('ckpt_iter', l)
        # print('trace.shape', node.trace.shape)
        # print(dset[i:i+l].shape)

        dset[i:i+l] = node.trace
        dset.attrs['end_iter'] = i + l
        self.close()

        # Save the other objects
        try:
            self.save()
            self.mcmc.save()
            self.graph.save()
        except:
            logging.critical('If you want to checkpoint, you must set the save location ' \
                'of tracer, graph, and mcmc using the function self.set_save_location()')
            print(self._save_loc)
            print(self.mcmc._save_loc)
            print(self.graph._save_loc)
            raise

    def overwrite_entire_trace_on_disk(self, name, data, dtype=None):
        '''Overwrite all the data we have on disk for the variable 
        with name `name` and data `data`. Blanks everything out and 
        sets the end variable to the end of data
        
        Parameters
        ----------
        name : str
            Name of the variable we are overwriting
        data : np.ndarray
            Array we are overwriting the data with
        '''
        if not util.isarray(data):
            raise TypeError('`data` ({}) must be an array'.format(type(data)))
        data = np.asarray(data)

        self.open()
        dset = self.f[name]
        shape = dset.shape
        if dtype is None:
            dtype = data.dtype

        # Delete the old dataset and make a new one
        del self.f[name]
        self.close()
        self.being_traced.remove(name)

        self.set_trace(name=name, shape=shape, dtype=dtype)
        
        self.open()
        dset = self.f[name]
        dset[:data.shape[0]] = data
        dset.attrs['end_iter'] = data.shape[0]
        self.close()

    def finish_tracing(self):
        '''Append the rest of the buffers to the dataset
        '''
        self.open()
        for name in self.being_traced:
            dset = self.f[name]
            i = dset.attrs['end_iter']
            node = self.graph[name]
            l = node.ckpt_iter
            dset[i:i+l] = node.trace
            dset.attrs['end_iter'] = i+l
        self.close()

    def get_trace(self, name, section='posterior', slices=None):
        '''Return the trace that corresponds with the name.

        Depdending on the parameter `section`, it will return different parts of
        the trace. Options:
            'posterior': 
                Returns the trace after the burnin
            'burnin'
                Returns the samples that were in the burnin
            'entire'
                Returns all the samples
            'slice'
                All of the arguments for slicing are in slices
            
        Parameters
        ----------
        name : str
            Name of the variable
        section : str
            Which part of the trace to return - description above
        slices : list(slice), slice
            A list of slicing objects or a slice object.

            slice(start, stop, step)
            Example, single dimension:
                slice(None) == :
                slice(5) == :5
                slice(4, None, None) == 4:
                slice(9, 22,None) == 9:22
            Example, multiple dimensions:
                [slice(None), slice(4, None, None)] == :, 4:
                [slice(None), 4, 5] == :, 4, 5

        Returns
        -------
        np.ndarray
        '''
        if not util.isstr(section):
            raise TypeError('`section` ({}) must be a str'.format(type(str)))
        
        self.open()
        dset = self.f[name]
        if section == 'posterior':
            high = dset.attrs['end_iter']
            low = self.burnin
            if low < self.burnin:
                self.close()
                raise IndexError('Last iteration ({}) is less than the burnin ({}). ' \
                    'Cannot get the trace'.format(i, self.burnin))
        elif section == 'burnin':
            high = dset.attrs['end_iter']
            low = 0
            if high > self.burnin:
                high = self.burnin
        elif section == 'entire':
            low = 0
            high = dset.attrs['end_iter']
        elif section != 'slice':
            raise ValueError('`section` ({}) not recognized'.format(section))
        
        if section != 'slice':
            if slices is not None:
                slices = [slice(low,high,None)] + list(slices)
            else:
                slices = slice(low,high,None)

        ret = dset[slices]
        self.close()
        return ret

    def get_iter(self, name):
        '''Return the end index that has been saved so far for variable with
        name `name`

        Parameters
        ----------
        name : str
            Name of the variable
        
        Returns
        -------
        int
        '''
        self.open()
        dset = self.f[name]
        i = dset.attrs['end_iter']
        self.close()
        return i


def r_hat(chains, vname, idx=None):
    '''Calculate the measure `R^` for the variable called `vname` at the index `idx`.
    If `idx` is None then we assume that the variable is scalar. `R^` is defined in
    [1]. It is assumed that these chains were run with different initial conditions
    and that the data is the same. An error will be thrown if the total number of
    burn-in or total samples are different.

    The values range from [1, inf], where 1 is completely mixed.

    Parameters
    ----------
    chains : list(pylab.inference.BaseMCMC),list(str)
        An iterable object of pl.inference.BaseMCMC objects. If it is a string then
        it is the saved location of the chain object.
    vanme : str, int
        This is the index of the variable we want to calculate `R^` from. This can
        either be the name (str) or the graph ID (int) to identify it.
    idx : int, tuple(int)
        This is the index of the item you're looking at. This is only necessary if 
        this variable is a vector. If it is a scalar then this is ignored.

    References
    ----------
    [1] A. Gelman, H. S. Stern, J. B. Carlin, D. B. Dunson, A. Vehtari, and D. B. Rubin, Bayesian Data
        Analysis Third Edition. Chapman and Hall/CRC, 2013.
    '''
    # Check that all of the chains are consistent with each other
    if not util.isarray(chains):
        raise TypeError('`chains` ({}) must be array_like'.format(type(chains)))
    if len(chains) <= 1:
        raise ValueError('There must be at least 2 items in chains. There are {}'.format(
            len(chains)))
    for i in len(chains):
        chain = chains[i]
        if util.isstr(chain):
            chains[i] = BaseMCMC.load(chains[i])
            chain = chains[i]
        if not isMCMC(chain):
            raise TypeError('`chain` ({}) must be a pylab.inference.BaseMCMC object'.format(
                type(chain)))
    n_burnin = chains[0].burnin
    n_samples = chains[0].n_samples
    for chain in chains:
        if chain.burnin != n_burnin or chain.n_samples != n_samples:
            raise ValueError('Each chain should have the same burnin ({}) and same ' \
                'number of total samples ({}).'.format(
                    [chain.burnin for chain in chains], [chain.n_samples for chain in chains]))
    
    # Get the variables from each of the chains and check that they are the proper shapes
    if not (util.isstr(vname) or util.isint(vname)):
        raise TypeError('`vname` ({}) must be an int or a str'.format(type(vname)))
    traces = [chain.graph[vname].get_trace_from_disk('posterior') for chain in chains]
    if idx is not None:
        traces = [trace[:,idx] for trace in traces]
    for i,trace in enumerate(traces):
        if len(trace.shape) != 1:
            raise ValueError('The `{}`th trace of {} has a shape of {}, it should be' \
                ' a scalar'.format(i,vname,trace.shape))
    n = len(traces[0])
    for trace in traces:
        if n != len(trace):
            raise ValueError('Each trace of the variable `{}` must be the same length ({})'.format(
                vname, [len(trace) for trace in traces]))
    m = len(traces)
    mu_chain = [np.mean(trace) for trace in traces]
    mu_total = np.mean(mu_chain)

    # Calculate between-sequence variance
    B = (n / (m-1)) * np.sum(([mu_chain[j] - mu_total])**2 for j in range(m))

    # Calculate the within-sequence variance
    W = 0
    for j in range(m):
        trace = traces[j]
        sj2 = (1/(n-1)) * np.sum((trace - mu_chain[j])**2)
        W += sj2
    W = W/m

    # Calculate r_hat
    rhat = np.sqrt(((n-1)*W/n + B/n) / W)
    return rhat
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="pylab.inference.DEFAULT_LOG_EVERY" class="name">var <span class="ident">DEFAULT_LOG_EVERY</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.inference.REQUIRED_ATTRS" class="name">var <span class="ident">REQUIRED_ATTRS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pylab.inference.OLS">
    <p>def <span class="ident">OLS</span>(</p><p>covariates, observations)</p>
    </div>
    

    
  
    <div class="desc"><p>observations = covariates @ beta
Moore-Penrose pseudoinverse</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.OLS', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.OLS" class="source">
    <pre><code>def OLS(covariates, observations):
    '''observations = covariates @ beta
    Moore-Penrose pseudoinverse
    '''
    return np.linalg.inv(covariates.T @ covariates) @ covariates.T @ observations
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.inference.isMCMC">
    <p>def <span class="ident">isMCMC</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if the input array is an MCMC inference object</p>
<h2>Parameters</h2>
<p>x : any
    Instance we are checking</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is a an MCMC inference object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.isMCMC', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.isMCMC" class="source">
    <pre><code>def isMCMC(x):
    '''Checks if the input array is an MCMC inference object

    Parameters
    ----------
    x : any
        Instance we are checking
    
    Returns
    -------
    bool
        True if `x` is a an MCMC inference object
    '''
    return x is not None and issubclass(x.__class__, BaseMCMC)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.inference.r_hat">
    <p>def <span class="ident">r_hat</span>(</p><p>chains, vname, idx=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate the measure <code>R^</code> for the variable called <code>vname</code> at the index <code>idx</code>.
If <code>idx</code> is None then we assume that the variable is scalar. <code>R^</code> is defined in
[1]. It is assumed that these chains were run with different initial conditions
and that the data is the same. An error will be thrown if the total number of
burn-in or total samples are different.</p>
<p>The values range from [1, inf], where 1 is completely mixed.</p>
<h2>Parameters</h2>
<p>chains : list(pylab.inference.BaseMCMC),list(str)
    An iterable object of pl.inference.BaseMCMC objects. If it is a string then
    it is the saved location of the chain object.
vanme : str, int
    This is the index of the variable we want to calculate <code>R^</code> from. This can
    either be the name (str) or the graph ID (int) to identify it.
idx : int, tuple(int)
    This is the index of the item you're looking at. This is only necessary if 
    this variable is a vector. If it is a scalar then this is ignored.</p>
<h2>References</h2>
<p>[1] A. Gelman, H. S. Stern, J. B. Carlin, D. B. Dunson, A. Vehtari, and D. B. Rubin, Bayesian Data
    Analysis Third Edition. Chapman and Hall/CRC, 2013.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.r_hat', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.r_hat" class="source">
    <pre><code>def r_hat(chains, vname, idx=None):
    '''Calculate the measure `R^` for the variable called `vname` at the index `idx`.
    If `idx` is None then we assume that the variable is scalar. `R^` is defined in
    [1]. It is assumed that these chains were run with different initial conditions
    and that the data is the same. An error will be thrown if the total number of
    burn-in or total samples are different.

    The values range from [1, inf], where 1 is completely mixed.

    Parameters
    ----------
    chains : list(pylab.inference.BaseMCMC),list(str)
        An iterable object of pl.inference.BaseMCMC objects. If it is a string then
        it is the saved location of the chain object.
    vanme : str, int
        This is the index of the variable we want to calculate `R^` from. This can
        either be the name (str) or the graph ID (int) to identify it.
    idx : int, tuple(int)
        This is the index of the item you're looking at. This is only necessary if 
        this variable is a vector. If it is a scalar then this is ignored.

    References
    ----------
    [1] A. Gelman, H. S. Stern, J. B. Carlin, D. B. Dunson, A. Vehtari, and D. B. Rubin, Bayesian Data
        Analysis Third Edition. Chapman and Hall/CRC, 2013.
    '''
    # Check that all of the chains are consistent with each other
    if not util.isarray(chains):
        raise TypeError('`chains` ({}) must be array_like'.format(type(chains)))
    if len(chains) <= 1:
        raise ValueError('There must be at least 2 items in chains. There are {}'.format(
            len(chains)))
    for i in len(chains):
        chain = chains[i]
        if util.isstr(chain):
            chains[i] = BaseMCMC.load(chains[i])
            chain = chains[i]
        if not isMCMC(chain):
            raise TypeError('`chain` ({}) must be a pylab.inference.BaseMCMC object'.format(
                type(chain)))
    n_burnin = chains[0].burnin
    n_samples = chains[0].n_samples
    for chain in chains:
        if chain.burnin != n_burnin or chain.n_samples != n_samples:
            raise ValueError('Each chain should have the same burnin ({}) and same ' \
                'number of total samples ({}).'.format(
                    [chain.burnin for chain in chains], [chain.n_samples for chain in chains]))
    
    # Get the variables from each of the chains and check that they are the proper shapes
    if not (util.isstr(vname) or util.isint(vname)):
        raise TypeError('`vname` ({}) must be an int or a str'.format(type(vname)))
    traces = [chain.graph[vname].get_trace_from_disk('posterior') for chain in chains]
    if idx is not None:
        traces = [trace[:,idx] for trace in traces]
    for i,trace in enumerate(traces):
        if len(trace.shape) != 1:
            raise ValueError('The `{}`th trace of {} has a shape of {}, it should be' \
                ' a scalar'.format(i,vname,trace.shape))
    n = len(traces[0])
    for trace in traces:
        if n != len(trace):
            raise ValueError('Each trace of the variable `{}` must be the same length ({})'.format(
                vname, [len(trace) for trace in traces]))
    m = len(traces)
    mu_chain = [np.mean(trace) for trace in traces]
    mu_total = np.mean(mu_chain)

    # Calculate between-sequence variance
    B = (n / (m-1)) * np.sum(([mu_chain[j] - mu_total])**2 for j in range(m))

    # Calculate the within-sequence variance
    W = 0
    for j in range(m):
        trace = traces[j]
        sj2 = (1/(n-1)) * np.sum((trace - mu_chain[j])**2)
        W += sj2
    W = W/m

    # Calculate r_hat
    rhat = np.sqrt(((n-1)*W/n + B/n) / W)
    return rhat
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pylab.inference.BaseMCMC" class="name">class <span class="ident">BaseMCMC</span></p>
      
  
    <div class="desc"><p>Base MCMC over a graph. This only runs 1 chain.</p>
<h2>Typical use</h2>
<p>You first initialize the object with the graph and parameters you want</p>
<blockquote>
<blockquote>
<blockquote>
<p>inf = BaseMCMC(burnin=1000, n_samples=2000, graph=G)
Then you set the inference order
inf.set_inference_order(['a', 'b', 'c'])
Then set some diagnostic variables (Optional)
inf.set_diagnostic_variables(['e'])
Then we can run the inference
inf.run(log_every=5, ckpt=100, tracer_filename='./output/tracer.hdf5')</p>
</blockquote>
</blockquote>
</blockquote>
<h2>Inference order</h2>
<p>This datastructure will perform the inference specified in the inference 
order, which is set using the <code>set_inference_order</code> method. Each element
in <code>inf_order</code> must be an ID in <code>graph</code> that implements the functions: <code>update</code> 
(how we sample the variable during inference), <code>set_trace</code> (how the 
tracing gets set up), <code>add_trace</code> (how the current value gets added to the 
trace (this is called immediately after <code>update</code>)), and <code>initialize</code> (
how the values get initialized before inference).</p>
<p>If your posterior class directly inherits a class that is a subclass of 
<code>pylab.variables.Variable</code> then the functions <code>set_trace</code> and 
<code>add_trace</code> are already implemented for you.</p>
<p>Sometimes we want to randomize the order that we update variables. For
example, if I am updating the growth, self_interactions, and interactions,
I may want to randomize the order that I update them so that there is no
unintentional bias during inference. In that case I can make a new object 
called <code>gLVParams</code> where the <code>update</code> function randomizes the order that
growth.update(), self_interactions.update(), and interactions.update() 
functions are called. </p>
<h2>Parameters</h2>
<p>burnin : int
    Number of initial samples to throw away
n_samples : int
    Total number of samples of the posterior
    Number of posterior samples = n_samples-burnin
graph : pylab.graph.Graph, Optional
    The graph we want to do the inference over
    If nothing is provided, it grabs the default graph</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC" class="source">
    <pre><code>class BaseMCMC(Saveable):
    '''Base MCMC over a graph. This only runs 1 chain.

    Typical use
    -----------
    You first initialize the object with the graph and parameters you want
    >>> inf = BaseMCMC(burnin=1000, n_samples=2000, graph=G)
    Then you set the inference order
    >>> inf.set_inference_order(['a', 'b', 'c'])
    Then set some diagnostic variables (Optional)
    >>> inf.set_diagnostic_variables(['e'])
    Then we can run the inference
    >>> inf.run(log_every=5, ckpt=100, tracer_filename='./output/tracer.hdf5')

    Inference order
    ---------------
    This datastructure will perform the inference specified in the inference 
    order, which is set using the `set_inference_order` method. Each element
    in `inf_order` must be an ID in `graph` that implements the functions: `update` 
    (how we sample the variable during inference), `set_trace` (how the 
    tracing gets set up), `add_trace` (how the current value gets added to the 
    trace (this is called immediately after `update`)), and `initialize` (
    how the values get initialized before inference).

    If your posterior class directly inherits a class that is a subclass of 
    `pylab.variables.Variable` then the functions `set_trace` and 
    `add_trace` are already implemented for you.

    Sometimes we want to randomize the order that we update variables. For
    example, if I am updating the growth, self_interactions, and interactions,
    I may want to randomize the order that I update them so that there is no
    unintentional bias during inference. In that case I can make a new object 
    called `gLVParams` where the `update` function randomizes the order that
    growth.update(), self_interactions.update(), and interactions.update() 
    functions are called. 

    Parameters
    ----------
    burnin : int
        Number of initial samples to throw away
    n_samples : int
        Total number of samples of the posterior
        Number of posterior samples = n_samples-burnin
    graph : pylab.graph.Graph, Optional
        The graph we want to do the inference over
        If nothing is provided, it grabs the default graph
    '''

    def __init__(self, burnin, n_samples, graph):
        if not util.isint(burnin):
            raise TypeError('`burnin` ({}) must be an int'.format(type(burnin)))
        if not util.isint(n_samples):
            raise TypeError('`n_samples` ({}) must be an int'.format(type(n_samples)))
        if not isgraph(graph):
            raise TypeError('`graph` ({}) must be a pylab.graph.Graph'.format(
                type(graph)))
        if n_samples < burnin:
            raise TypeError('The total number of sample (n_samples) must be'\
                'larger than the burn in (burnin)')

        self.burnin = burnin
        self.n_samples = n_samples
        self.sample_iter = 0
        self.inf_order = None
        self.ran = False
        self.graph=graph
        self.graph.inference = self
        self.diagnostic_variables = None
        self.tracer = None

    def names(self):
        '''Get the names of the nodes in the inference object

        Returns
        -------
        list(str)
        '''
        return list(self.graph.name2id.keys())

    def ids(self):
        '''Get the IDs of the nodes in the inference object

        Returns
        -------
        list(int)
        '''
        return list(self.graph.nodes.keys())

    def set_inference_order(self, order):
        '''`order` is an array of nodes we want to sample in the order
        that we want. Check that they are all in the graph. Can put in the 
        ID or the name

        Parameters
        ----------
        order : array_like(int or str)
            Order to do the inference. This must be the IDs of the nodes and can
            be an ID (int) or the name (str)
        '''
        if not util.isarray(order):
            raise TypeError('order ({}) must be an array'.format(order))

        ret = []
        for nid in order:
            if nid not in self.graph:
                raise ValueError('Node ({}) not found in graph ({})'.format(
                    nid, self.names()))
            node = self.graph[nid]

            for attr in REQUIRED_ATTRS:
                if hasattr(node, attr):
                    if not callable(getattr(node, attr)):
                        raise UndefinedError('node ({}) must have `{}` be callable'.format(
                            node.name, attr))
                else:
                    raise UndefinedError('node ({}) must have the function `{}`'.format(
                        node.name, attr))
            ret.append(node.id)
        self.inf_order = ret

    def is_in_inference_order(self, var):
        '''Checks if the variable is in the inference order

        Parameters
        ----------
        var : int, str, pylab.variables.Variable
            Identifier for the variable
            If it is an int - it is assumed this is the id of the variable
            If is is a str - it is assumed this is the name of the variable

        Returns
        -------
        bool
        '''
        if not isVariable(var):
            if var not in self.graph:
                raise IndexError('`var` ({}) ({}) not recognized in graph'.format(type(var), var))
            var = self.graph[var].id
        else:
            var = var.id
        return var in self.inf_order

    def set_diagnostic_variables(self, vars):
        '''A list of variables that you want to track over time. These variables
        do not necessarily have to be variables that we are tracing, rather they
        can be any variable that changes over time in the inference. However,
        the variables that we are tracing need to be a subclass of
        pylab.variables.Variable

        We manually override the tracing for each of the variables.

        Parameters
        ----------
        vars : array_like, set, 1-dim
            - A list of the variables you want to track (the actual object)
            - The elements in the list should be of type pylab.variables.Variable
        '''
        # wrap vars as an iterable if it is not
        if not hasattr(vars, '__iter__'):
            vars = [vars]

        if len(vars) == 0:
            raise ValueError('No values in `vars`')

        # Check parameters passed in
        for var in vars:
            if not isVariable(var):
                raise InheritanceError('Each variable passed in should be of a subclass of' \
                    ' `pylab.variables.Variable`. This is of type `{}`'.format(
                        var.__class__.__name__))

        # Add variables to dictionary
        self.diagnostic_variables = {}
        for var in vars:
            if var.name in self.diagnostic_variables:
                raise ValueError('Two different diagnostic variables cannot have ' \
                    'the same name.')
            self.diagnostic_variables[var.name] = var

    def set_tracer(self, filename, ckpt=100):
        '''Sets up the tracing object

        Parameters
        ----------
        filename : str, None
            File location to save the hdf5 object
        ckpt : int, None
            Saves the current progress of the inference chain every `ckpt` iterations
            If None then there is no intermediate checkpointing
        '''
        if ckpt is None:
            ckpt = self.n_samples
        self.tracer_filename = filename
        self.ckpt = ckpt
        self.tracer = Tracer(mcmc=self, filename=filename)

    def run(self, log_every=1):
        '''Run the inference.

        Parameters
        ----------
        log_every : int, None
            Logs the values of the variables you are learning every `log_every` iterations.
            If the logger is set to DEBUG then override to log every iteration.
        
        Returns
        -------
        pylab.inference.BaseMCMC
            Output from the inference, self
        '''
        try:
            if self.inf_order is None:
                raise UndefinedError('Cannot run mcmc until you have set the inference order.' \
                    ' Set with the function `self.set_inference_order`.')
            if self.tracer is None:
                raise ValueError('Tracer not set. Set with the function `set_tracer`.')

            total_time = time.time()
            if log_every is None:
                log_every = DEFAULT_LOG_EVERY

            start = time.time()
            for i in range(self.n_samples):
                self.sample_iter = i

                # Log where necessary
                if i % log_every == 0:
                    logging.info('\n\nInference iteration {}/{}, time: {}'.format(
                        i, self.n_samples, time.time() - start))
                    start = time.time()
                    for id in self.inf_order:
                        if type(id) == list:
                            for id_ in id:
                                logging.info('{}: {}'.format(self.graph.nodes[id_].name,
                                    str(self.graph.nodes[id_])))
                        else:
                            logging.info('{}: {}'.format(self.graph.nodes[id].name,
                                str(self.graph.nodes[id])))

                # Sample posterior in the order indicated and add the trace
                for _id in self.inf_order:
                    try:
                        if i == 0:
                            self.graph.nodes[_id].add_init_value()
                        self.graph.nodes[_id].update()
                        self.graph.nodes[_id].add_trace()
                    except:
                        logging.critical('Crashed in `{}`'.format(self.graph[_id].name))
                        raise

                # Save diagnostic variables where necessary
                if self.diagnostic_variables is not None:
                    for name in self.diagnostic_variables:
                        if self.diagnostic_variables[name].sample_iter == self.sample_iter:
                            self.diagnostic_variables[name].add_trace()

            # Finish the tracing
            self.graph.tracer.finish_tracing()
            self.ran = True
            logging.info('Inference total time: {}/Gibb step'.format(
                (time.time() - total_time)/self.n_samples))
            
            return self
        except:
            for a in self.graph._persistent_pntr:
                a.kill()
            raise
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.inference.BaseMCMC">BaseMCMC</a></li>
          <li>pylab.base.Saveable</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, burnin, n_samples, graph)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.__init__" class="source">
    <pre><code>def __init__(self, burnin, n_samples, graph):
    if not util.isint(burnin):
        raise TypeError('`burnin` ({}) must be an int'.format(type(burnin)))
    if not util.isint(n_samples):
        raise TypeError('`n_samples` ({}) must be an int'.format(type(n_samples)))
    if not isgraph(graph):
        raise TypeError('`graph` ({}) must be a pylab.graph.Graph'.format(
            type(graph)))
    if n_samples < burnin:
        raise TypeError('The total number of sample (n_samples) must be'\
            'larger than the burn in (burnin)')
    self.burnin = burnin
    self.n_samples = n_samples
    self.sample_iter = 0
    self.inf_order = None
    self.ran = False
    self.graph=graph
    self.graph.inference = self
    self.diagnostic_variables = None
    self.tracer = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.ids">
    <p>def <span class="ident">ids</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the IDs of the nodes in the inference object</p>
<h2>Returns</h2>
<p>list(int)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.ids', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.ids" class="source">
    <pre><code>def ids(self):
    '''Get the IDs of the nodes in the inference object
    Returns
    -------
    list(int)
    '''
    return list(self.graph.nodes.keys())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.is_in_inference_order">
    <p>def <span class="ident">is_in_inference_order</span>(</p><p>self, var)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if the variable is in the inference order</p>
<h2>Parameters</h2>
<p>var : int, str, pylab.variables.Variable
    Identifier for the variable
    If it is an int - it is assumed this is the id of the variable
    If is is a str - it is assumed this is the name of the variable</p>
<h2>Returns</h2>
<p>bool</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.is_in_inference_order', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.is_in_inference_order" class="source">
    <pre><code>def is_in_inference_order(self, var):
    '''Checks if the variable is in the inference order
    Parameters
    ----------
    var : int, str, pylab.variables.Variable
        Identifier for the variable
        If it is an int - it is assumed this is the id of the variable
        If is is a str - it is assumed this is the name of the variable
    Returns
    -------
    bool
    '''
    if not isVariable(var):
        if var not in self.graph:
            raise IndexError('`var` ({}) ({}) not recognized in graph'.format(type(var), var))
        var = self.graph[var].id
    else:
        var = var.id
    return var in self.inf_order
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.names">
    <p>def <span class="ident">names</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the names of the nodes in the inference object</p>
<h2>Returns</h2>
<p>list(str)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.names', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.names" class="source">
    <pre><code>def names(self):
    '''Get the names of the nodes in the inference object
    Returns
    -------
    list(str)
    '''
    return list(self.graph.name2id.keys())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.run">
    <p>def <span class="ident">run</span>(</p><p>self, log_every=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Run the inference.</p>
<h2>Parameters</h2>
<p>log_every : int, None
    Logs the values of the variables you are learning every <code>log_every</code> iterations.
    If the logger is set to DEBUG then override to log every iteration.</p>
<h2>Returns</h2>
<p>pylab.inference.BaseMCMC
    Output from the inference, self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.run', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.run" class="source">
    <pre><code>def run(self, log_every=1):
    '''Run the inference.
    Parameters
    ----------
    log_every : int, None
        Logs the values of the variables you are learning every `log_every` iterations.
        If the logger is set to DEBUG then override to log every iteration.
    
    Returns
    -------
    pylab.inference.BaseMCMC
        Output from the inference, self
    '''
    try:
        if self.inf_order is None:
            raise UndefinedError('Cannot run mcmc until you have set the inference order.' \
                ' Set with the function `self.set_inference_order`.')
        if self.tracer is None:
            raise ValueError('Tracer not set. Set with the function `set_tracer`.')
        total_time = time.time()
        if log_every is None:
            log_every = DEFAULT_LOG_EVERY
        start = time.time()
        for i in range(self.n_samples):
            self.sample_iter = i
            # Log where necessary
            if i % log_every == 0:
                logging.info('\n\nInference iteration {}/{}, time: {}'.format(
                    i, self.n_samples, time.time() - start))
                start = time.time()
                for id in self.inf_order:
                    if type(id) == list:
                        for id_ in id:
                            logging.info('{}: {}'.format(self.graph.nodes[id_].name,
                                str(self.graph.nodes[id_])))
                    else:
                        logging.info('{}: {}'.format(self.graph.nodes[id].name,
                            str(self.graph.nodes[id])))
            # Sample posterior in the order indicated and add the trace
            for _id in self.inf_order:
                try:
                    if i == 0:
                        self.graph.nodes[_id].add_init_value()
                    self.graph.nodes[_id].update()
                    self.graph.nodes[_id].add_trace()
                except:
                    logging.critical('Crashed in `{}`'.format(self.graph[_id].name))
                    raise
            # Save diagnostic variables where necessary
            if self.diagnostic_variables is not None:
                for name in self.diagnostic_variables:
                    if self.diagnostic_variables[name].sample_iter == self.sample_iter:
                        self.diagnostic_variables[name].add_trace()
        # Finish the tracing
        self.graph.tracer.finish_tracing()
        self.ran = True
        logging.info('Inference total time: {}/Gibb step'.format(
            (time.time() - total_time)/self.n_samples))
        
        return self
    except:
        for a in self.graph._persistent_pntr:
            a.kill()
        raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <code>pylab.base.Saveable.set_save_location</code>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.set_diagnostic_variables">
    <p>def <span class="ident">set_diagnostic_variables</span>(</p><p>self, vars)</p>
    </div>
    

    
  
    <div class="desc"><p>A list of variables that you want to track over time. These variables
do not necessarily have to be variables that we are tracing, rather they
can be any variable that changes over time in the inference. However,
the variables that we are tracing need to be a subclass of
pylab.variables.Variable</p>
<p>We manually override the tracing for each of the variables.</p>
<h2>Parameters</h2>
<p>vars : array_like, set, 1-dim
    - A list of the variables you want to track (the actual object)
    - The elements in the list should be of type pylab.variables.Variable</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.set_diagnostic_variables', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.set_diagnostic_variables" class="source">
    <pre><code>def set_diagnostic_variables(self, vars):
    '''A list of variables that you want to track over time. These variables
    do not necessarily have to be variables that we are tracing, rather they
    can be any variable that changes over time in the inference. However,
    the variables that we are tracing need to be a subclass of
    pylab.variables.Variable
    We manually override the tracing for each of the variables.
    Parameters
    ----------
    vars : array_like, set, 1-dim
        - A list of the variables you want to track (the actual object)
        - The elements in the list should be of type pylab.variables.Variable
    '''
    # wrap vars as an iterable if it is not
    if not hasattr(vars, '__iter__'):
        vars = [vars]
    if len(vars) == 0:
        raise ValueError('No values in `vars`')
    # Check parameters passed in
    for var in vars:
        if not isVariable(var):
            raise InheritanceError('Each variable passed in should be of a subclass of' \
                ' `pylab.variables.Variable`. This is of type `{}`'.format(
                    var.__class__.__name__))
    # Add variables to dictionary
    self.diagnostic_variables = {}
    for var in vars:
        if var.name in self.diagnostic_variables:
            raise ValueError('Two different diagnostic variables cannot have ' \
                'the same name.')
        self.diagnostic_variables[var.name] = var
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.set_inference_order">
    <p>def <span class="ident">set_inference_order</span>(</p><p>self, order)</p>
    </div>
    

    
  
    <div class="desc"><p><code>order</code> is an array of nodes we want to sample in the order
that we want. Check that they are all in the graph. Can put in the 
ID or the name</p>
<h2>Parameters</h2>
<p>order : array_like(int or str)
    Order to do the inference. This must be the IDs of the nodes and can
    be an ID (int) or the name (str)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.set_inference_order', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.set_inference_order" class="source">
    <pre><code>def set_inference_order(self, order):
    '''`order` is an array of nodes we want to sample in the order
    that we want. Check that they are all in the graph. Can put in the 
    ID or the name
    Parameters
    ----------
    order : array_like(int or str)
        Order to do the inference. This must be the IDs of the nodes and can
        be an ID (int) or the name (str)
    '''
    if not util.isarray(order):
        raise TypeError('order ({}) must be an array'.format(order))
    ret = []
    for nid in order:
        if nid not in self.graph:
            raise ValueError('Node ({}) not found in graph ({})'.format(
                nid, self.names()))
        node = self.graph[nid]
        for attr in REQUIRED_ATTRS:
            if hasattr(node, attr):
                if not callable(getattr(node, attr)):
                    raise UndefinedError('node ({}) must have `{}` be callable'.format(
                        node.name, attr))
            else:
                raise UndefinedError('node ({}) must have the function `{}`'.format(
                    node.name, attr))
        ret.append(node.id)
    self.inf_order = ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.set_tracer">
    <p>def <span class="ident">set_tracer</span>(</p><p>self, filename, ckpt=100)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets up the tracing object</p>
<h2>Parameters</h2>
<p>filename : str, None
    File location to save the hdf5 object
ckpt : int, None
    Saves the current progress of the inference chain every <code>ckpt</code> iterations
    If None then there is no intermediate checkpointing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.set_tracer', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.set_tracer" class="source">
    <pre><code>def set_tracer(self, filename, ckpt=100):
    '''Sets up the tracing object
    Parameters
    ----------
    filename : str, None
        File location to save the hdf5 object
    ckpt : int, None
        Saves the current progress of the inference chain every `ckpt` iterations
        If None then there is no intermediate checkpointing
    '''
    if ckpt is None:
        ckpt = self.n_samples
    self.tracer_filename = filename
    self.ckpt = ckpt
    self.tracer = Tracer(mcmc=self, filename=filename)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.burnin" class="name">var <span class="ident">burnin</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.diagnostic_variables" class="name">var <span class="ident">diagnostic_variables</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.graph" class="name">var <span class="ident">graph</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.inf_order" class="name">var <span class="ident">inf_order</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.n_samples" class="name">var <span class="ident">n_samples</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.ran" class="name">var <span class="ident">ran</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.sample_iter" class="name">var <span class="ident">sample_iter</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.BaseMCMC.tracer" class="name">var <span class="ident">tracer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.inference.BaseMCMC.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.BaseMCMC.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.BaseMCMC.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.inference.Tracer" class="name">class <span class="ident">Tracer</span></p>
      
  
    <div class="desc"><p>This sets up the graph to be traced using h5py.</p>
<p>Able to checkpoint the values of the graph through inference.
Write the data to disk. The only variables that are traced are the 
variables in the set <code>being_traced</code>.</p>
<p>There might be other processes/threads that are reading the current 
chain to plot it intermittently, so we create the file in SWMR 
(Single Writer, Multiple Reader) mode which will make the 
file always readable (never ina  corrupt state from writing).</p>
<h2>Parameters</h2>
<p>mcmc : pylab.inference.BaseMCMC
    This is the inference object that we are tracing
filename : str
    This is where to save it</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer" class="source">
    <pre><code>class Tracer(Saveable): 
    '''This sets up the graph to be traced using h5py.

    Able to checkpoint the values of the graph through inference.
    Write the data to disk. The only variables that are traced are the 
    variables in the set `being_traced`.

    There might be other processes/threads that are reading the current 
    chain to plot it intermittently, so we create the file in SWMR 
    (Single Writer, Multiple Reader) mode which will make the 
    file always readable (never ina  corrupt state from writing).

    Parameters
    ----------
    mcmc : pylab.inference.BaseMCMC
        This is the inference object that we are tracing
    filename : str
        This is where to save it
    '''
    def __init__(self, mcmc, filename):
        # Check parameters and set up the attributes
        self.mcmc = mcmc
        self.graph = self.mcmc.graph
        self.graph.tracer = self
        self.mcmc.tracer = self

        if not util.isstr(filename):
            raise TypeError('filename ({}) must be a str'.format(type(filename)))
        self.filename = filename
        self.f = h5py.File(self.filename, 'w', libver='latest')
        self.being_traced = set()

        self.f.attrs['burnin'] = self.mcmc.burnin
        self.f.attrs['n_samples'] = self.mcmc.n_samples
        self.f.attrs['ckpt'] = self.mcmc.ckpt

        self.burnin = self.mcmc.burnin
        self.n_samples = self.mcmc.n_samples
        self.ckpt = self.mcmc.ckpt

        # Get the inference order and diagnostic variables
        ret = []
        for nid in self.mcmc.inf_order:
            ret.append(self.mcmc.graph[nid].name)
        self.f.attrs['inf_order'] = ret
        if self.mcmc.diagnostic_variables is not None:
            a = list(self.mcmc.diagnostic_variables.keys())
        else:
            a = []
        self.f.attrs['diagnostic_variables'] = a
        logging.info('Setting Single Write, Multiple Read Mode')
        self.f.swmr_mode = True # single writer, multiple reader mode
        self.close()

        # Add all of the variables being traced to the file
        logging.info('Setting the trace of learned parameters')
        logging.info('#######################################')
        for nid in self.mcmc.inf_order:
            logging.info('Setting the trace of {}'.format(self.graph[nid].name))
            self.graph[nid].set_trace()
        logging.info('Setting the trace for diagnostic variables')
        logging.info('##########################################')
        if self.mcmc.diagnostic_variables is not None:
            for nid in self.mcmc.diagnostic_variables:
                logging.info('Setting the trace of {}'.format(self.graph[nid].name))
                self.graph[nid].set_trace()

    # def __enter__(self):
    #     self.f = h5py.File(self.filename, 'r+')
    #     return self.f

    # def __exit__(self, type, value, traceback):
    #     self.close()

    def close(self):
        self.f.close()
        self.f = None

    def open(self):
        self.f = h5py.File(self.filename, 'r+', libver='latest')

    def copy(self):
        '''Return a copy of the object but do not copy the underlying hdf5 object
        '''
        new_obj = type(self)(mcmc=self.mcmc, filename=self.filename)
        new_obj.__dict__.update(self.__dict__)
        return new_obj

    def deepcopy(self, hdf5_dst=None):
        '''Return a deepcopy of the object and copy the underlying hdf5 object as well

        Parameters
        ----------
        hdf5_dst : str, None
            Destination to copy the hdf5 object. If Nothing is provided then we 
            will just append '_copy' to the name of the current filename
        '''
        if hdf5_dst is None:
            dst = self.filename.replace('.hdf5', '_copy.hdf5')
        else:
            if not util.isstr(hdf5_dst):
                raise TypeError('`hdf5_dst` ({}) must be a str')
            dst = hdf5_dst


        new_obj = copy.deepcopy(self)
        new_obj.filename = dst
        shutil.copyfile(src=self.filename, dst=new_obj.filename)
        return new_obj

    def is_being_traced(self, var):
        '''Checks if the variable is being traced

        Parameters
        ----------
        var : int, str, pylab.graph.Node
            An ID of a graph object or the object

        Returns
        -------
        bool
        '''
        if isnode(var):
            var = var.name
        else:
            if var in self.graph:
                var = self.graph[var].name
            else:
                raise IndexError('`var` ({}) ({}) not recognized in graph'.format(type(var), var))
        return var in self.being_traced

    def set_trace(self, name, shape, dtype):
        '''Set up a dataset for the variable. If a group is specified, it will 
        add it to the group

        Parameters
        ----------
        name : str
            This is the name of the variable.        
        shape : tuple, None
            This is the shape of the variable. This should not include the 
            trace length, that is added in this function. If it is a scalar,
            then the shape is None
        dtype : Type
            This is the type of the trace
        group : str, h5py.Group
            This is the group you want it added to 
        '''
        if name in self.being_traced:
            logging.info('Skipping adding the trace of `{}` because it is already being' \
                ' traced ({})'.format(name, list(self.being_traced)))
            return
        if not util.isstr(name):
            raise TypeError('`name` ({}) must be a str'.format(type(name)))
        if not (util.istuple(shape) or shape is None):
            raise TypeError('`shape` ({}) must be a tuple or None'.format(type(shape)))
        if not util.istype(dtype):
            raise TypeError('`dtype` ({}) ({}) must be a Type'.format(dtype, type(dtype)))
        self.open()
        
        if shape is not None:
            shape = (self.n_samples, ) + shape
        else:
            shape = (self.n_samples, )
        dset = self.f.create_dataset(name=name, shape=shape, dtype=dtype, chunks=True)
        dset.attrs['end_iter'] = 0
        self.being_traced.add(name)
        self.close()

    def write_to_disk(self, name):
        '''Append the RAM trace of the variable `name` into disk. Copies the data
        from RAM (self.graph[name]/trace) into disk memory.

        Parameters
        ----------
        name : str
            Name of the variable we are writing 
        '''
        self.open()
        dset = self.f[name]
        i = dset.attrs['end_iter']
        node = self.graph[name]
        l = node.ckpt_iter
        
        # print('\nwriting to disk,', name)
        # print('ckpt_iter', l)
        # print('trace.shape', node.trace.shape)
        # print(dset[i:i+l].shape)

        dset[i:i+l] = node.trace
        dset.attrs['end_iter'] = i + l
        self.close()

        # Save the other objects
        try:
            self.save()
            self.mcmc.save()
            self.graph.save()
        except:
            logging.critical('If you want to checkpoint, you must set the save location ' \
                'of tracer, graph, and mcmc using the function self.set_save_location()')
            print(self._save_loc)
            print(self.mcmc._save_loc)
            print(self.graph._save_loc)
            raise

    def overwrite_entire_trace_on_disk(self, name, data, dtype=None):
        '''Overwrite all the data we have on disk for the variable 
        with name `name` and data `data`. Blanks everything out and 
        sets the end variable to the end of data
        
        Parameters
        ----------
        name : str
            Name of the variable we are overwriting
        data : np.ndarray
            Array we are overwriting the data with
        '''
        if not util.isarray(data):
            raise TypeError('`data` ({}) must be an array'.format(type(data)))
        data = np.asarray(data)

        self.open()
        dset = self.f[name]
        shape = dset.shape
        if dtype is None:
            dtype = data.dtype

        # Delete the old dataset and make a new one
        del self.f[name]
        self.close()
        self.being_traced.remove(name)

        self.set_trace(name=name, shape=shape, dtype=dtype)
        
        self.open()
        dset = self.f[name]
        dset[:data.shape[0]] = data
        dset.attrs['end_iter'] = data.shape[0]
        self.close()

    def finish_tracing(self):
        '''Append the rest of the buffers to the dataset
        '''
        self.open()
        for name in self.being_traced:
            dset = self.f[name]
            i = dset.attrs['end_iter']
            node = self.graph[name]
            l = node.ckpt_iter
            dset[i:i+l] = node.trace
            dset.attrs['end_iter'] = i+l
        self.close()

    def get_trace(self, name, section='posterior', slices=None):
        '''Return the trace that corresponds with the name.

        Depdending on the parameter `section`, it will return different parts of
        the trace. Options:
            'posterior': 
                Returns the trace after the burnin
            'burnin'
                Returns the samples that were in the burnin
            'entire'
                Returns all the samples
            'slice'
                All of the arguments for slicing are in slices
            
        Parameters
        ----------
        name : str
            Name of the variable
        section : str
            Which part of the trace to return - description above
        slices : list(slice), slice
            A list of slicing objects or a slice object.

            slice(start, stop, step)
            Example, single dimension:
                slice(None) == :
                slice(5) == :5
                slice(4, None, None) == 4:
                slice(9, 22,None) == 9:22
            Example, multiple dimensions:
                [slice(None), slice(4, None, None)] == :, 4:
                [slice(None), 4, 5] == :, 4, 5

        Returns
        -------
        np.ndarray
        '''
        if not util.isstr(section):
            raise TypeError('`section` ({}) must be a str'.format(type(str)))
        
        self.open()
        dset = self.f[name]
        if section == 'posterior':
            high = dset.attrs['end_iter']
            low = self.burnin
            if low < self.burnin:
                self.close()
                raise IndexError('Last iteration ({}) is less than the burnin ({}). ' \
                    'Cannot get the trace'.format(i, self.burnin))
        elif section == 'burnin':
            high = dset.attrs['end_iter']
            low = 0
            if high > self.burnin:
                high = self.burnin
        elif section == 'entire':
            low = 0
            high = dset.attrs['end_iter']
        elif section != 'slice':
            raise ValueError('`section` ({}) not recognized'.format(section))
        
        if section != 'slice':
            if slices is not None:
                slices = [slice(low,high,None)] + list(slices)
            else:
                slices = slice(low,high,None)

        ret = dset[slices]
        self.close()
        return ret

    def get_iter(self, name):
        '''Return the end index that has been saved so far for variable with
        name `name`

        Parameters
        ----------
        name : str
            Name of the variable
        
        Returns
        -------
        int
        '''
        self.open()
        dset = self.f[name]
        i = dset.attrs['end_iter']
        self.close()
        return i
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.inference.Tracer">Tracer</a></li>
          <li>pylab.base.Saveable</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, mcmc, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.__init__" class="source">
    <pre><code>def __init__(self, mcmc, filename):
    # Check parameters and set up the attributes
    self.mcmc = mcmc
    self.graph = self.mcmc.graph
    self.graph.tracer = self
    self.mcmc.tracer = self
    if not util.isstr(filename):
        raise TypeError('filename ({}) must be a str'.format(type(filename)))
    self.filename = filename
    self.f = h5py.File(self.filename, 'w', libver='latest')
    self.being_traced = set()
    self.f.attrs['burnin'] = self.mcmc.burnin
    self.f.attrs['n_samples'] = self.mcmc.n_samples
    self.f.attrs['ckpt'] = self.mcmc.ckpt
    self.burnin = self.mcmc.burnin
    self.n_samples = self.mcmc.n_samples
    self.ckpt = self.mcmc.ckpt
    # Get the inference order and diagnostic variables
    ret = []
    for nid in self.mcmc.inf_order:
        ret.append(self.mcmc.graph[nid].name)
    self.f.attrs['inf_order'] = ret
    if self.mcmc.diagnostic_variables is not None:
        a = list(self.mcmc.diagnostic_variables.keys())
    else:
        a = []
    self.f.attrs['diagnostic_variables'] = a
    logging.info('Setting Single Write, Multiple Read Mode')
    self.f.swmr_mode = True # single writer, multiple reader mode
    self.close()
    # Add all of the variables being traced to the file
    logging.info('Setting the trace of learned parameters')
    logging.info('#######################################')
    for nid in self.mcmc.inf_order:
        logging.info('Setting the trace of {}'.format(self.graph[nid].name))
        self.graph[nid].set_trace()
    logging.info('Setting the trace for diagnostic variables')
    logging.info('##########################################')
    if self.mcmc.diagnostic_variables is not None:
        for nid in self.mcmc.diagnostic_variables:
            logging.info('Setting the trace of {}'.format(self.graph[nid].name))
            self.graph[nid].set_trace()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.close">
    <p>def <span class="ident">close</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.close', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.close" class="source">
    <pre><code>def close(self):
    self.f.close()
    self.f = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.copy">
    <p>def <span class="ident">copy</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a copy of the object but do not copy the underlying hdf5 object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.copy', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.copy" class="source">
    <pre><code>def copy(self):
    '''Return a copy of the object but do not copy the underlying hdf5 object
    '''
    new_obj = type(self)(mcmc=self.mcmc, filename=self.filename)
    new_obj.__dict__.update(self.__dict__)
    return new_obj
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.deepcopy">
    <p>def <span class="ident">deepcopy</span>(</p><p>self, hdf5_dst=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a deepcopy of the object and copy the underlying hdf5 object as well</p>
<h2>Parameters</h2>
<p>hdf5_dst : str, None
    Destination to copy the hdf5 object. If Nothing is provided then we 
    will just append '_copy' to the name of the current filename</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.deepcopy', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.deepcopy" class="source">
    <pre><code>def deepcopy(self, hdf5_dst=None):
    '''Return a deepcopy of the object and copy the underlying hdf5 object as well
    Parameters
    ----------
    hdf5_dst : str, None
        Destination to copy the hdf5 object. If Nothing is provided then we 
        will just append '_copy' to the name of the current filename
    '''
    if hdf5_dst is None:
        dst = self.filename.replace('.hdf5', '_copy.hdf5')
    else:
        if not util.isstr(hdf5_dst):
            raise TypeError('`hdf5_dst` ({}) must be a str')
        dst = hdf5_dst
    new_obj = copy.deepcopy(self)
    new_obj.filename = dst
    shutil.copyfile(src=self.filename, dst=new_obj.filename)
    return new_obj
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.finish_tracing">
    <p>def <span class="ident">finish_tracing</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Append the rest of the buffers to the dataset</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.finish_tracing', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.finish_tracing" class="source">
    <pre><code>def finish_tracing(self):
    '''Append the rest of the buffers to the dataset
    '''
    self.open()
    for name in self.being_traced:
        dset = self.f[name]
        i = dset.attrs['end_iter']
        node = self.graph[name]
        l = node.ckpt_iter
        dset[i:i+l] = node.trace
        dset.attrs['end_iter'] = i+l
    self.close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.get_iter">
    <p>def <span class="ident">get_iter</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the end index that has been saved so far for variable with
name <code>name</code></p>
<h2>Parameters</h2>
<p>name : str
    Name of the variable</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.get_iter', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.get_iter" class="source">
    <pre><code>def get_iter(self, name):
    '''Return the end index that has been saved so far for variable with
    name `name`
    Parameters
    ----------
    name : str
        Name of the variable
    
    Returns
    -------
    int
    '''
    self.open()
    dset = self.f[name]
    i = dset.attrs['end_iter']
    self.close()
    return i
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.get_trace">
    <p>def <span class="ident">get_trace</span>(</p><p>self, name, section=&#39;posterior&#39;, slices=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the trace that corresponds with the name.</p>
<p>Depdending on the parameter <code>section</code>, it will return different parts of
the trace. Options:
    'posterior': 
        Returns the trace after the burnin
    'burnin'
        Returns the samples that were in the burnin
    'entire'
        Returns all the samples
    'slice'
        All of the arguments for slicing are in slices</p>
<h2>Parameters</h2>
<p>name : str
    Name of the variable
section : str
    Which part of the trace to return - description above
slices : list(slice), slice
    A list of slicing objects or a slice object.</p>
<pre><code>slice(start, stop, step)
Example, single dimension:
    slice(None) == :
    slice(5) == :5
    slice(4, None, None) == 4:
    slice(9, 22,None) == 9:22
Example, multiple dimensions:
    [slice(None), slice(4, None, None)] == :, 4:
    [slice(None), 4, 5] == :, 4, 5
</code></pre>
<h2>Returns</h2>
<p>np.ndarray</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.get_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.get_trace" class="source">
    <pre><code>def get_trace(self, name, section='posterior', slices=None):
    '''Return the trace that corresponds with the name.
    Depdending on the parameter `section`, it will return different parts of
    the trace. Options:
        'posterior': 
            Returns the trace after the burnin
        'burnin'
            Returns the samples that were in the burnin
        'entire'
            Returns all the samples
        'slice'
            All of the arguments for slicing are in slices
        
    Parameters
    ----------
    name : str
        Name of the variable
    section : str
        Which part of the trace to return - description above
    slices : list(slice), slice
        A list of slicing objects or a slice object.
        slice(start, stop, step)
        Example, single dimension:
            slice(None) == :
            slice(5) == :5
            slice(4, None, None) == 4:
            slice(9, 22,None) == 9:22
        Example, multiple dimensions:
            [slice(None), slice(4, None, None)] == :, 4:
            [slice(None), 4, 5] == :, 4, 5
    Returns
    -------
    np.ndarray
    '''
    if not util.isstr(section):
        raise TypeError('`section` ({}) must be a str'.format(type(str)))
    
    self.open()
    dset = self.f[name]
    if section == 'posterior':
        high = dset.attrs['end_iter']
        low = self.burnin
        if low < self.burnin:
            self.close()
            raise IndexError('Last iteration ({}) is less than the burnin ({}). ' \
                'Cannot get the trace'.format(i, self.burnin))
    elif section == 'burnin':
        high = dset.attrs['end_iter']
        low = 0
        if high > self.burnin:
            high = self.burnin
    elif section == 'entire':
        low = 0
        high = dset.attrs['end_iter']
    elif section != 'slice':
        raise ValueError('`section` ({}) not recognized'.format(section))
    
    if section != 'slice':
        if slices is not None:
            slices = [slice(low,high,None)] + list(slices)
        else:
            slices = slice(low,high,None)
    ret = dset[slices]
    self.close()
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.is_being_traced">
    <p>def <span class="ident">is_being_traced</span>(</p><p>self, var)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if the variable is being traced</p>
<h2>Parameters</h2>
<p>var : int, str, pylab.graph.Node
    An ID of a graph object or the object</p>
<h2>Returns</h2>
<p>bool</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.is_being_traced', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.is_being_traced" class="source">
    <pre><code>def is_being_traced(self, var):
    '''Checks if the variable is being traced
    Parameters
    ----------
    var : int, str, pylab.graph.Node
        An ID of a graph object or the object
    Returns
    -------
    bool
    '''
    if isnode(var):
        var = var.name
    else:
        if var in self.graph:
            var = self.graph[var].name
        else:
            raise IndexError('`var` ({}) ({}) not recognized in graph'.format(type(var), var))
    return var in self.being_traced
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.open">
    <p>def <span class="ident">open</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.open', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.open" class="source">
    <pre><code>def open(self):
    self.f = h5py.File(self.filename, 'r+', libver='latest')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.overwrite_entire_trace_on_disk">
    <p>def <span class="ident">overwrite_entire_trace_on_disk</span>(</p><p>self, name, data, dtype=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrite all the data we have on disk for the variable 
with name <code>name</code> and data <code>data</code>. Blanks everything out and 
sets the end variable to the end of data</p>
<h2>Parameters</h2>
<p>name : str
    Name of the variable we are overwriting
data : np.ndarray
    Array we are overwriting the data with</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.overwrite_entire_trace_on_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.overwrite_entire_trace_on_disk" class="source">
    <pre><code>def overwrite_entire_trace_on_disk(self, name, data, dtype=None):
    '''Overwrite all the data we have on disk for the variable 
    with name `name` and data `data`. Blanks everything out and 
    sets the end variable to the end of data
    
    Parameters
    ----------
    name : str
        Name of the variable we are overwriting
    data : np.ndarray
        Array we are overwriting the data with
    '''
    if not util.isarray(data):
        raise TypeError('`data` ({}) must be an array'.format(type(data)))
    data = np.asarray(data)
    self.open()
    dset = self.f[name]
    shape = dset.shape
    if dtype is None:
        dtype = data.dtype
    # Delete the old dataset and make a new one
    del self.f[name]
    self.close()
    self.being_traced.remove(name)
    self.set_trace(name=name, shape=shape, dtype=dtype)
    
    self.open()
    dset = self.f[name]
    dset[:data.shape[0]] = data
    dset.attrs['end_iter'] = data.shape[0]
    self.close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <code>pylab.base.Saveable.set_save_location</code>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.set_trace">
    <p>def <span class="ident">set_trace</span>(</p><p>self, name, shape, dtype)</p>
    </div>
    

    
  
    <div class="desc"><p>Set up a dataset for the variable. If a group is specified, it will 
add it to the group</p>
<h2>Parameters</h2>
<p>name : str
    This is the name of the variable.      <br />
shape : tuple, None
    This is the shape of the variable. This should not include the 
    trace length, that is added in this function. If it is a scalar,
    then the shape is None
dtype : Type
    This is the type of the trace
group : str, h5py.Group
    This is the group you want it added to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.set_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.set_trace" class="source">
    <pre><code>def set_trace(self, name, shape, dtype):
    '''Set up a dataset for the variable. If a group is specified, it will 
    add it to the group
    Parameters
    ----------
    name : str
        This is the name of the variable.        
    shape : tuple, None
        This is the shape of the variable. This should not include the 
        trace length, that is added in this function. If it is a scalar,
        then the shape is None
    dtype : Type
        This is the type of the trace
    group : str, h5py.Group
        This is the group you want it added to 
    '''
    if name in self.being_traced:
        logging.info('Skipping adding the trace of `{}` because it is already being' \
            ' traced ({})'.format(name, list(self.being_traced)))
        return
    if not util.isstr(name):
        raise TypeError('`name` ({}) must be a str'.format(type(name)))
    if not (util.istuple(shape) or shape is None):
        raise TypeError('`shape` ({}) must be a tuple or None'.format(type(shape)))
    if not util.istype(dtype):
        raise TypeError('`dtype` ({}) ({}) must be a Type'.format(dtype, type(dtype)))
    self.open()
    
    if shape is not None:
        shape = (self.n_samples, ) + shape
    else:
        shape = (self.n_samples, )
    dset = self.f.create_dataset(name=name, shape=shape, dtype=dtype, chunks=True)
    dset.attrs['end_iter'] = 0
    self.being_traced.add(name)
    self.close()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.write_to_disk">
    <p>def <span class="ident">write_to_disk</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Append the RAM trace of the variable <code>name</code> into disk. Copies the data
from RAM (self.graph[name]/trace) into disk memory.</p>
<h2>Parameters</h2>
<p>name : str
    Name of the variable we are writing</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.write_to_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.write_to_disk" class="source">
    <pre><code>def write_to_disk(self, name):
    '''Append the RAM trace of the variable `name` into disk. Copies the data
    from RAM (self.graph[name]/trace) into disk memory.
    Parameters
    ----------
    name : str
        Name of the variable we are writing 
    '''
    self.open()
    dset = self.f[name]
    i = dset.attrs['end_iter']
    node = self.graph[name]
    l = node.ckpt_iter
    
    # print('\nwriting to disk,', name)
    # print('ckpt_iter', l)
    # print('trace.shape', node.trace.shape)
    # print(dset[i:i+l].shape)
    dset[i:i+l] = node.trace
    dset.attrs['end_iter'] = i + l
    self.close()
    # Save the other objects
    try:
        self.save()
        self.mcmc.save()
        self.graph.save()
    except:
        logging.critical('If you want to checkpoint, you must set the save location ' \
            'of tracer, graph, and mcmc using the function self.set_save_location()')
        print(self._save_loc)
        print(self.mcmc._save_loc)
        print(self.graph._save_loc)
        raise
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.inference.Tracer.being_traced" class="name">var <span class="ident">being_traced</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.Tracer.burnin" class="name">var <span class="ident">burnin</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.Tracer.ckpt" class="name">var <span class="ident">ckpt</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.Tracer.f" class="name">var <span class="ident">f</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.Tracer.filename" class="name">var <span class="ident">filename</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.Tracer.graph" class="name">var <span class="ident">graph</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.Tracer.mcmc" class="name">var <span class="ident">mcmc</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.inference.Tracer.n_samples" class="name">var <span class="ident">n_samples</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.inference.Tracer.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.inference.Tracer.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.inference.Tracer.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
