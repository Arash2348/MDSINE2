<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pylab.contrib API documentation</title>
    <meta name="description" content="These are classes that should be apart of pylab but need to be built
from many different modules. To..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.contrib.DEFAULT_INDICATOR_SUFFIX">DEFAULT_INDICATOR_SUFFIX</a></li>
    <li class="mono"><a href="#pylab.contrib.DEFAULT_MAGNITUDE_SUFFIX">DEFAULT_MAGNITUDE_SUFFIX</a></li>
    <li class="mono"><a href="#pylab.contrib.DEFAULT_PROBABILITY_SUFFIX">DEFAULT_PROBABILITY_SUFFIX</a></li>
    <li class="mono"><a href="#pylab.contrib.DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE">DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE</a></li>
    <li class="mono"><a href="#pylab.contrib.DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES">DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.contrib.isclusterperturbation">isclusterperturbation</a></li>
    <li class="mono"><a href="#pylab.contrib.isclusterperturbationindicator">isclusterperturbationindicator</a></li>
    <li class="mono"><a href="#pylab.contrib.isinteractions">isinteractions</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pylab.contrib.ClusterPerturbation">ClusterPerturbation</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.add_child">add_child</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.add_init_value">add_init_value</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.add_parent">add_parent</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.add_prior">add_prior</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.add_trace">add_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.add_undirected">add_undirected</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.cluster_array">cluster_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.delete">delete</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.get_adjacent_keys">get_adjacent_keys</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.get_iter">get_iter</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.get_trace_from_disk">get_trace_from_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.isactive">isactive</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.otu_array">otu_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.save">save</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.set_trace">set_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.set_value_shape">set_value_shape</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.set_values_from_array">set_values_from_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.timetuple">timetuple</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbation.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.contrib.ClusterPerturbationIndicator">ClusterPerturbationIndicator</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.add_child">add_child</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.add_init_value">add_init_value</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.add_parent">add_parent</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.add_prior">add_prior</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.add_trace">add_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.add_undirected">add_undirected</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.assignments_changed">assignments_changed</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.cluster_arg_array">cluster_arg_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.cluster_array">cluster_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.cluster_bool_array">cluster_bool_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.clusters_changed">clusters_changed</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.delete">delete</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.get_adjacent_keys">get_adjacent_keys</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.get_clusters_on">get_clusters_on</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.get_iter">get_iter</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.get_otus_on">get_otus_on</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.get_trace_from_disk">get_trace_from_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.num_on_clusters">num_on_clusters</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.num_on_otus">num_on_otus</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.otu_arg_array">otu_arg_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.otu_array">otu_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.otu_bool_array">otu_bool_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.reset">reset</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.save">save</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.set_signal_when_clusters_change">set_signal_when_clusters_change</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.set_signal_when_otu_assignment_changes">set_signal_when_otu_assignment_changes</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.set_trace">set_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.set_values_from_array">set_values_from_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationIndicator.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.contrib.ClusterPerturbationValue">ClusterPerturbationValue</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.add_child">add_child</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.add_init_value">add_init_value</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.add_parent">add_parent</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.add_prior">add_prior</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.add_trace">add_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.add_undirected">add_undirected</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.assignments_changed">assignments_changed</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.cluster_array">cluster_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.clusters_changed">clusters_changed</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.delete">delete</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.get_adjacent_keys">get_adjacent_keys</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.get_iter">get_iter</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.get_trace_from_disk">get_trace_from_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.otu_array">otu_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.reset">reset</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.save">save</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.set_signal_when_clusters_change">set_signal_when_clusters_change</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.set_signal_when_otu_assignment_changes">set_signal_when_otu_assignment_changes</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.set_trace">set_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.set_values_from_array">set_values_from_array</a></li>
    <li class="mono"><a href="#pylab.contrib.ClusterPerturbationValue.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.contrib.Interactions">Interactions</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.contrib.Interactions.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.add_child">add_child</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.add_init_value">add_init_value</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.add_parent">add_parent</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.add_prior">add_prior</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.add_trace">add_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.add_undirected">add_undirected</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.assignments_changed">assignments_changed</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.clusters_changed">clusters_changed</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.delete">delete</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.generate_bayes_factors_posthoc">generate_bayes_factors_posthoc</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.generate_in_out_degree_posthoc">generate_in_out_degree_posthoc</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_adjacent">get_adjacent</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_adjacent_keys">get_adjacent_keys</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_arg_indicators">get_arg_indicators</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_datalevel_indicator_matrix">get_datalevel_indicator_matrix</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_datalevel_value_matrix">get_datalevel_value_matrix</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_indicators">get_indicators</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_iter">get_iter</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_trace_from_disk">get_trace_from_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_value_matrix">get_value_matrix</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.get_values">get_values</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.iloc">iloc</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.iter_from_source">iter_from_source</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.iter_to_target">iter_to_target</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.iter_valid">iter_valid</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.iter_valid_pairs">iter_valid_pairs</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.key_pairs">key_pairs</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.num_neg_indicators">num_neg_indicators</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.num_pos_indicators">num_pos_indicators</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.reset">reset</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.save">save</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.set_indicators">set_indicators</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.set_signal_when_clusters_change">set_signal_when_clusters_change</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.set_signal_when_otu_assignment_changes">set_signal_when_otu_assignment_changes</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.set_trace">set_trace</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.set_values">set_values</a></li>
    <li class="mono"><a href="#pylab.contrib.Interactions.load">load</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pylab.contrib</span> module</h1>
  <p>These are classes that should be apart of pylab but need to be built
from many different modules. To get dependency structure right, all of these
extra, bigger classes are built in here. No other modules can
depend on contrib</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib" class="source">
    <pre><code>'''These are classes that should be apart of pylab but need to be built
from many different modules. To get dependency structure right, all of these
extra, bigger classes are built in here. No other modules can
depend on contrib
'''
import numpy as np
import numpy.random as npr
import sys
import logging
import numba

from .base import BasePerturbation, Traceable
from . import variables
from .cluster import isclustervalue, ClusterValue, isclustering, \
    ClusterProperty
from .graph import Node
from . import util

# Constants
DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE = False
DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES = False
DEFAULT_MAGNITUDE_SUFFIX = '_magnitude'
DEFAULT_PROBABILITY_SUFFIX = '_probability'
DEFAULT_INDICATOR_SUFFIX = '_indicator'

def isclusterperturbation(x):
    '''Checks whether the input is a subclass of ClusterPerturbation

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbation
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbation, else False
    '''
    return x is not None and issubclass(x.__class__, ClusterPerturbation)

def isclusterperturbationindicator(x):
    '''Checks whether the input is a subclass of ClusterPerturbationIndicator

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbationIndicator
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbationIndicator, else False
    '''
    return x is not None and issubclass(x.__class__, ClusterPerturbationIndicator)

def isinteractions(x):
    '''Type check if `x` is a subclass of Interactions

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of Interactions
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    '''
    return x is not None and issubclass(x.__class__, Interactions)

class ClusterPerturbationValue(ClusterValue):
    '''Extends `pylab.cluster.ClusterValue` object so it works for reset and cluster
    changed
    '''
    def reset(self):
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = False

    def clusters_changed(self, cids_added, cids_removed):
        '''Delete old clusters, sample from `prior` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        '''
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = self.prior.sample()


class ClusterPerturbationIndicator(ClusterValue):
    '''Extends the `pylab.cluster.ClusterValue` object so that it works for being a 
    cluster perturbation indicator
    
    Implements the `clusters_changed` function required by a ClusterProperty
    and provides a direct pointer to the probability object

    Parameters
    ----------
    probability : pl.variables.Variable
        This is the variable object that holds the probability for a positive indicator
    kwargs : dict
        These are additional arguments for ClusterValue
    '''
    def __init__(self, probability, **kwargs):
        ClusterValue.__init__(self, dtype=bool, **kwargs)
        self.probability = probability

    def reset(self):
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = False

    def clusters_changed(self, cids_added, cids_removed):
        '''Delete old clusters, sample from `probability` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        '''
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = bool(npr.binomial(
                n=1,
                p=self.probability.value))

    def otu_bool_array(self):
        '''Creates a boolean array expanded so that each OTU has the same 
        value that the cluster that contains it has. This is the same as 
        calling CLusterValue.otu_array
        Example
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([True, False, True, False, True])

        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each OTU
        '''
        return ClusterValue.otu_array(self)

    def cluster_bool_array(self):
        '''Creates a boolean array for each OTU in cluster order. This 
        is the same as calling ClusterValue.cluster_array()

        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([True, False])
        
        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each cluster
        '''
        return ClusterValue.cluster_array(self)

    def otu_arg_array(self):
        '''Creates an ordered index array of OTUs that are positive.
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([0,2,4])
        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each OTU
        '''
        val = []
        for cluster in self.clustering:
            if self.value[cluster.id]:
                val += list(cluster.members)
        return np.asarray(val, dtype=int)

    def cluster_arg_array(self):
        '''Creates an ordered index array of clusters that are positive.
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([0])
        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each cluster
        '''

        return np.asarray([idx for idx,cid in enumerate(self.clustering.order) \
            if self.value[cid]], dtype=int)

    def num_on_otus(self):
        '''These are the number of on otus for this perturbation
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> 3

        Returns
        -------
        int
            This is the number of postiive OTUs
        '''
        try:
            cumm = 0
            for cluster in self.clustering:
                if self.value[cluster.id]:
                    cumm += cluster.size
            return int(cumm)
        except:
            logging.critical('Inner cluster ids:\n{}'.format(list(self.value.keys())))
            logging.critical('Clustering cluster ids:\n{}'.format(self.clustering.order))
            raise

    def num_on_clusters(self):
        '''These are the number of on clusters for this perturbation
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> 1

        Returns
        -------
        int
            This is the number of postiive clusters
        '''
        cumm = 0
        for cid in self.clustering.order:
            cumm += self.value[cid]
        return cumm

    def get_clusters_on(self):
        '''Return the cluster IDs that have a positive indicator for this
        perturbation.

        Returns
        -------
        list
        '''
        ret = [cid for cid in self.clustering.order if self.value[cid]]
        return ret

    def get_otus_on(self):
        '''Get the OTU indecies that have a positive indicator for this
        perturbation.

        Returns
        -------
        list
        '''
        ret = []
        for cid in self.clustering.order:
            if self.value[cid]:
                ret += list(self.clustering.clusters[cid].members)
        return ret


class ClusterPerturbation(BasePerturbation, variables.Variable):
    '''This is an basic implementation for a cluster level perturbation.
    We trace the values at the OTU level.

    If you want to compute the bayes factors for each OTU, you can 
    calculate ~np.isnan for the trace. This will give an indicator 
    array that you can then use to calculate the bayes factor.
    
    Parameters
    ----------
    start, end : int, float
        - Start and end of the perturbation
    clustering : pylab.cluster.Clustering
        - This is the clustering object it is being set with
    magnitude : pylab.variables.Variable, pylab.cluster.ClusterValue, int/float, array, Optional
        - If a pylab.variables.Variable is passed in it will create one
          with the value indicated. Defualt value is None
    indicator : pylab.cluster.ClusterValue, array, Optional
        - This is the indicator of the interaction (vector, an indicator
          for every cluster). Default value is False for every cluster
    probability : pylab.variables.Variable, float, Optional
        - This is the probability that the perturbation affects a cluster, e.g.
          probability = 0.7, there's a 70% chance that the perturbation afffects 
          each cluster
    kwargs : dict
        - Extra arguments for the Node class
    '''
    def __init__(self, start, end, clustering,
        magnitude=None, indicator=None, probability=None,
        signal_when_clusters_change=False,
        signal_when_otu_assignment_changes=False, **kwargs):

        if signal_when_clusters_change is None:
            signal_when_clusters_change = DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE
        if signal_when_otu_assignment_changes is None:
            signal_when_otu_assignment_changes = DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES
        if not isclustering(clustering):
            raise TypeError('`clustering` ({}) must be a pylab.cluster.Clustering object'.format(
                type(clustering)))
        

        BasePerturbation.__init__(self, start=start, end=end)
        variables.Variable.__init__(self, **kwargs)
        if self.G.perturbations is None:
            self.G.perturbations = []
        self.G.perturbations.append(self)
        self.clustering = clustering
        self.set_value_shape(shape=(len(self.clustering.otus), ))
        if magnitude is not None:
            if util.isarray(magnitude):
                temp = ClusterPerturbationValue(clustering=clustering, 
                    G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                    signal_when_clusters_change=signal_when_clusters_change,
                    signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)
                temp.set_values_from_array(magnitude)
                magnitude=temp
            elif not isclustervalue(magnitude):
                raise TypeError('`magnitude` ({})' \
                    ' must be an array or a pylab.cluster.ClusterValue'.format(type(magnitude)))
        else:
            magnitude = ClusterPerturbationValue(clustering=clustering, 
                G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)            

        if not variables.isVariable(probability):
            if not util.isfloat(probability) and probability is not None:
                raise ValueError('`probability` ({}) must be a pylab.variables.Variable' \
                    ', a float, or None'.format(type(probability)))
            if util.isfloat(probability):
                if probability < 0 or probability > 1:
                    raise ValueError('`probability` ({}) must be in [0,1]'.format(
                        probability))
            probability = variables.Variable(value=probability, G=self.G, dtype=float,
                name=self.name+DEFAULT_PROBABILITY_SUFFIX)
        if not isclustervalue(indicator):
            if not util.isarray(indicator) and indicator is not None:
                raise ValueError('`indicator` ({}) must be a pylab.cluster.ClusterValue,' \
                    ' array, or None'.format(type(indicator)))
            if util.isarray(indicator):
                if len(indicator) != len(self.clustering):
                    raise ValueError('If `indicator` ({}) is an array, it must have the ' \
                        'same number of elements as number of clusters ({})'.format(
                            len(indicator), len(self.clustering)))
            ind = ClusterPerturbationIndicator(
                G=self.G, 
                name=self.name+DEFAULT_INDICATOR_SUFFIX,
                clustering=clustering,
                probability=probability,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)
            if util.isarray(indicator):
                ind.set_values_from_array(indicator)
            else:
                for cid in ind.clustering.order:
                    ind.value[cid] = False
            indicator = ind

        self.magnitude = magnitude
        self.indicator = indicator
        self.probability = probability

    def __str__(self):
        s = BasePerturbation.__str__(self)
        s += '\nMagnitude:\n'
        for cid in self.clustering.order:
            s += '\t{}: {}\n'.format(cid, self.magnitude.value[cid])
        s += 'Indicator:\n'
        for cid in self.clustering.order:
            s += '\t{}: {}\n'.format(cid, self.indicator.value[cid])
        s += 'Probability: {}'.format(self.probability.value)
        return s

    def otu_array(self, only_pos_ind=False):
        '''Expands the condensed form into a variable for each OTU
        in the data.

        Example
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            >>> np.ndarray([-0.5, 0, -0.5, 0, -0.5])
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        '''
        ind = self.indicator.otu_bool_array()
        if only_pos_ind:
            val = self.magnitude.otu_array()[ind]
        else:
            val = np.zeros(len(self.clustering.otus))
            val[ind] = self.magnitude.otu_array()[ind]
        return val

    def cluster_array(self, only_pos_ind=False):
        '''Make an array for each cluster with the magnitude

        Example
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            >>> np.ndarray([-0.5, 0])
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        '''
        ind = self.indicator.cluster_bool_array()
        if only_pos_ind:
            val = self.magnitude.cluster_array()[ind]
        else:
            val = np.zeros(len(self.clustering))
            val[ind] = self.magnitude.cluster_array()[ind]
        return val
    
    def add_trace(self):
        '''Set the negative indicators as np.nan
        '''
        self.value = np.full(len(self.clustering.otus), np.nan)
        ind = self.indicator.otu_arg_array()
        self.value[ind] = self.magnitude.otu_array()[ind]
        variables.Variable.add_trace(self)

    def add_init_value(self):
        '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        '''
        self.value = np.full(len(self.clustering.otus), np.nan)
        ind = self.indicator.otu_arg_array()
        self.value[ind] = self.magnitude.otu_array()[ind]
        variables.Variable.add_init_value(self)

    def set_values_from_array(self, values, use_indicators=True):
        '''Sets the values from an array of the same order as the clusters.

        Paramters
        ---------
        values : array_like
            An array of the values
            Must be the same length as the number of clusters is `use_indicators` 
            is False. If `use_indicators` is True, then the length must correspond
            to how many positive indicators there are.
        use_indicators : bool
            If True, the values  only correspond to positive interactions. Else
            the values correspond to every cluster
        '''
        if not util.isarray(values):
            raise ValueError('`values` ({}) must be an array'.format(type(values)))
        if not util.isbool(use_indicators):
            raise TypeError('`use_indicators` ({}) must be a bool'.format(
                type(use_indicators)))
        if not use_indicators:
            # Checking is done within this function
            self.magnitude.set_values_from_array(values)
        else:
            if len(values) != self.indicator.num_on_clusters():
                raise ValueError('The length of the array ({}) does not correspond' \
                    ' to how many on indicators there are ({})'.format(
                        len(values), self.indicator.num_on_clusters()))
            i = 0
            for cid in self.clustering.order:
                if self.indicator.value[cid]:
                    self.magnitude.value[cid] = values[i]
                    i += 1


class Interactions(ClusterProperty, Node, Traceable):
    '''This is a basic class for interactions between clusters.

    This is a 2D dictionary. The first level of the dictionary indexes the target 
    cluster and the second level indexes the source cluster. You can make this 2 
    layer dictionary into a matrix or a vector with functions defined in this class. 
    The reason why the data is stored in a 2D dictionary is because the number of 
    clusters changes constantly, so inserting and deleting values in a dictionary is more
    efficient than using a matrix/pandas.DataFrame. Additionally, the order of the clusters
    are changing constantly. Having them as a 2D dictionary allows us to reference the 
    interactions in the same order as the clusters as they are defined in `clusters`.

    Tracing
    -------
    The interactions get traced on an OTU-OTU bases. In this class we assume there are no
    interactions within a cluster. If the indicator is False, we set the trace to np.nan.
    To get the indicators call `np.nan_to_num` on the trace. We do not trace the indicators 
    separately, but you can get the trace of the interactions by calling ~np.isnan(self.trace).

    Indicators
    ----------
    You can choose whether to use or not use indicators for the interactions. If you choose
    not to use the indicators, then we assume that every indicator is positive.

    Iterators
    ---------
    These interactions assume the following order during iterating:
        For target cluster in clusters:
            For source cluster in clusters:
                if they are the same cluster, skip
                else yield value[target][source]
    Clusters are ordered in the same way as clustering.

    Value and indicator initialization
    ----------------------------------
    The values and indicators for a new interaction that gets made need to be initialized to 
    a value so we use the parameters `value_initializer` and  `inidicator_initializer`. If they
    are not specified then we return `np.nan` During initialization of the inference these are 
    usually set to the priors of the variables.

    The initializer for the indicator is assumed to either return a `bool` or a float betwen 
    [0,1]. It will set it to true if the sampled value is >= 0.5. There is no checking for 
    this though.

    Parameters
    ----------
    clustering : Clustering
        Clustering object
    use_indicators : bool
        If True, use indicators. If False do not use indicators (automatically sets all indicators)
        to True
    value_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior. 
        Defaults always returning np.nan.
    indicator_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior.         
        Defaults to always returning True
    '''
    def __init__(self, clustering, use_indicators, 
        value_initializer=None, indicator_initializer=None, 
        signal_when_clusters_change=True, **kwargs):

        Node.__init__(self, **kwargs)
        ClusterProperty.__init__(self, clustering=clustering, 
            signal_when_clusters_change=signal_when_clusters_change, 
            signal_when_otu_assignment_changes=False)

        if value_initializer is None:
            value_initializer = _always_return_nan
        if indicator_initializer is None:
            indicator_initializer = _always_return_nan
        if not np.all(util.itercheck([value_initializer, indicator_initializer], callable)):
            raise TypeError('`value_initializer` ({}) and `indicator_initializer` ({}) ' \
                'must be callable'.format(type(value_initializer), 
                type(indicator_initializer)))
        self.value_initializer = value_initializer
        self.indicator_initializer = indicator_initializer
        
        if not util.isbool(use_indicators):
            raise TypeError('`use_indicators` ({}) must be a bool'.format(type(use_indicators)))
        self.use_indicators = use_indicators
        if not self.use_indicators:
            self.indicator_initializer = _always_return_true

        order = self.clustering.order
        self.value = {}
        for tcid in order:
            self.value[tcid] = {}
            for scid in order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction( 
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer())

        self._shape = (len(self.clustering.otus), len(self.clustering.otus))
        self.dtype = float

    def __getitem__(self, key):
        return self.value[key]

    def __setitem__(self, key, val):
        self.value[key] = val

    def __iter__(self):
        '''Iterates over the interactions in order
        '''
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    yield temp[scid]

    def __str__(self):
        s=''
        for interaction in self:
            s += str(interaction) + '\n'
        return s
    
    @property
    def size(self):
        '''Return how many interactions there are possible according to the number of clusters.
        THIS IS NOT HOW MANY POSITIVE INTERACTIONS THERE ARE - USE `num_pos_interactions`

        Returns
        -------
        int
        '''
        n_clusters = len(self.clustering)
        return n_clusters * (n_clusters - 1)

    def iter_valid(self):
        '''Iterate only over the positive indicators
        '''
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield temp[scid]

    def iter_valid_pairs(self):
        '''Iterate only over the positive indicators
        '''
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield tcid, scid

    def iter_to_target(self, cid, only_valid=False):
        '''Iterates over interactions to the target cluster from all
        source clusters in the order specified by clusters

        Paramters
        ---------
        cid : int
            This is the target cluster id we are iterating from
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        '''
        order = self.clustering.order
        temp = self.value[cid] # For quicker pointer
        if only_valid:
            for scid in order:
                if scid != cid:
                    if temp[scid].indicator:
                        yield temp[scid]
        else:
            for scid in order:
                if scid != cid:
                    yield temp[scid]

    def iter_from_source(self, cid, only_valid=False):
        '''Iterates over interactions from the source cluster to all
        target clusters in the order specified by clusters

        Paramters
        ---------
        cid (int)
            This is the source cluster id
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        '''
        order = self.clustering.order
        if only_valid:
            for tcid in order:
                if tcid != cid:
                    if self.value[tcid][cid].indicator:
                        yield self.value[tcid][cid]
        else:
            for tcid in order:
                if tcid != cid:
                    yield self.value[tcid][cid]

    def reset(self):
        self.value = {}
        for tcid in self.clustering.order:
            self.value[tcid] = {}
            for scid in self.clustering.order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction(
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer()>=.5)

    def iloc(self, idx):
        '''Get the interaction as a function of the index that it occurs at.
        Reverse indexing is allowed.

        Parameters
        ----------
        idx : int
            This is the index that the interaction occurs at

        Returns
        -------
        pylab.contrib._Interaction
        '''
        if not util.isint(idx):
            raise TypeError('`idx` ({}) must be an int'.format(idx))
        if idx >= self.size:
            raise ValueError('`idx` ({}) cannot be >= the number of interactions ({})'.format(
                idx, self.size))
        if idx < 0:
            idx = self.size - idx
        tcidx = idx // (len(self.clustering) - 1)
        scidx = idx - tcidx * (len(self.clustering) - 1)
        if scidx >= tcidx:
            scidx += 1
        return self.value[
            self.clustering.order[tcidx]][
            self.clustering.order[scidx]]

    def clusters_changed(self, cids_added, cids_removed):
        '''Remove all of the interactions to and from the clusters
        in `cids_removed` and make interactions for the `cid_added`
        '''
        # Remove interactions from clusters deleted
        if len(cids_removed) > 0:
            for cid in cids_removed:
                self.value.pop(cid, None)
            for cid in self.value.keys():
                for cid_del in cids_removed:
                    self.value[cid].pop(cid_del, None)
        if len(cids_added) > 0:
            for cid in cids_added:
                self._add_single_cluster(cid)
        
    def _add_single_cluster(self, cid):
        other_cids = self.value.keys()
        # Add the interaction from clusters already there and 
        # the new cluster
        for ocid in other_cids:
            self.value[ocid][cid] = _Interaction(
                source_cid=cid, target_cid=ocid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() >= 0.5)
        self.value[cid] = {}
        for ocid in other_cids:
            self.value[cid][ocid] = _Interaction(
                source_cid=ocid, target_cid=cid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() >= 0.5)
    
    def key_pairs(self, only_valid=False):
        '''Returns (target,source) cluster ids in order

        Parameters
        ----------
        only_valid : bool
            If True, it will only return the key pairs that have a positive indicator.
            Else it will return all of the interactions regardless of the indicator.

        Returns 
        -------
        list((int,int))
            Return a list of the (target, source) cluster IDs for each interaciton
            in order.
        '''
        order = self.clustering.order
        l = []
        for tcid in order:
            for scid in order:
                if tcid != scid:
                    if only_valid:
                        if self.value[tcid][scid].indicator:
                            l.append((tcid, scid))
                    else:
                        l.append((tcid,scid))
        return l

    def num_neg_indicators(self, target_cid=None):
        '''Return the number of indicator variables that are 0

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the negative indicators going into the cluster 
            `target_cid`
        '''
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += not interaction.indicator
        else:
            for interaction in self:
                cumm += not interaction.indicator
        return cumm

    def num_pos_indicators(self, target_cid=None):
        '''Return the number of indicator variables that are 1

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the positive indicators going into the cluster 
            `target_cid`
        '''
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += interaction.indicator
        else:
            for interaction in self:
                cumm += interaction.indicator
        return cumm

    def get_arg_indicators(self, target_cid=None, source_cid=None):
        '''Get the positive indicators as indices, in order -> same convention
        as `get_indicators`.

        If `target_cid` is specfied, it will get all of the positive indicator indicies 
        going to the target cluster `target_cid` in order. If `source_cid` is specified,
        then it will get all of the positive indicator indices going to the source cluster 
        `source_cid` in order. If both `target_cid` and `source_cid` are specified,
        it will return an empty array if the indicator is False or it will return
        an array of size 1 if the indicator is True.

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.

        Returns
        -------
        list(int)
            Returns a list of the interactions that are positive in order
        '''
        ret = []
        try:
            if target_cid is not None:
                n_clusters = len(self.clustering)
                tcidx = self.clustering.cid2cidx[target_cid]

                if source_cid is not None:
                    if self.value[target_cid][source_cid].indicator:
                        scidx = self.clustering.cid2cidx[source_cid]
                        if tcidx < scidx:
                            scidx -= 1
                        iidx = tcidx * (n_clusters - 1) + scidx
                        ret.append(iidx)
                else:
                    base_idx = tcidx * (n_clusters - 1)
                    for offset, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            ret.append(base_idx + offset)
            
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                scidx = self.clustering.cid2cidx[source_cid]
                for interaction in self.iter_from_source(source_cid):
                    if interaction.indicator:
                        tcidx = self.clustering.cid2cidx[interaction.target_cid]

                        iidx = tcidx * (n_clusters - 1) + scidx
                        if scidx > tcidx:
                            iidx -= 1
                        ret.append(iidx)

            else:
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        ret.append(idx)
            return ret
        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError('`Either `target_cid` ({}) or `source_cid` ({})' \
                        ' must be an int'.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError('`target_cid` ({}) and `source_cid` ({}) cannot' \
                        ' be the same'.format(target_cid, source_cid))
            raise

    def get_indicators(self, target_cid=None, source_cid=None):
        '''Return a the indicator variables as a vector in the order specified
        by the clusters.

        if `target_cid` is specified then it will return all indicators going
        to that cluster. If `source_cid` is specified then it will return all
        indicators going from that cluster. If both are specifeid then it
        will return an array of size 1 of a bool

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.

        Returns
        -------
        np.ndarray(n, dtype=bool)
            Returns a bool vector of the indicators in roder
        '''
        try:
            if target_cid is not None:
                if source_cid is not None:
                    ret = np.asarray([self.value[target_cid][source_cid].indicator])
                else:
                    l = len(self.clustering) - 1
                    ret = np.zeros(l, dtype=bool)
                    for iidx, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            ret[iidx] = True
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                l = len(self.clustering) - 1
                ret = np.zeros(l, dtype=bool)
                for iidx, interaction in enumerate(self.iter_from_source(source_cid)):
                    if interaction.indicator:
                        ret[iidx] = True

            else:
                ret = np.zeros(self.size, dtype=bool)
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        ret[idx] = True
                return ret

            return ret

        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError('`Either `target_cid` ({}) or `source_cid` ({})' \
                        ' must be an int'.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError('`target_cid` ({}) and `source_cid` ({}) cannot' \
                        ' be the same'.format(target_cid, source_cid))
            raise

    def set_indicators(self, arr):
        '''Sets the values of the indicators of the interactions from a vector.

        If `include_self_interactions` is True, assumes that `arr` contains the
        values for the self interactions. If False, assume that the indices are
        skipped.

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=bool)
            These are the indicator values to set, in order
        '''
        if len(arr) != self.size:
            raise ValueError('The number of elements in `arr` ({}) is not the ' \
                'same as the number of interactions ({})'.format(len(arr), self.size))
        for idx, interaction in enumerate(self):
            interaction.indicator = arr[idx]
            if interaction.indicator == 0:
                interaction.value = 0

    def set_values(self, arr, use_indicators=True):
        '''Sets the values of the interactions from a vector.

        If `use_indicators` is True, assumes that the values in the vector only contain
        values for interactions where the indicator variable is positive and the
        rest are skipped. If False, assumes the vector has values for where the
        indicator variables are positive and negative (all).

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=float)
            These are the interaction values to set, in order
        use_indicators : bool, Optional
            If True, we only set the interactions with a positive indicator. Else we set every
            single interaction
        '''
        if not use_indicators:
            if len(arr) != self.size:
                raise ValueError('The number of elements in `arr` ({}) is not the ' \
                    'same as the number of interactions ({})'.format(len(arr), self.size))
            for idx, interaction in enumerate(self):
                interaction.value = arr[idx]
        else:
            # Dont check because it is too computationally intensive
            idx = 0
            for interaction in self:
                if not interaction.indicator:
                    continue
                interaction.value = arr[idx]
                idx += 1

    def get_values(self, use_indicators=True):
        '''Makes a vector of the interaction variables in the order of the
        clustering

        if use_indicators is True, it skips over the indices that have a negative
        indicator variable. if it is True, it goes over everthing

         Paramters
        ---------
        use_indicators : bool, Optional
            If True, we only return the interactions with a positive indicator. Else we get every
            single interaction

        Returns
        -------
        np.ndarray(n, dtype=float)
            Array of the interaction values, in order
        '''
        ret = np.zeros(self.size)
        idx = 0
        if use_indicators:
            for interaction in self.iter_valid():
                ret[idx] = interaction.value
                idx += 1
        else:
            for interaction in self:
                ret[idx] = interaction.value
                idx += 1
        # Trim if necessary
        return ret[:idx]

    def get_value_matrix(self, set_neg_indicators_to_nan=False):
        '''Get the interaction matrix at the clustert level (OTU-OTU). 
        The ordering of the clusters is the same as it is in clustering

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the OTU-OTU interaction value matrix
        '''
        n_clusters = len(self.clustering)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_clusters, n_clusters), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            tcidx = self.clustering.cid2cidx[interaction.target_cid]
            scidx = self.clustering.cid2cidx[interaction.source_cid]
            ret[tcidx, scidx] = interaction.value
        return ret

    def get_datalevel_value_matrix(self, set_neg_indicators_to_nan=False):
        '''Get the interaction matrix at the data level (OTU-OTU), not
        at the cluster level. The ordering of the OTUs is the same as 
        it is in the otuset in clustering (self.clustering.otus).

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the OTU-OTU interaction value matrix
        '''
        n_otus = len(self.clustering.otus)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_otus, n_otus), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            val = interaction.value
            for toidx in self.clustering.clusters[interaction.target_cid].members:
                for soidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[toidx, soidx] = val
        return ret
    
    def get_datalevel_indicator_matrix(self):
        '''Get the otu-otu indicator matrix.

        The ordering of the otus are the same as the order in
        self.clusters.otus.ids.order

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the OTU-OTU interaction value matrix
        '''
        n_otus = len(self.clustering.otus)
        ret = np.zeros(shape=(n_otus, n_otus), dtype=bool)
        for interaction in self:
            if not interaction.indicator:
                continue
            for toidx in self.clustering.clusters[interaction.target_cid].members:
                for soidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[toidx, soidx] = True
        return ret

    def generate_bayes_factors_posthoc(self, prior):
        '''Generates the bayes factors on an OTU-OTU level, given the passed in prior.

        All negative indicators are set as `np.nan`s in the trace, so we do `~np.isnan`
        to get the indicators

        Parameters
        ----------
        prior : pylab.variables.Beta
            This assumes this is a beta distribution for the prior

        Returns
        -------
        np.ndarray((n,n), dtpye=float)
            These are the bayes factors for each of the interactions on an OTU-OTU level
        '''
        prior_factor = (prior.b + 1) / (prior.a + 1)
        trace = self.get_trace_from_disk()
        trace = ~ np.isnan(trace)
        ret = variables.summary(trace)['mean']
        ret = ret / (1. - ret)
        return ret * prior_factor

    def generate_in_out_degree_posthoc(self, section='posterior'):
        '''Returns a dictionary of arrays
        "in"
            For each index in the array, corresponding to the index of the OTUs, returns
            the number of incoming interactions for each iteration of the OTU
        "out"
            For each index in the array, corresponding to the index of the OTUs, returns
            the number of outgoing interactions for each iteration of the OTU

        Parameters
        ----------
        section : str
            Which section of the inference you want to choose. 
            Options:
                'posterior'
                    Only look at the posterior
                'burnin'
                    Returns the samples that were in the burnin
                'entire'
                    Returns all the samples
        '''
        trace = self.get_trace_from_disk(section=section)
        trace = ~np.isnan(trace)
        return {'in': np.sum(trace, axis=2), 'out':np.sum(trace, axis=1)}

    def set_trace(self):
        '''Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        '''
        tracer = self.G.tracer
        tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)

        self.ckpt_iter = 0
        self.sample_iter = 0
        shape = (tracer.ckpt, ) + self._shape
        self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)

    def add_trace(self):
        '''Adds the current value to the trace. If the buffer is full
        it will end it to disk
        '''
        self.trace[self.ckpt_iter] = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            shape = (self.G.tracer.ckpt, ) + self._shape
            self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
            self.ckpt_iter = 0

    def add_init_value(self):
        '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        '''
        self._init_value = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)

    def get_adjacent(self, cid, incoming, outgoing, use_indicators=True):
        '''Get all of the cluster IDs that have a positive interaction going into
        or from the cluster `cid`.

        Parameters
        ----------
        cid : int
            This is the Cluster ID you want to get the adjacent clusters of
        incoming : bool 
            Get the cids of the incoming edges
        outgoing : bool
            Get the cids of the outgoing edges
        use_indicators : bool
            If this is True then if the indicator is False then we do not include.
            If this is False then we always include the interaction

        Returns
        -------
        list
            List of cids
        '''
        if cid not in self.clustering.order:
            raise ValueError('`cid` ({}) not found'.format(cid))
        cids = []
        if incoming:
            for interaction in self.iter_from_source(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.target_cid)
        if outgoing:
            for interaction in self.iter_to_target(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.source_cid)
        return cids
        

class _Interaction:
    '''Defines an interaction from cluster `source` to cluster `target`.

    Parameters
    ----------
    source_cid : int
        Unique id of the source cluster
    target_cid : int
        Unique id of the target cluster
    value : numeric
        The value of the interaction
    indicator : bool
        Indicator variable of the interaction
    id : int
        Unique identifier of this interaction object
    '''
    def __init__(self, source_cid, target_cid, value, indicator):
        self.source_cid = source_cid
        self.target_cid = target_cid
        self.value = value
        self.indicator = indicator
        self.id = id(self)

    def __str__(self):
        return 'Interaction {}\n' \
            '\tTarget cluster: {}\n' \
            '\tSource cluster: {}\n' \
            '\tValue: {}\n' \
            '\tIndicator: {}\n'.format(
                self.id,
                self.target_cid,
                self.source_cid,
                self.value,
                self.indicator)


def _always_return_true(*args, **kwargs):
    return True

def _always_return_nan(*args, **kwargs):
    return np.nan

</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="pylab.contrib.DEFAULT_INDICATOR_SUFFIX" class="name">var <span class="ident">DEFAULT_INDICATOR_SUFFIX</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.contrib.DEFAULT_MAGNITUDE_SUFFIX" class="name">var <span class="ident">DEFAULT_MAGNITUDE_SUFFIX</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.contrib.DEFAULT_PROBABILITY_SUFFIX" class="name">var <span class="ident">DEFAULT_PROBABILITY_SUFFIX</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.contrib.DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE" class="name">var <span class="ident">DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.contrib.DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES" class="name">var <span class="ident">DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pylab.contrib.isclusterperturbation">
    <p>def <span class="ident">isclusterperturbation</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of ClusterPerturbation</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of ClusterPerturbation</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type ClusterPerturbation, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.isclusterperturbation', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.isclusterperturbation" class="source">
    <pre><code>def isclusterperturbation(x):
    '''Checks whether the input is a subclass of ClusterPerturbation

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbation
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbation, else False
    '''
    return x is not None and issubclass(x.__class__, ClusterPerturbation)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.contrib.isclusterperturbationindicator">
    <p>def <span class="ident">isclusterperturbationindicator</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of ClusterPerturbationIndicator</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of ClusterPerturbationIndicator</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type ClusterPerturbationIndicator, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.isclusterperturbationindicator', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.isclusterperturbationindicator" class="source">
    <pre><code>def isclusterperturbationindicator(x):
    '''Checks whether the input is a subclass of ClusterPerturbationIndicator

    Parameters
    ----------
    x : any
        Input instance to check the type of ClusterPerturbationIndicator
    
    Returns
    -------
    bool
        True if `x` is of type ClusterPerturbationIndicator, else False
    '''
    return x is not None and issubclass(x.__class__, ClusterPerturbationIndicator)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.contrib.isinteractions">
    <p>def <span class="ident">isinteractions</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Type check if <code>x</code> is a subclass of Interactions</p>
<h2>Parameters</h2>
<p>x : any
    Returns True if <code>x</code> is a subclass of Interactions</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is the correct subtype</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.isinteractions', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.isinteractions" class="source">
    <pre><code>def isinteractions(x):
    '''Type check if `x` is a subclass of Interactions

    Parameters
    ----------
    x : any
        Returns True if `x` is a subclass of Interactions
    
    Returns
    -------
    bool
        True if `x` is the correct subtype
    '''
    return x is not None and issubclass(x.__class__, Interactions)
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pylab.contrib.ClusterPerturbation" class="name">class <span class="ident">ClusterPerturbation</span></p>
      
  
    <div class="desc"><p>This is an basic implementation for a cluster level perturbation.
We trace the values at the OTU level.</p>
<p>If you want to compute the bayes factors for each OTU, you can 
calculate ~np.isnan for the trace. This will give an indicator 
array that you can then use to calculate the bayes factor.</p>
<h2>Parameters</h2>
<p>start, end : int, float
    - Start and end of the perturbation
clustering : pylab.cluster.Clustering
    - This is the clustering object it is being set with
magnitude : pylab.variables.Variable, pylab.cluster.ClusterValue, int/float, array, Optional
    - If a pylab.variables.Variable is passed in it will create one
      with the value indicated. Defualt value is None
indicator : pylab.cluster.ClusterValue, array, Optional
    - This is the indicator of the interaction (vector, an indicator
      for every cluster). Default value is False for every cluster
probability : pylab.variables.Variable, float, Optional
    - This is the probability that the perturbation affects a cluster, e.g.
      probability = 0.7, there's a 70% chance that the perturbation afffects 
      each cluster
kwargs : dict
    - Extra arguments for the Node class</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation" class="source">
    <pre><code>class ClusterPerturbation(BasePerturbation, variables.Variable):
    '''This is an basic implementation for a cluster level perturbation.
    We trace the values at the OTU level.

    If you want to compute the bayes factors for each OTU, you can 
    calculate ~np.isnan for the trace. This will give an indicator 
    array that you can then use to calculate the bayes factor.
    
    Parameters
    ----------
    start, end : int, float
        - Start and end of the perturbation
    clustering : pylab.cluster.Clustering
        - This is the clustering object it is being set with
    magnitude : pylab.variables.Variable, pylab.cluster.ClusterValue, int/float, array, Optional
        - If a pylab.variables.Variable is passed in it will create one
          with the value indicated. Defualt value is None
    indicator : pylab.cluster.ClusterValue, array, Optional
        - This is the indicator of the interaction (vector, an indicator
          for every cluster). Default value is False for every cluster
    probability : pylab.variables.Variable, float, Optional
        - This is the probability that the perturbation affects a cluster, e.g.
          probability = 0.7, there's a 70% chance that the perturbation afffects 
          each cluster
    kwargs : dict
        - Extra arguments for the Node class
    '''
    def __init__(self, start, end, clustering,
        magnitude=None, indicator=None, probability=None,
        signal_when_clusters_change=False,
        signal_when_otu_assignment_changes=False, **kwargs):

        if signal_when_clusters_change is None:
            signal_when_clusters_change = DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE
        if signal_when_otu_assignment_changes is None:
            signal_when_otu_assignment_changes = DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES
        if not isclustering(clustering):
            raise TypeError('`clustering` ({}) must be a pylab.cluster.Clustering object'.format(
                type(clustering)))
        

        BasePerturbation.__init__(self, start=start, end=end)
        variables.Variable.__init__(self, **kwargs)
        if self.G.perturbations is None:
            self.G.perturbations = []
        self.G.perturbations.append(self)
        self.clustering = clustering
        self.set_value_shape(shape=(len(self.clustering.otus), ))
        if magnitude is not None:
            if util.isarray(magnitude):
                temp = ClusterPerturbationValue(clustering=clustering, 
                    G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                    signal_when_clusters_change=signal_when_clusters_change,
                    signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)
                temp.set_values_from_array(magnitude)
                magnitude=temp
            elif not isclustervalue(magnitude):
                raise TypeError('`magnitude` ({})' \
                    ' must be an array or a pylab.cluster.ClusterValue'.format(type(magnitude)))
        else:
            magnitude = ClusterPerturbationValue(clustering=clustering, 
                G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)            

        if not variables.isVariable(probability):
            if not util.isfloat(probability) and probability is not None:
                raise ValueError('`probability` ({}) must be a pylab.variables.Variable' \
                    ', a float, or None'.format(type(probability)))
            if util.isfloat(probability):
                if probability < 0 or probability > 1:
                    raise ValueError('`probability` ({}) must be in [0,1]'.format(
                        probability))
            probability = variables.Variable(value=probability, G=self.G, dtype=float,
                name=self.name+DEFAULT_PROBABILITY_SUFFIX)
        if not isclustervalue(indicator):
            if not util.isarray(indicator) and indicator is not None:
                raise ValueError('`indicator` ({}) must be a pylab.cluster.ClusterValue,' \
                    ' array, or None'.format(type(indicator)))
            if util.isarray(indicator):
                if len(indicator) != len(self.clustering):
                    raise ValueError('If `indicator` ({}) is an array, it must have the ' \
                        'same number of elements as number of clusters ({})'.format(
                            len(indicator), len(self.clustering)))
            ind = ClusterPerturbationIndicator(
                G=self.G, 
                name=self.name+DEFAULT_INDICATOR_SUFFIX,
                clustering=clustering,
                probability=probability,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)
            if util.isarray(indicator):
                ind.set_values_from_array(indicator)
            else:
                for cid in ind.clustering.order:
                    ind.value[cid] = False
            indicator = ind

        self.magnitude = magnitude
        self.indicator = indicator
        self.probability = probability

    def __str__(self):
        s = BasePerturbation.__str__(self)
        s += '\nMagnitude:\n'
        for cid in self.clustering.order:
            s += '\t{}: {}\n'.format(cid, self.magnitude.value[cid])
        s += 'Indicator:\n'
        for cid in self.clustering.order:
            s += '\t{}: {}\n'.format(cid, self.indicator.value[cid])
        s += 'Probability: {}'.format(self.probability.value)
        return s

    def otu_array(self, only_pos_ind=False):
        '''Expands the condensed form into a variable for each OTU
        in the data.

        Example
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            >>> np.ndarray([-0.5, 0, -0.5, 0, -0.5])
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        '''
        ind = self.indicator.otu_bool_array()
        if only_pos_ind:
            val = self.magnitude.otu_array()[ind]
        else:
            val = np.zeros(len(self.clustering.otus))
            val[ind] = self.magnitude.otu_array()[ind]
        return val

    def cluster_array(self, only_pos_ind=False):
        '''Make an array for each cluster with the magnitude

        Example
            ** Cluster assignments **
            cluster1 = {0,2,4}
            cluster2 = {1,3}

            ** Cluster indicators for perturbation **
            value[cluster1] = True
            value[cluster2] = False

            magnitude.value = -0.5

            >>> np.ndarray([-0.5, 0])
        
        Parameters
        ----------
        only_pos_ind : bool
            If this is True, then it will return only for when the indicator is positive

        Returns
        -------
        np.ndarray((n_c,), dtype=float)
            Array of the cluster perturbation values for each cluster
        '''
        ind = self.indicator.cluster_bool_array()
        if only_pos_ind:
            val = self.magnitude.cluster_array()[ind]
        else:
            val = np.zeros(len(self.clustering))
            val[ind] = self.magnitude.cluster_array()[ind]
        return val
    
    def add_trace(self):
        '''Set the negative indicators as np.nan
        '''
        self.value = np.full(len(self.clustering.otus), np.nan)
        ind = self.indicator.otu_arg_array()
        self.value[ind] = self.magnitude.otu_array()[ind]
        variables.Variable.add_trace(self)

    def add_init_value(self):
        '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        '''
        self.value = np.full(len(self.clustering.otus), np.nan)
        ind = self.indicator.otu_arg_array()
        self.value[ind] = self.magnitude.otu_array()[ind]
        variables.Variable.add_init_value(self)

    def set_values_from_array(self, values, use_indicators=True):
        '''Sets the values from an array of the same order as the clusters.

        Paramters
        ---------
        values : array_like
            An array of the values
            Must be the same length as the number of clusters is `use_indicators` 
            is False. If `use_indicators` is True, then the length must correspond
            to how many positive indicators there are.
        use_indicators : bool
            If True, the values  only correspond to positive interactions. Else
            the values correspond to every cluster
        '''
        if not util.isarray(values):
            raise ValueError('`values` ({}) must be an array'.format(type(values)))
        if not util.isbool(use_indicators):
            raise TypeError('`use_indicators` ({}) must be a bool'.format(
                type(use_indicators)))
        if not use_indicators:
            # Checking is done within this function
            self.magnitude.set_values_from_array(values)
        else:
            if len(values) != self.indicator.num_on_clusters():
                raise ValueError('The length of the array ({}) does not correspond' \
                    ' to how many on indicators there are ({})'.format(
                        len(values), self.indicator.num_on_clusters()))
            i = 0
            for cid in self.clustering.order:
                if self.indicator.value[cid]:
                    self.magnitude.value[cid] = values[i]
                    i += 1
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.contrib.ClusterPerturbation">ClusterPerturbation</a></li>
          <li>pylab.base.BasePerturbation</li>
          <li>pylab.variables.Variable</li>
          <li>pylab.graph.Node</li>
          <li>pylab.graph.BaseNode</li>
          <li>pylab.base.Saveable</li>
          <li>pylab.variables._BaseArithmeticClass</li>
          <li>pylab.base.Traceable</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, start, end, clustering, magnitude=None, indicator=None, probability=None, signal_when_clusters_change=False, signal_when_otu_assignment_changes=False, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.__init__" class="source">
    <pre><code>def __init__(self, start, end, clustering,
    magnitude=None, indicator=None, probability=None,
    signal_when_clusters_change=False,
    signal_when_otu_assignment_changes=False, **kwargs):
    if signal_when_clusters_change is None:
        signal_when_clusters_change = DEFAULT_SIGNAL_WHEN_CLUSTERS_CHANGE
    if signal_when_otu_assignment_changes is None:
        signal_when_otu_assignment_changes = DEFAULT_SIGNAL_WHEN_OTU_ASSIGNMENT_CHANGES
    if not isclustering(clustering):
        raise TypeError('`clustering` ({}) must be a pylab.cluster.Clustering object'.format(
            type(clustering)))
    
    BasePerturbation.__init__(self, start=start, end=end)
    variables.Variable.__init__(self, **kwargs)
    if self.G.perturbations is None:
        self.G.perturbations = []
    self.G.perturbations.append(self)
    self.clustering = clustering
    self.set_value_shape(shape=(len(self.clustering.otus), ))
    if magnitude is not None:
        if util.isarray(magnitude):
            temp = ClusterPerturbationValue(clustering=clustering, 
                G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
                signal_when_clusters_change=signal_when_clusters_change,
                signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)
            temp.set_values_from_array(magnitude)
            magnitude=temp
        elif not isclustervalue(magnitude):
            raise TypeError('`magnitude` ({})' \
                ' must be an array or a pylab.cluster.ClusterValue'.format(type(magnitude)))
    else:
        magnitude = ClusterPerturbationValue(clustering=clustering, 
            G=self.G, dtype=float, name=self.name+DEFAULT_MAGNITUDE_SUFFIX,
            signal_when_clusters_change=signal_when_clusters_change,
            signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)            
    if not variables.isVariable(probability):
        if not util.isfloat(probability) and probability is not None:
            raise ValueError('`probability` ({}) must be a pylab.variables.Variable' \
                ', a float, or None'.format(type(probability)))
        if util.isfloat(probability):
            if probability < 0 or probability > 1:
                raise ValueError('`probability` ({}) must be in [0,1]'.format(
                    probability))
        probability = variables.Variable(value=probability, G=self.G, dtype=float,
            name=self.name+DEFAULT_PROBABILITY_SUFFIX)
    if not isclustervalue(indicator):
        if not util.isarray(indicator) and indicator is not None:
            raise ValueError('`indicator` ({}) must be a pylab.cluster.ClusterValue,' \
                ' array, or None'.format(type(indicator)))
        if util.isarray(indicator):
            if len(indicator) != len(self.clustering):
                raise ValueError('If `indicator` ({}) is an array, it must have the ' \
                    'same number of elements as number of clusters ({})'.format(
                        len(indicator), len(self.clustering)))
        ind = ClusterPerturbationIndicator(
            G=self.G, 
            name=self.name+DEFAULT_INDICATOR_SUFFIX,
            clustering=clustering,
            probability=probability,
            signal_when_clusters_change=signal_when_clusters_change,
            signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)
        if util.isarray(indicator):
            ind.set_values_from_array(indicator)
        else:
            for cid in ind.clustering.order:
                ind.value[cid] = False
        indicator = ind
    self.magnitude = magnitude
    self.indicator = indicator
    self.probability = probability
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.add_child">
    <p>def <span class="ident">add_child</span>(</p><p>self, child)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>child</code> as a child to the node
Also adds self as a parent to <code>child</code></p>
<h2>Parameters</h2>
<p>child : Node
    - node we want to set as a child</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.add_child', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.add_child" class="source">
    <pre><code>def add_child(self, child):
    '''Adds `child` as a child to the node
    Also adds self as a parent to `child`
    Parameters
    ----------
    child : Node
        - node we want to set as a child
    '''
    if not isnode(child):
        raise ValueError('child ({}) must be a (subclass of) Node'.format( 
            type(child)))
    if self.G.id != child.G.id:
        raise GraphIDError('Attempting to add a child `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, child.name))
    self.children[child.id] = child
    child.parents[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.add_init_value">
    <p>def <span class="ident">add_init_value</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the initialization value. This is called by <code>pylab.inference.BaseMCMC.run</code>
when first updating the variable. User should not use this function</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.add_init_value', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.add_init_value" class="source">
    <pre><code>def add_init_value(self):
    '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
    when first updating the variable. User should not use this function
    '''
    self.value = np.full(len(self.clustering.otus), np.nan)
    ind = self.indicator.otu_arg_array()
    self.value[ind] = self.magnitude.otu_array()[ind]
    variables.Variable.add_init_value(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.add_parent">
    <p>def <span class="ident">add_parent</span>(</p><p>self, parent)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>parent</code> as a parent to the node
Also adds self as a child to <code>parent</code></p>
<h2>Parameters</h2>
<p>parent : Node
    - node we want to set as a parent</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.add_parent', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.add_parent" class="source">
    <pre><code>def add_parent(self, parent):
    '''Adds `parent` as a parent to the node
    Also adds self as a child to `parent`
    Parameters
    ----------
    parent : Node
        - node we want to set as a parent
    '''
    if not isnode(parent):
        raise ValueError('parent ({}) must be a (subclass of) Node'.format( 
            type(parent)))
    if self.G.id != parent.G.id:
        raise GraphIDError('Attempting to add a parent `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, parent.name))
    self.parents[parent.id] = parent
    parent.children[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.add_prior">
    <p>def <span class="ident">add_prior</span>(</p><p>self, prior)</p>
    </div>
    

    
  
    <div class="desc"><p>Override the name of the passed in distribution <code>prior</code>.</p>
<h2>Parameters</h2>
<p>prior : Node
    - node we want to set as a prior</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.add_prior', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.add_prior" class="source">
    <pre><code>def add_prior(self, prior):
    '''Override the name of the passed in distribution `prior`.
    Parameters
    ----------
    prior : Node
        - node we want to set as a prior
    '''
    if not isnode(prior):
        raise ValueError('prior ({}) must be a (subclass of) Node'.format( 
            type(prior)))
    self.add_parent(prior)
    self.prior = prior
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.add_trace">
    <p>def <span class="ident">add_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the negative indicators as np.nan</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.add_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.add_trace" class="source">
    <pre><code>def add_trace(self):
    '''Set the negative indicators as np.nan
    '''
    self.value = np.full(len(self.clustering.otus), np.nan)
    ind = self.indicator.otu_arg_array()
    self.value[ind] = self.magnitude.otu_array()[ind]
    variables.Variable.add_trace(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.add_undirected">
    <p>def <span class="ident">add_undirected</span>(</p><p>self, node)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>node</code> as an undirected neighbor to the node
Does the same for <code>node</code></p>
<h2>Parameters</h2>
<p>node : Node
    - node we want to set as an undirected node</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.add_undirected', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.add_undirected" class="source">
    <pre><code>def add_undirected(self, node):
    '''Adds `node` as an undirected neighbor to the node
    Does the same for `node`
    Parameters
    ----------
    node : Node
        - node we want to set as an undirected node
    '''
    if not isnode(node):
        raise ValueError('node ({}) must be a (subclass of) Node'.format( 
            type(node)))
    if self.G.id != node.G.id:
        raise GraphIDError('Attempting to add a node `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, node.name))
    self.undirected[node.id] = node
    node.undirected[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.cluster_array">
    <p>def <span class="ident">cluster_array</span>(</p><p>self, only_pos_ind=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Make an array for each cluster with the magnitude</p>
<p>Example
    <strong> Cluster assignments </strong>
    cluster1 = {0,2,4}
    cluster2 = {1,3}</p>
<pre><code>** Cluster indicators for perturbation **
value[cluster1] = True
value[cluster2] = False

magnitude.value = -0.5

&gt;&gt;&gt; np.ndarray([-0.5, 0])
</code></pre>
<h2>Parameters</h2>
<p>only_pos_ind : bool
    If this is True, then it will return only for when the indicator is positive</p>
<h2>Returns</h2>
<p>np.ndarray((n_c,), dtype=float)
    Array of the cluster perturbation values for each cluster</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.cluster_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.cluster_array" class="source">
    <pre><code>def cluster_array(self, only_pos_ind=False):
    '''Make an array for each cluster with the magnitude
    Example
        ** Cluster assignments **
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        ** Cluster indicators for perturbation **
        value[cluster1] = True
        value[cluster2] = False
        magnitude.value = -0.5
        >>> np.ndarray([-0.5, 0])
    
    Parameters
    ----------
    only_pos_ind : bool
        If this is True, then it will return only for when the indicator is positive
    Returns
    -------
    np.ndarray((n_c,), dtype=float)
        Array of the cluster perturbation values for each cluster
    '''
    ind = self.indicator.cluster_bool_array()
    if only_pos_ind:
        val = self.magnitude.cluster_array()[ind]
    else:
        val = np.zeros(len(self.clustering))
        val[ind] = self.magnitude.cluster_array()[ind]
    return val
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.delete">
    <p>def <span class="ident">delete</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete itself from the graph</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.delete', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.delete" class="source">
    <pre><code>def delete(self):
    '''Delete itself from the graph
    '''
    if len(self.parents) > 0:
        for pid in self.parents:
            self.G.nodes[pid].children.pop(self.id, None)
    if len(self.children) > 0:
        for cid in self.children:
            self.G.nodes[cid].parents.pop(self.id, None)
    if len(self.undirected) > 0:
        for uid in self.undirected:
            self.G.nodes[uid].undirected.pop(self.id, None)
    BaseNode.delete(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.get_adjacent_keys">
    <p>def <span class="ident">get_adjacent_keys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the adjacent nodes</p>
<h2>Returns</h2>
<p>list(int)
    A list of all the IDs of the adjacent nodes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.get_adjacent_keys', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.get_adjacent_keys" class="source">
    <pre><code>def get_adjacent_keys(self):
    '''Get the adjacent nodes
    Returns
    -------
    list(int)
        A list of all the IDs of the adjacent nodes
    '''
    return list(self.parents.keys()) + list(self.children.keys())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.get_iter">
    <p>def <span class="ident">get_iter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the number of iterations saved to the hdf5 file of the variable</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.get_iter', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.get_iter" class="source">
    <pre><code>def get_iter(self):
    '''Get the number of iterations saved to the hdf5 file of the variable
    Returns
    -------
    int
    '''
    return self.G.tracer.get_iter(name=self.name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.get_trace_from_disk">
    <p>def <span class="ident">get_trace_from_disk</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
include the samples in the local buffer trace and could be very large</p>
<h2>Returns</h2>
<p>np.ndarray</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.get_trace_from_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.get_trace_from_disk" class="source">
    <pre><code>def get_trace_from_disk(self, *args, **kwargs):
    '''Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
    include the samples in the local buffer trace and could be very large
    Returns
    -------
    np.ndarray
    '''
    return self.G.tracer.get_trace(name=self.name, *args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.isactive">
    <p>def <span class="ident">isactive</span>(</p><p>self, time)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a <code>bool</code> if the perturbation is on at time <code>time</code>.</p>
<h2>Parameters</h2>
<p>time : float, int
    Time to check</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.isactive', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.isactive" class="source">
    <pre><code>def isactive(self, time):
    '''Returns a `bool` if the perturbation is on at time `time`.
    Parameters
    ----------
    time : float, int
        Time to check
    '''
    return time > self.start and time <= self.end
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.otu_array">
    <p>def <span class="ident">otu_array</span>(</p><p>self, only_pos_ind=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Expands the condensed form into a variable for each OTU
in the data.</p>
<p>Example
    <strong> Cluster assignments </strong>
    cluster1 = {0,2,4}
    cluster2 = {1,3}</p>
<pre><code>** Cluster indicators for perturbation **
value[cluster1] = True
value[cluster2] = False

magnitude.value = -0.5

&gt;&gt;&gt; np.ndarray([-0.5, 0, -0.5, 0, -0.5])
</code></pre>
<h2>Parameters</h2>
<p>only_pos_ind : bool
    If this is True, then it will return only for when the indicator is positive</p>
<h2>Returns</h2>
<p>np.ndarray((n_c,), dtype=float)
    Array of the cluster perturbation values for each cluster</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.otu_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.otu_array" class="source">
    <pre><code>def otu_array(self, only_pos_ind=False):
    '''Expands the condensed form into a variable for each OTU
    in the data.
    Example
        ** Cluster assignments **
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        ** Cluster indicators for perturbation **
        value[cluster1] = True
        value[cluster2] = False
        magnitude.value = -0.5
        >>> np.ndarray([-0.5, 0, -0.5, 0, -0.5])
    
    Parameters
    ----------
    only_pos_ind : bool
        If this is True, then it will return only for when the indicator is positive
    Returns
    -------
    np.ndarray((n_c,), dtype=float)
        Array of the cluster perturbation values for each cluster
    '''
    ind = self.indicator.otu_bool_array()
    if only_pos_ind:
        val = self.magnitude.otu_array()[ind]
    else:
        val = np.zeros(len(self.clustering.otus))
        val[ind] = self.magnitude.otu_array()[ind]
    return val
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.overwrite_entire_trace_on_disk">
    <p>def <span class="ident">overwrite_entire_trace_on_disk</span>(</p><p>self, data, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrites the entire trace of the variable with the given data.</p>
<h2>Parameters</h2>
<p>data : np.ndarray
    Data you are overwriting the trace with.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.overwrite_entire_trace_on_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.overwrite_entire_trace_on_disk" class="source">
    <pre><code>def overwrite_entire_trace_on_disk(self, data, **kwargs):
    '''Overwrites the entire trace of the variable with the given data.
    Parameters
    ----------
    data : np.ndarray
        Data you are overwriting the trace with.
    '''
    self.G.tracer.overwrite_entire_trace_on_disk(
        name=self.name, data=data, dtype=self.dtype, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <code>pylab.base.Saveable.set_save_location</code>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.set_trace">
    <p>def <span class="ident">set_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the trace arrays for the variable in the Tracer object. </p>
<p>It will initialize a buffer the size of the checkpoint size in Tracer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.set_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.set_trace" class="source">
    <pre><code>def set_trace(self):
    '''Initialize the trace arrays for the variable in the Tracer object. 
    It will initialize a buffer the size of the checkpoint size in Tracer
    '''
    self.G.tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)
    
    self.ckpt_iter = 0
    self.sample_iter = 0
    shape = (self.G.tracer.ckpt, )
    if self._shape is not None:
        shape += self._shape
    self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.set_value_shape">
    <p>def <span class="ident">set_value_shape</span>(</p><p>self, shape)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the shape</p>
<h2>Parameters</h2>
<p>shape : tuple</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.set_value_shape', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.set_value_shape" class="source">
    <pre><code>def set_value_shape(self, shape):
    '''Set the shape
    
    Parameters
    ----------
    shape : tuple
    '''
    if not istuple(shape):
        raise TypeError('`shape` ({}) must be a tuple'.format(type(shape)))
    self._shape = shape
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.set_values_from_array">
    <p>def <span class="ident">set_values_from_array</span>(</p><p>self, values, use_indicators=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the values from an array of the same order as the clusters.</p>
<h2>Paramters</h2>
<p>values : array_like
    An array of the values
    Must be the same length as the number of clusters is <code>use_indicators</code> 
    is False. If <code>use_indicators</code> is True, then the length must correspond
    to how many positive indicators there are.
use_indicators : bool
    If True, the values  only correspond to positive interactions. Else
    the values correspond to every cluster</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.set_values_from_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.set_values_from_array" class="source">
    <pre><code>def set_values_from_array(self, values, use_indicators=True):
    '''Sets the values from an array of the same order as the clusters.
    Paramters
    ---------
    values : array_like
        An array of the values
        Must be the same length as the number of clusters is `use_indicators` 
        is False. If `use_indicators` is True, then the length must correspond
        to how many positive indicators there are.
    use_indicators : bool
        If True, the values  only correspond to positive interactions. Else
        the values correspond to every cluster
    '''
    if not util.isarray(values):
        raise ValueError('`values` ({}) must be an array'.format(type(values)))
    if not util.isbool(use_indicators):
        raise TypeError('`use_indicators` ({}) must be a bool'.format(
            type(use_indicators)))
    if not use_indicators:
        # Checking is done within this function
        self.magnitude.set_values_from_array(values)
    else:
        if len(values) != self.indicator.num_on_clusters():
            raise ValueError('The length of the array ({}) does not correspond' \
                ' to how many on indicators there are ({})'.format(
                    len(values), self.indicator.num_on_clusters()))
        i = 0
        for cid in self.clustering.order:
            if self.indicator.value[cid]:
                self.magnitude.value[cid] = values[i]
                i += 1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.timetuple">
    <p>def <span class="ident">timetuple</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the time tuple of the start and end</p>
<h2>Paramters</h2>
<p>None</p>
<h2>Returns</h2>
<p>2-tuple
    (start,end) as floats</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.timetuple', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.timetuple" class="source">
    <pre><code>def timetuple(self):
    '''Returns the time tuple of the start and end
    Paramters
    ---------
    None
    Returns
    -------
    2-tuple
        (start,end) as floats
    '''
    return (self.start, self.end)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.T" class="name">var <span class="ident">T</span></p>
            

            
  
    <div class="desc"><p>Transpose</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.clustering" class="name">var <span class="ident">clustering</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.degree" class="name">var <span class="ident">degree</span></p>
            

            
  
    <div class="desc"><p>Get the degree of the node</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.indicator" class="name">var <span class="ident">indicator</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.initialization_value" class="name">var <span class="ident">initialization_value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.magnitude" class="name">var <span class="ident">magnitude</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.metropolis" class="name">var <span class="ident">metropolis</span></p>
            

            
  
    <div class="desc"><p>Get the metropolis object</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbation.probability" class="name">var <span class="ident">probability</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbation.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbation.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbation.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.contrib.ClusterPerturbationIndicator" class="name">class <span class="ident">ClusterPerturbationIndicator</span></p>
      
  
    <div class="desc"><p>Extends the <code>pylab.cluster.ClusterValue</code> object so that it works for being a 
cluster perturbation indicator</p>
<p>Implements the <code>clusters_changed</code> function required by a ClusterProperty
and provides a direct pointer to the probability object</p>
<h2>Parameters</h2>
<p>probability : pl.variables.Variable
    This is the variable object that holds the probability for a positive indicator
kwargs : dict
    These are additional arguments for ClusterValue</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator" class="source">
    <pre><code>class ClusterPerturbationIndicator(ClusterValue):
    '''Extends the `pylab.cluster.ClusterValue` object so that it works for being a 
    cluster perturbation indicator
    
    Implements the `clusters_changed` function required by a ClusterProperty
    and provides a direct pointer to the probability object

    Parameters
    ----------
    probability : pl.variables.Variable
        This is the variable object that holds the probability for a positive indicator
    kwargs : dict
        These are additional arguments for ClusterValue
    '''
    def __init__(self, probability, **kwargs):
        ClusterValue.__init__(self, dtype=bool, **kwargs)
        self.probability = probability

    def reset(self):
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = False

    def clusters_changed(self, cids_added, cids_removed):
        '''Delete old clusters, sample from `probability` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        '''
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = bool(npr.binomial(
                n=1,
                p=self.probability.value))

    def otu_bool_array(self):
        '''Creates a boolean array expanded so that each OTU has the same 
        value that the cluster that contains it has. This is the same as 
        calling CLusterValue.otu_array
        Example
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([True, False, True, False, True])

        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each OTU
        '''
        return ClusterValue.otu_array(self)

    def cluster_bool_array(self):
        '''Creates a boolean array for each OTU in cluster order. This 
        is the same as calling ClusterValue.cluster_array()

        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([True, False])
        
        Returns
        -------
        np.ndarray((n,), dtype=bool)
            A numpy bool array for each cluster
        '''
        return ClusterValue.cluster_array(self)

    def otu_arg_array(self):
        '''Creates an ordered index array of OTUs that are positive.
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([0,2,4])
        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each OTU
        '''
        val = []
        for cluster in self.clustering:
            if self.value[cluster.id]:
                val += list(cluster.members)
        return np.asarray(val, dtype=int)

    def cluster_arg_array(self):
        '''Creates an ordered index array of clusters that are positive.
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> np.ndarray([0])
        Returns
        -------
        np.ndarray((n_c,), dtype=int)
            A numpy index array for each cluster
        '''

        return np.asarray([idx for idx,cid in enumerate(self.clustering.order) \
            if self.value[cid]], dtype=int)

    def num_on_otus(self):
        '''These are the number of on otus for this perturbation
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> 3

        Returns
        -------
        int
            This is the number of postiive OTUs
        '''
        try:
            cumm = 0
            for cluster in self.clustering:
                if self.value[cluster.id]:
                    cumm += cluster.size
            return int(cumm)
        except:
            logging.critical('Inner cluster ids:\n{}'.format(list(self.value.keys())))
            logging.critical('Clustering cluster ids:\n{}'.format(self.clustering.order))
            raise

    def num_on_clusters(self):
        '''These are the number of on clusters for this perturbation
        Example:
            cluster1 = {0,2,4}
            cluster2 = {1,3}
            value[cluster1] = True
            value[cluster2] = False

            >>> 1

        Returns
        -------
        int
            This is the number of postiive clusters
        '''
        cumm = 0
        for cid in self.clustering.order:
            cumm += self.value[cid]
        return cumm

    def get_clusters_on(self):
        '''Return the cluster IDs that have a positive indicator for this
        perturbation.

        Returns
        -------
        list
        '''
        ret = [cid for cid in self.clustering.order if self.value[cid]]
        return ret

    def get_otus_on(self):
        '''Get the OTU indecies that have a positive indicator for this
        perturbation.

        Returns
        -------
        list
        '''
        ret = []
        for cid in self.clustering.order:
            if self.value[cid]:
                ret += list(self.clustering.clusters[cid].members)
        return ret
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.contrib.ClusterPerturbationIndicator">ClusterPerturbationIndicator</a></li>
          <li>pylab.cluster.ClusterValue</li>
          <li>pylab.cluster.ClusterProperty</li>
          <li>pylab.graph.Node</li>
          <li>pylab.graph.BaseNode</li>
          <li>pylab.base.Saveable</li>
          <li>pylab.base.Traceable</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, probability, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.__init__" class="source">
    <pre><code>def __init__(self, probability, **kwargs):
    ClusterValue.__init__(self, dtype=bool, **kwargs)
    self.probability = probability
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.add_child">
    <p>def <span class="ident">add_child</span>(</p><p>self, child)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>child</code> as a child to the node
Also adds self as a parent to <code>child</code></p>
<h2>Parameters</h2>
<p>child : Node
    - node we want to set as a child</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.add_child', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.add_child" class="source">
    <pre><code>def add_child(self, child):
    '''Adds `child` as a child to the node
    Also adds self as a parent to `child`
    Parameters
    ----------
    child : Node
        - node we want to set as a child
    '''
    if not isnode(child):
        raise ValueError('child ({}) must be a (subclass of) Node'.format( 
            type(child)))
    if self.G.id != child.G.id:
        raise GraphIDError('Attempting to add a child `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, child.name))
    self.children[child.id] = child
    child.parents[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.add_init_value">
    <p>def <span class="ident">add_init_value</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the initialization value. This is called by <code>pylab.inference.BaseMCMC.run</code>
when first updating the variable. User should not use this function</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.add_init_value', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.add_init_value" class="source">
    <pre><code>def add_init_value(self):
    '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
    when first updating the variable. User should not use this function
    '''
    self._init_value = self.otu_array()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.add_parent">
    <p>def <span class="ident">add_parent</span>(</p><p>self, parent)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>parent</code> as a parent to the node
Also adds self as a child to <code>parent</code></p>
<h2>Parameters</h2>
<p>parent : Node
    - node we want to set as a parent</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.add_parent', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.add_parent" class="source">
    <pre><code>def add_parent(self, parent):
    '''Adds `parent` as a parent to the node
    Also adds self as a child to `parent`
    Parameters
    ----------
    parent : Node
        - node we want to set as a parent
    '''
    if not isnode(parent):
        raise ValueError('parent ({}) must be a (subclass of) Node'.format( 
            type(parent)))
    if self.G.id != parent.G.id:
        raise GraphIDError('Attempting to add a parent `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, parent.name))
    self.parents[parent.id] = parent
    parent.children[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.add_prior">
    <p>def <span class="ident">add_prior</span>(</p><p>self, prior)</p>
    </div>
    

    
  
    <div class="desc"><p>Override the name of the passed in distribution <code>prior</code>.</p>
<h2>Parameters</h2>
<p>prior : Node
    - node we want to set as a prior</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.add_prior', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.add_prior" class="source">
    <pre><code>def add_prior(self, prior):
    '''Override the name of the passed in distribution `prior`.
    Parameters
    ----------
    prior : Node
        - node we want to set as a prior
    '''
    if not isnode(prior):
        raise ValueError('prior ({}) must be a (subclass of) Node'.format( 
            type(prior)))
    self.add_parent(prior)
    self.prior = prior
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.add_trace">
    <p>def <span class="ident">add_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds the current value to the trace on an otu-basis. Writes to disk if
local buffer is full</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.add_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.add_trace" class="source">
    <pre><code>def add_trace(self):
    '''Adds the current value to the trace on an otu-basis. Writes to disk if
    local buffer is full
    '''
    value = self.otu_array()
    self.trace[self.ckpt_iter] = value
    self.ckpt_iter += 1
    self.sample_iter += 1
    if self.ckpt_iter == len(self.trace):
        # We have gotten the largest we can in the local buffer, write to disk
        self.G.tracer.write_to_disk(name=self.name)
        self.trace = np.full(shape=(self.G.tracer.ckpt, len(self.clustering.otus)),
            dtype=self.dtype, fill_value=np.nan)
        self.ckpt_iter = 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.add_undirected">
    <p>def <span class="ident">add_undirected</span>(</p><p>self, node)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>node</code> as an undirected neighbor to the node
Does the same for <code>node</code></p>
<h2>Parameters</h2>
<p>node : Node
    - node we want to set as an undirected node</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.add_undirected', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.add_undirected" class="source">
    <pre><code>def add_undirected(self, node):
    '''Adds `node` as an undirected neighbor to the node
    Does the same for `node`
    Parameters
    ----------
    node : Node
        - node we want to set as an undirected node
    '''
    if not isnode(node):
        raise ValueError('node ({}) must be a (subclass of) Node'.format( 
            type(node)))
    if self.G.id != node.G.id:
        raise GraphIDError('Attempting to add a node `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, node.name))
    self.undirected[node.id] = node
    node.undirected[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.assignments_changed">
    <p>def <span class="ident">assignments_changed</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.assignments_changed', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.assignments_changed" class="source">
    <pre><code>def assignments_changed(self):
    raise NeedToImplementError('User needs to implement this function')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.cluster_arg_array">
    <p>def <span class="ident">cluster_arg_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates an ordered index array of clusters that are positive.
Example:
    cluster1 = {0,2,4}
    cluster2 = {1,3}
    value[cluster1] = True
    value[cluster2] = False</p>
<pre><code>&gt;&gt;&gt; np.ndarray([0])
</code></pre>
<h2>Returns</h2>
<p>np.ndarray((n_c,), dtype=int)
    A numpy index array for each cluster</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.cluster_arg_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.cluster_arg_array" class="source">
    <pre><code>def cluster_arg_array(self):
    '''Creates an ordered index array of clusters that are positive.
    Example:
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        >>> np.ndarray([0])
    Returns
    -------
    np.ndarray((n_c,), dtype=int)
        A numpy index array for each cluster
    '''
    return np.asarray([idx for idx,cid in enumerate(self.clustering.order) \
        if self.value[cid]], dtype=int)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.cluster_array">
    <p>def <span class="ident">cluster_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Converts the dictionary into a cluster array in the order of the clusters</p>
<h2>Returns</h2>
<p>np.ndarray((n,), dtype=self.dtype)
    Array of the values expanded for each cluster in the overall cluster order</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.cluster_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.cluster_array" class="source">
    <pre><code>def cluster_array(self):
    '''Converts the dictionary into a cluster array in the order of the clusters
    Returns
    -------
    np.ndarray((n,), dtype=self.dtype)
        Array of the values expanded for each cluster in the overall cluster order
    '''
    return np.asarray([self.value[cid] for cid in self.clustering.order], dtype=self.dtype)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.cluster_bool_array">
    <p>def <span class="ident">cluster_bool_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a boolean array for each OTU in cluster order. This 
is the same as calling ClusterValue.cluster_array()</p>
<p>Example:
    cluster1 = {0,2,4}
    cluster2 = {1,3}
    value[cluster1] = True
    value[cluster2] = False</p>
<pre><code>&gt;&gt;&gt; np.ndarray([True, False])
</code></pre>
<h2>Returns</h2>
<p>np.ndarray((n,), dtype=bool)
    A numpy bool array for each cluster</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.cluster_bool_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.cluster_bool_array" class="source">
    <pre><code>def cluster_bool_array(self):
    '''Creates a boolean array for each OTU in cluster order. This 
    is the same as calling ClusterValue.cluster_array()
    Example:
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        >>> np.ndarray([True, False])
    
    Returns
    -------
    np.ndarray((n,), dtype=bool)
        A numpy bool array for each cluster
    '''
    return ClusterValue.cluster_array(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.clusters_changed">
    <p>def <span class="ident">clusters_changed</span>(</p><p>self, cids_added, cids_removed)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete old clusters, sample from <code>probability</code> for the
new clusters. We do not need to type check because it
is self contained within pylab</p>
<h2>Parameters</h2>
<p>cids_added (list(int))
    - These are a list of cluster ids to add
cids_removed (list(int))
    - These are the cids that were removed</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.clusters_changed', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.clusters_changed" class="source">
    <pre><code>def clusters_changed(self, cids_added, cids_removed):
    '''Delete old clusters, sample from `probability` for the
    new clusters. We do not need to type check because it
    is self contained within pylab
    Parameters
    ----------
    cids_added (list(int))
        - These are a list of cluster ids to add
    cids_removed (list(int))
        - These are the cids that were removed
    '''
    for cid in cids_removed:
        self.value.pop(cid)
    for cid in cids_added:
        self.value[cid] = bool(npr.binomial(
            n=1,
            p=self.probability.value))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.delete">
    <p>def <span class="ident">delete</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete itself from the graph</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.delete', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.delete" class="source">
    <pre><code>def delete(self):
    '''Delete itself from the graph
    '''
    if len(self.parents) > 0:
        for pid in self.parents:
            self.G.nodes[pid].children.pop(self.id, None)
    if len(self.children) > 0:
        for cid in self.children:
            self.G.nodes[cid].parents.pop(self.id, None)
    if len(self.undirected) > 0:
        for uid in self.undirected:
            self.G.nodes[uid].undirected.pop(self.id, None)
    BaseNode.delete(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.get_adjacent_keys">
    <p>def <span class="ident">get_adjacent_keys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the adjacent nodes</p>
<h2>Returns</h2>
<p>list(int)
    A list of all the IDs of the adjacent nodes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.get_adjacent_keys', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.get_adjacent_keys" class="source">
    <pre><code>def get_adjacent_keys(self):
    '''Get the adjacent nodes
    Returns
    -------
    list(int)
        A list of all the IDs of the adjacent nodes
    '''
    return list(self.parents.keys()) + list(self.children.keys())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.get_clusters_on">
    <p>def <span class="ident">get_clusters_on</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the cluster IDs that have a positive indicator for this
perturbation.</p>
<h2>Returns</h2>
<p>list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.get_clusters_on', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.get_clusters_on" class="source">
    <pre><code>def get_clusters_on(self):
    '''Return the cluster IDs that have a positive indicator for this
    perturbation.
    Returns
    -------
    list
    '''
    ret = [cid for cid in self.clustering.order if self.value[cid]]
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.get_iter">
    <p>def <span class="ident">get_iter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the number of iterations saved to the hdf5 file of the variable</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.get_iter', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.get_iter" class="source">
    <pre><code>def get_iter(self):
    '''Get the number of iterations saved to the hdf5 file of the variable
    Returns
    -------
    int
    '''
    return self.G.tracer.get_iter(name=self.name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.get_otus_on">
    <p>def <span class="ident">get_otus_on</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the OTU indecies that have a positive indicator for this
perturbation.</p>
<h2>Returns</h2>
<p>list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.get_otus_on', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.get_otus_on" class="source">
    <pre><code>def get_otus_on(self):
    '''Get the OTU indecies that have a positive indicator for this
    perturbation.
    Returns
    -------
    list
    '''
    ret = []
    for cid in self.clustering.order:
        if self.value[cid]:
            ret += list(self.clustering.clusters[cid].members)
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.get_trace_from_disk">
    <p>def <span class="ident">get_trace_from_disk</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
include the samples in the local buffer trace and could be very large</p>
<h2>Returns</h2>
<p>np.ndarray</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.get_trace_from_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.get_trace_from_disk" class="source">
    <pre><code>def get_trace_from_disk(self, *args, **kwargs):
    '''Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
    include the samples in the local buffer trace and could be very large
    Returns
    -------
    np.ndarray
    '''
    return self.G.tracer.get_trace(name=self.name, *args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.num_on_clusters">
    <p>def <span class="ident">num_on_clusters</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>These are the number of on clusters for this perturbation
Example:
    cluster1 = {0,2,4}
    cluster2 = {1,3}
    value[cluster1] = True
    value[cluster2] = False</p>
<pre><code>&gt;&gt;&gt; 1
</code></pre>
<h2>Returns</h2>
<p>int
    This is the number of postiive clusters</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.num_on_clusters', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.num_on_clusters" class="source">
    <pre><code>def num_on_clusters(self):
    '''These are the number of on clusters for this perturbation
    Example:
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        >>> 1
    Returns
    -------
    int
        This is the number of postiive clusters
    '''
    cumm = 0
    for cid in self.clustering.order:
        cumm += self.value[cid]
    return cumm
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.num_on_otus">
    <p>def <span class="ident">num_on_otus</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>These are the number of on otus for this perturbation
Example:
    cluster1 = {0,2,4}
    cluster2 = {1,3}
    value[cluster1] = True
    value[cluster2] = False</p>
<pre><code>&gt;&gt;&gt; 3
</code></pre>
<h2>Returns</h2>
<p>int
    This is the number of postiive OTUs</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.num_on_otus', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.num_on_otus" class="source">
    <pre><code>def num_on_otus(self):
    '''These are the number of on otus for this perturbation
    Example:
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        >>> 3
    Returns
    -------
    int
        This is the number of postiive OTUs
    '''
    try:
        cumm = 0
        for cluster in self.clustering:
            if self.value[cluster.id]:
                cumm += cluster.size
        return int(cumm)
    except:
        logging.critical('Inner cluster ids:\n{}'.format(list(self.value.keys())))
        logging.critical('Clustering cluster ids:\n{}'.format(self.clustering.order))
        raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.otu_arg_array">
    <p>def <span class="ident">otu_arg_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates an ordered index array of OTUs that are positive.
Example:
    cluster1 = {0,2,4}
    cluster2 = {1,3}
    value[cluster1] = True
    value[cluster2] = False</p>
<pre><code>&gt;&gt;&gt; np.ndarray([0,2,4])
</code></pre>
<h2>Returns</h2>
<p>np.ndarray((n_c,), dtype=int)
    A numpy index array for each OTU</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.otu_arg_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.otu_arg_array" class="source">
    <pre><code>def otu_arg_array(self):
    '''Creates an ordered index array of OTUs that are positive.
    Example:
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        >>> np.ndarray([0,2,4])
    Returns
    -------
    np.ndarray((n_c,), dtype=int)
        A numpy index array for each OTU
    '''
    val = []
    for cluster in self.clustering:
        if self.value[cluster.id]:
            val += list(cluster.members)
    return np.asarray(val, dtype=int)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.otu_array">
    <p>def <span class="ident">otu_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Converts these values per OTU</p>
<h2>Returns</h2>
<p>np.ndarray((n,), dtype=self.dtype)
    Array of the values expanded to the OTUs in the overall OTU order
    specified in OTUSet</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.otu_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.otu_array" class="source">
    <pre><code>def otu_array(self):
    '''Converts these values per OTU
    Returns
    -------
    np.ndarray((n,), dtype=self.dtype)
        Array of the values expanded to the OTUs in the overall OTU order
        specified in OTUSet
    '''
    ret = np.zeros(len(self.clustering.otus), dtype=self.dtype)
    for cluster in self.clustering:
        oidxs = list(cluster.members)
        ret[oidxs] = self.value[cluster.id]
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.otu_bool_array">
    <p>def <span class="ident">otu_bool_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a boolean array expanded so that each OTU has the same 
value that the cluster that contains it has. This is the same as 
calling CLusterValue.otu_array
Example
    cluster1 = {0,2,4}
    cluster2 = {1,3}
    value[cluster1] = True
    value[cluster2] = False</p>
<pre><code>&gt;&gt;&gt; np.ndarray([True, False, True, False, True])
</code></pre>
<h2>Returns</h2>
<p>np.ndarray((n,), dtype=bool)
    A numpy bool array for each OTU</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.otu_bool_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.otu_bool_array" class="source">
    <pre><code>def otu_bool_array(self):
    '''Creates a boolean array expanded so that each OTU has the same 
    value that the cluster that contains it has. This is the same as 
    calling CLusterValue.otu_array
    Example
        cluster1 = {0,2,4}
        cluster2 = {1,3}
        value[cluster1] = True
        value[cluster2] = False
        >>> np.ndarray([True, False, True, False, True])
    Returns
    -------
    np.ndarray((n,), dtype=bool)
        A numpy bool array for each OTU
    '''
    return ClusterValue.otu_array(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.overwrite_entire_trace_on_disk">
    <p>def <span class="ident">overwrite_entire_trace_on_disk</span>(</p><p>self, data, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrites the entire trace of the variable with the given data.</p>
<h2>Parameters</h2>
<p>data : np.ndarray
    Data you are overwriting the trace with.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.overwrite_entire_trace_on_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.overwrite_entire_trace_on_disk" class="source">
    <pre><code>def overwrite_entire_trace_on_disk(self, data, **kwargs):
    '''Overwrites the entire trace of the variable with the given data.
    Parameters
    ----------
    data : np.ndarray
        Data you are overwriting the trace with.
    '''
    self.G.tracer.overwrite_entire_trace_on_disk(
        name=self.name, data=data, dtype=self.dtype, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.reset">
    <p>def <span class="ident">reset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Call this function after you set the <code>signal_when_otu_assignment_changes</code> or
<code>signal_when_clusters_change</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.reset', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.reset" class="source">
    <pre><code>def reset(self):
    self.value = {}
    for cid in self.clustering.order:
        self.value[cid] = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <code>pylab.base.Saveable.set_save_location</code>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.set_signal_when_clusters_change">
    <p>def <span class="ident">set_signal_when_clusters_change</span>(</p><p>self, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Switch the signal <code>signal_when_clusters_change</code> to <code>value</code></p>
<h2>Paramters</h2>
<p>value : bool
    This is what to set the <code>signal_when_clusters_change</code> flag to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.set_signal_when_clusters_change', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.set_signal_when_clusters_change" class="source">
    <pre><code>def set_signal_when_clusters_change(self, value):
    '''Switch the signal `signal_when_clusters_change` to `value`
    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_clusters_change` flag to
    '''
    if not util.isbool(value):
        raise ValueError('`value` ({}) must be a bool'.format(
            type(value)))
    # Only need to change if they are different
    if self.signal_when_clusters_change != value:
        if self.signal_when_clusters_change:
            # We need to take it out
            self.clustering.properties.signal_when_clusters_change.remove(self)
        else:
            self.clustering.properties.signal_when_clusters_change.append(self)
    self.signal_when_clusters_change = value
    self.reset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.set_signal_when_otu_assignment_changes">
    <p>def <span class="ident">set_signal_when_otu_assignment_changes</span>(</p><p>self, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Switch the signal <code>signal_when_otu_assignment_changes</code> to <code>value</code></p>
<h2>Paramters</h2>
<p>value : bool
    This is what to set the <code>signal_when_otu_assignment_changes</code> flag to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.set_signal_when_otu_assignment_changes', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.set_signal_when_otu_assignment_changes" class="source">
    <pre><code>def set_signal_when_otu_assignment_changes(self, value):
    '''Switch the signal `signal_when_otu_assignment_changes` to `value`
    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_otu_assignment_changes` flag to
    '''
    if not util.isbool(value):
        raise ValueError('`value` ({}) must be a bool'.format(
            type(value)))
    # Only need to chagne if they are different
    if self.signal_when_otu_assignment_changes != value:
        if self.signal_when_otu_assignment_changes:
            # We need to take it out
            self.clustering.properties.signal_when_otu_assignment_changes.remove(self)
        else:
            self.clustering.properties.signal_when_otu_assignment_changes.append(self)
    self.signal_when_otu_assignment_changes = value
    self.reset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.set_trace">
    <p>def <span class="ident">set_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the trace arrays for the variable in the Tracer object. </p>
<p>It will initialize a buffer the size of the checkpoint size in Tracer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.set_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.set_trace" class="source">
    <pre><code>def set_trace(self):
    tracer = self.G.tracer
    tracer.set_trace(
        self.name, 
        shape=(len(self.clustering.otus), ), 
        dtype=self.dtype)
    self.ckpt_iter = 0
    self.sample_iter = 0
    self.trace = np.full(shape=(tracer.ckpt, len(self.clustering.otus)),
        dtype=self.dtype, fill_value=np.nan)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.set_values_from_array">
    <p>def <span class="ident">set_values_from_array</span>(</p><p>self, values)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the values from an array of the same order as the clusters</p>
<h2>Paramters</h2>
<p>values : array_like
    An array of the values
    Must be the same length as the number of clusters</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.set_values_from_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.set_values_from_array" class="source">
    <pre><code>def set_values_from_array(self, values):
    '''Set the values from an array of the same order as the clusters
    Paramters
    ---------
    values : array_like
        An array of the values
        Must be the same length as the number of clusters
    '''
    if not util.isarray(values):
        raise ValueError('`values` ({}) must be an array'.format(type(values)))
    if len(values) != len(self.clustering):
        raise ValueError('`values` ({}) must be the same length as the number ' \
            'of clusters ({})'.format(len(values), len(self.clustering)))
    self.value = {}
    for cidx, cid in enumerate(self.clustering.order):
        self.value[cid] = values[cidx]
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbationIndicator.degree" class="name">var <span class="ident">degree</span></p>
            

            
  
    <div class="desc"><p>Get the degree of the node</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbationIndicator.initialization_value" class="name">var <span class="ident">initialization_value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbationIndicator.metropolis" class="name">var <span class="ident">metropolis</span></p>
            

            
  
    <div class="desc"><p>Get the metropolis object</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbationIndicator.probability" class="name">var <span class="ident">probability</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationIndicator.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationIndicator.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationIndicator.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.contrib.ClusterPerturbationValue" class="name">class <span class="ident">ClusterPerturbationValue</span></p>
      
  
    <div class="desc"><p>Extends <code>pylab.cluster.ClusterValue</code> object so it works for reset and cluster
changed</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue" class="source">
    <pre><code>class ClusterPerturbationValue(ClusterValue):
    '''Extends `pylab.cluster.ClusterValue` object so it works for reset and cluster
    changed
    '''
    def reset(self):
        self.value = {}
        for cid in self.clustering.order:
            self.value[cid] = False

    def clusters_changed(self, cids_added, cids_removed):
        '''Delete old clusters, sample from `prior` for the
        new clusters. We do not need to type check because it
        is self contained within pylab

        Parameters
        ----------
        cids_added (list(int))
            - These are a list of cluster ids to add
        cids_removed (list(int))
            - These are the cids that were removed
        '''
        for cid in cids_removed:
            self.value.pop(cid)
        for cid in cids_added:
            self.value[cid] = self.prior.sample()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.contrib.ClusterPerturbationValue">ClusterPerturbationValue</a></li>
          <li>pylab.cluster.ClusterValue</li>
          <li>pylab.cluster.ClusterProperty</li>
          <li>pylab.graph.Node</li>
          <li>pylab.graph.BaseNode</li>
          <li>pylab.base.Saveable</li>
          <li>pylab.base.Traceable</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, clustering, signal_when_clusters_change, signal_when_otu_assignment_changes, dtype=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.__init__" class="source">
    <pre><code>def __init__(self, clustering, signal_when_clusters_change,
    signal_when_otu_assignment_changes, dtype=None, **kwargs):
    if dtype is None:
        dtype = DEFAULT_CLUSTERVALUE_DTYPE
    Node.__init__(self, **kwargs)
    self.value = {}
    self.dtype = dtype
    ClusterProperty.__init__(self, clustering=clustering,
        signal_when_clusters_change=signal_when_clusters_change,
        signal_when_otu_assignment_changes=signal_when_otu_assignment_changes)
    for cid in self.clustering.order:
        self.value[cid] = np.nan
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.add_child">
    <p>def <span class="ident">add_child</span>(</p><p>self, child)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>child</code> as a child to the node
Also adds self as a parent to <code>child</code></p>
<h2>Parameters</h2>
<p>child : Node
    - node we want to set as a child</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.add_child', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.add_child" class="source">
    <pre><code>def add_child(self, child):
    '''Adds `child` as a child to the node
    Also adds self as a parent to `child`
    Parameters
    ----------
    child : Node
        - node we want to set as a child
    '''
    if not isnode(child):
        raise ValueError('child ({}) must be a (subclass of) Node'.format( 
            type(child)))
    if self.G.id != child.G.id:
        raise GraphIDError('Attempting to add a child `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, child.name))
    self.children[child.id] = child
    child.parents[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.add_init_value">
    <p>def <span class="ident">add_init_value</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the initialization value. This is called by <code>pylab.inference.BaseMCMC.run</code>
when first updating the variable. User should not use this function</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.add_init_value', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.add_init_value" class="source">
    <pre><code>def add_init_value(self):
    '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
    when first updating the variable. User should not use this function
    '''
    self._init_value = self.otu_array()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.add_parent">
    <p>def <span class="ident">add_parent</span>(</p><p>self, parent)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>parent</code> as a parent to the node
Also adds self as a child to <code>parent</code></p>
<h2>Parameters</h2>
<p>parent : Node
    - node we want to set as a parent</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.add_parent', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.add_parent" class="source">
    <pre><code>def add_parent(self, parent):
    '''Adds `parent` as a parent to the node
    Also adds self as a child to `parent`
    Parameters
    ----------
    parent : Node
        - node we want to set as a parent
    '''
    if not isnode(parent):
        raise ValueError('parent ({}) must be a (subclass of) Node'.format( 
            type(parent)))
    if self.G.id != parent.G.id:
        raise GraphIDError('Attempting to add a parent `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, parent.name))
    self.parents[parent.id] = parent
    parent.children[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.add_prior">
    <p>def <span class="ident">add_prior</span>(</p><p>self, prior)</p>
    </div>
    

    
  
    <div class="desc"><p>Override the name of the passed in distribution <code>prior</code>.</p>
<h2>Parameters</h2>
<p>prior : Node
    - node we want to set as a prior</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.add_prior', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.add_prior" class="source">
    <pre><code>def add_prior(self, prior):
    '''Override the name of the passed in distribution `prior`.
    Parameters
    ----------
    prior : Node
        - node we want to set as a prior
    '''
    if not isnode(prior):
        raise ValueError('prior ({}) must be a (subclass of) Node'.format( 
            type(prior)))
    self.add_parent(prior)
    self.prior = prior
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.add_trace">
    <p>def <span class="ident">add_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds the current value to the trace on an otu-basis. Writes to disk if
local buffer is full</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.add_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.add_trace" class="source">
    <pre><code>def add_trace(self):
    '''Adds the current value to the trace on an otu-basis. Writes to disk if
    local buffer is full
    '''
    value = self.otu_array()
    self.trace[self.ckpt_iter] = value
    self.ckpt_iter += 1
    self.sample_iter += 1
    if self.ckpt_iter == len(self.trace):
        # We have gotten the largest we can in the local buffer, write to disk
        self.G.tracer.write_to_disk(name=self.name)
        self.trace = np.full(shape=(self.G.tracer.ckpt, len(self.clustering.otus)),
            dtype=self.dtype, fill_value=np.nan)
        self.ckpt_iter = 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.add_undirected">
    <p>def <span class="ident">add_undirected</span>(</p><p>self, node)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>node</code> as an undirected neighbor to the node
Does the same for <code>node</code></p>
<h2>Parameters</h2>
<p>node : Node
    - node we want to set as an undirected node</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.add_undirected', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.add_undirected" class="source">
    <pre><code>def add_undirected(self, node):
    '''Adds `node` as an undirected neighbor to the node
    Does the same for `node`
    Parameters
    ----------
    node : Node
        - node we want to set as an undirected node
    '''
    if not isnode(node):
        raise ValueError('node ({}) must be a (subclass of) Node'.format( 
            type(node)))
    if self.G.id != node.G.id:
        raise GraphIDError('Attempting to add a node `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, node.name))
    self.undirected[node.id] = node
    node.undirected[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.assignments_changed">
    <p>def <span class="ident">assignments_changed</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.assignments_changed', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.assignments_changed" class="source">
    <pre><code>def assignments_changed(self):
    raise NeedToImplementError('User needs to implement this function')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.cluster_array">
    <p>def <span class="ident">cluster_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Converts the dictionary into a cluster array in the order of the clusters</p>
<h2>Returns</h2>
<p>np.ndarray((n,), dtype=self.dtype)
    Array of the values expanded for each cluster in the overall cluster order</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.cluster_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.cluster_array" class="source">
    <pre><code>def cluster_array(self):
    '''Converts the dictionary into a cluster array in the order of the clusters
    Returns
    -------
    np.ndarray((n,), dtype=self.dtype)
        Array of the values expanded for each cluster in the overall cluster order
    '''
    return np.asarray([self.value[cid] for cid in self.clustering.order], dtype=self.dtype)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.clusters_changed">
    <p>def <span class="ident">clusters_changed</span>(</p><p>self, cids_added, cids_removed)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete old clusters, sample from <code>prior</code> for the
new clusters. We do not need to type check because it
is self contained within pylab</p>
<h2>Parameters</h2>
<p>cids_added (list(int))
    - These are a list of cluster ids to add
cids_removed (list(int))
    - These are the cids that were removed</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.clusters_changed', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.clusters_changed" class="source">
    <pre><code>def clusters_changed(self, cids_added, cids_removed):
    '''Delete old clusters, sample from `prior` for the
    new clusters. We do not need to type check because it
    is self contained within pylab
    Parameters
    ----------
    cids_added (list(int))
        - These are a list of cluster ids to add
    cids_removed (list(int))
        - These are the cids that were removed
    '''
    for cid in cids_removed:
        self.value.pop(cid)
    for cid in cids_added:
        self.value[cid] = self.prior.sample()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.delete">
    <p>def <span class="ident">delete</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete itself from the graph</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.delete', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.delete" class="source">
    <pre><code>def delete(self):
    '''Delete itself from the graph
    '''
    if len(self.parents) > 0:
        for pid in self.parents:
            self.G.nodes[pid].children.pop(self.id, None)
    if len(self.children) > 0:
        for cid in self.children:
            self.G.nodes[cid].parents.pop(self.id, None)
    if len(self.undirected) > 0:
        for uid in self.undirected:
            self.G.nodes[uid].undirected.pop(self.id, None)
    BaseNode.delete(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.get_adjacent_keys">
    <p>def <span class="ident">get_adjacent_keys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the adjacent nodes</p>
<h2>Returns</h2>
<p>list(int)
    A list of all the IDs of the adjacent nodes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.get_adjacent_keys', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.get_adjacent_keys" class="source">
    <pre><code>def get_adjacent_keys(self):
    '''Get the adjacent nodes
    Returns
    -------
    list(int)
        A list of all the IDs of the adjacent nodes
    '''
    return list(self.parents.keys()) + list(self.children.keys())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.get_iter">
    <p>def <span class="ident">get_iter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the number of iterations saved to the hdf5 file of the variable</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.get_iter', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.get_iter" class="source">
    <pre><code>def get_iter(self):
    '''Get the number of iterations saved to the hdf5 file of the variable
    Returns
    -------
    int
    '''
    return self.G.tracer.get_iter(name=self.name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.get_trace_from_disk">
    <p>def <span class="ident">get_trace_from_disk</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
include the samples in the local buffer trace and could be very large</p>
<h2>Returns</h2>
<p>np.ndarray</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.get_trace_from_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.get_trace_from_disk" class="source">
    <pre><code>def get_trace_from_disk(self, *args, **kwargs):
    '''Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
    include the samples in the local buffer trace and could be very large
    Returns
    -------
    np.ndarray
    '''
    return self.G.tracer.get_trace(name=self.name, *args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.otu_array">
    <p>def <span class="ident">otu_array</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Converts these values per OTU</p>
<h2>Returns</h2>
<p>np.ndarray((n,), dtype=self.dtype)
    Array of the values expanded to the OTUs in the overall OTU order
    specified in OTUSet</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.otu_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.otu_array" class="source">
    <pre><code>def otu_array(self):
    '''Converts these values per OTU
    Returns
    -------
    np.ndarray((n,), dtype=self.dtype)
        Array of the values expanded to the OTUs in the overall OTU order
        specified in OTUSet
    '''
    ret = np.zeros(len(self.clustering.otus), dtype=self.dtype)
    for cluster in self.clustering:
        oidxs = list(cluster.members)
        ret[oidxs] = self.value[cluster.id]
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.overwrite_entire_trace_on_disk">
    <p>def <span class="ident">overwrite_entire_trace_on_disk</span>(</p><p>self, data, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrites the entire trace of the variable with the given data.</p>
<h2>Parameters</h2>
<p>data : np.ndarray
    Data you are overwriting the trace with.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.overwrite_entire_trace_on_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.overwrite_entire_trace_on_disk" class="source">
    <pre><code>def overwrite_entire_trace_on_disk(self, data, **kwargs):
    '''Overwrites the entire trace of the variable with the given data.
    Parameters
    ----------
    data : np.ndarray
        Data you are overwriting the trace with.
    '''
    self.G.tracer.overwrite_entire_trace_on_disk(
        name=self.name, data=data, dtype=self.dtype, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.reset">
    <p>def <span class="ident">reset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Call this function after you set the <code>signal_when_otu_assignment_changes</code> or
<code>signal_when_clusters_change</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.reset', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.reset" class="source">
    <pre><code>def reset(self):
    self.value = {}
    for cid in self.clustering.order:
        self.value[cid] = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <code>pylab.base.Saveable.set_save_location</code>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.set_signal_when_clusters_change">
    <p>def <span class="ident">set_signal_when_clusters_change</span>(</p><p>self, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Switch the signal <code>signal_when_clusters_change</code> to <code>value</code></p>
<h2>Paramters</h2>
<p>value : bool
    This is what to set the <code>signal_when_clusters_change</code> flag to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.set_signal_when_clusters_change', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.set_signal_when_clusters_change" class="source">
    <pre><code>def set_signal_when_clusters_change(self, value):
    '''Switch the signal `signal_when_clusters_change` to `value`
    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_clusters_change` flag to
    '''
    if not util.isbool(value):
        raise ValueError('`value` ({}) must be a bool'.format(
            type(value)))
    # Only need to change if they are different
    if self.signal_when_clusters_change != value:
        if self.signal_when_clusters_change:
            # We need to take it out
            self.clustering.properties.signal_when_clusters_change.remove(self)
        else:
            self.clustering.properties.signal_when_clusters_change.append(self)
    self.signal_when_clusters_change = value
    self.reset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.set_signal_when_otu_assignment_changes">
    <p>def <span class="ident">set_signal_when_otu_assignment_changes</span>(</p><p>self, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Switch the signal <code>signal_when_otu_assignment_changes</code> to <code>value</code></p>
<h2>Paramters</h2>
<p>value : bool
    This is what to set the <code>signal_when_otu_assignment_changes</code> flag to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.set_signal_when_otu_assignment_changes', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.set_signal_when_otu_assignment_changes" class="source">
    <pre><code>def set_signal_when_otu_assignment_changes(self, value):
    '''Switch the signal `signal_when_otu_assignment_changes` to `value`
    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_otu_assignment_changes` flag to
    '''
    if not util.isbool(value):
        raise ValueError('`value` ({}) must be a bool'.format(
            type(value)))
    # Only need to chagne if they are different
    if self.signal_when_otu_assignment_changes != value:
        if self.signal_when_otu_assignment_changes:
            # We need to take it out
            self.clustering.properties.signal_when_otu_assignment_changes.remove(self)
        else:
            self.clustering.properties.signal_when_otu_assignment_changes.append(self)
    self.signal_when_otu_assignment_changes = value
    self.reset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.set_trace">
    <p>def <span class="ident">set_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the trace arrays for the variable in the Tracer object. </p>
<p>It will initialize a buffer the size of the checkpoint size in Tracer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.set_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.set_trace" class="source">
    <pre><code>def set_trace(self):
    tracer = self.G.tracer
    tracer.set_trace(
        self.name, 
        shape=(len(self.clustering.otus), ), 
        dtype=self.dtype)
    self.ckpt_iter = 0
    self.sample_iter = 0
    self.trace = np.full(shape=(tracer.ckpt, len(self.clustering.otus)),
        dtype=self.dtype, fill_value=np.nan)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.set_values_from_array">
    <p>def <span class="ident">set_values_from_array</span>(</p><p>self, values)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the values from an array of the same order as the clusters</p>
<h2>Paramters</h2>
<p>values : array_like
    An array of the values
    Must be the same length as the number of clusters</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.set_values_from_array', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.set_values_from_array" class="source">
    <pre><code>def set_values_from_array(self, values):
    '''Set the values from an array of the same order as the clusters
    Paramters
    ---------
    values : array_like
        An array of the values
        Must be the same length as the number of clusters
    '''
    if not util.isarray(values):
        raise ValueError('`values` ({}) must be an array'.format(type(values)))
    if len(values) != len(self.clustering):
        raise ValueError('`values` ({}) must be the same length as the number ' \
            'of clusters ({})'.format(len(values), len(self.clustering)))
    self.value = {}
    for cidx, cid in enumerate(self.clustering.order):
        self.value[cid] = values[cidx]
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbationValue.degree" class="name">var <span class="ident">degree</span></p>
            

            
  
    <div class="desc"><p>Get the degree of the node</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbationValue.initialization_value" class="name">var <span class="ident">initialization_value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.ClusterPerturbationValue.metropolis" class="name">var <span class="ident">metropolis</span></p>
            

            
  
    <div class="desc"><p>Get the metropolis object</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.ClusterPerturbationValue.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.ClusterPerturbationValue.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.ClusterPerturbationValue.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.contrib.Interactions" class="name">class <span class="ident">Interactions</span></p>
      
  
    <div class="desc"><p>This is a basic class for interactions between clusters.</p>
<p>This is a 2D dictionary. The first level of the dictionary indexes the target 
cluster and the second level indexes the source cluster. You can make this 2 
layer dictionary into a matrix or a vector with functions defined in this class. 
The reason why the data is stored in a 2D dictionary is because the number of 
clusters changes constantly, so inserting and deleting values in a dictionary is more
efficient than using a matrix/pandas.DataFrame. Additionally, the order of the clusters
are changing constantly. Having them as a 2D dictionary allows us to reference the 
interactions in the same order as the clusters as they are defined in <code>clusters</code>.</p>
<h2>Tracing</h2>
<p>The interactions get traced on an OTU-OTU bases. In this class we assume there are no
interactions within a cluster. If the indicator is False, we set the trace to np.nan.
To get the indicators call <code>np.nan_to_num</code> on the trace. We do not trace the indicators 
separately, but you can get the trace of the interactions by calling ~np.isnan(self.trace).</p>
<h2>Indicators</h2>
<p>You can choose whether to use or not use indicators for the interactions. If you choose
not to use the indicators, then we assume that every indicator is positive.</p>
<h2>Iterators</h2>
<p>These interactions assume the following order during iterating:
    For target cluster in clusters:
        For source cluster in clusters:
            if they are the same cluster, skip
            else yield value[target][source]
Clusters are ordered in the same way as clustering.</p>
<h2>Value and indicator initialization</h2>
<p>The values and indicators for a new interaction that gets made need to be initialized to 
a value so we use the parameters <code>value_initializer</code> and  <code>inidicator_initializer</code>. If they
are not specified then we return <code>np.nan</code> During initialization of the inference these are 
usually set to the priors of the variables.</p>
<p>The initializer for the indicator is assumed to either return a <code>bool</code> or a float betwen 
[0,1]. It will set it to true if the sampled value is &gt;= 0.5. There is no checking for 
this though.</p>
<h2>Parameters</h2>
<p>clustering : Clustering
    Clustering object
use_indicators : bool
    If True, use indicators. If False do not use indicators (automatically sets all indicators)
    to True
value_initializer : callable, None
    This is the function that initializes the value of the <code>value</code> attribute for an interaction. 
    During MCMC you could set this to the sample method of the prior. 
    Defaults always returning np.nan.
indicator_initializer : callable, None
    This is the function that initializes the value of the <code>value</code> attribute for an interaction. 
    During MCMC you could set this to the sample method of the prior.       <br />
    Defaults to always returning True</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions" class="source">
    <pre><code>class Interactions(ClusterProperty, Node, Traceable):
    '''This is a basic class for interactions between clusters.

    This is a 2D dictionary. The first level of the dictionary indexes the target 
    cluster and the second level indexes the source cluster. You can make this 2 
    layer dictionary into a matrix or a vector with functions defined in this class. 
    The reason why the data is stored in a 2D dictionary is because the number of 
    clusters changes constantly, so inserting and deleting values in a dictionary is more
    efficient than using a matrix/pandas.DataFrame. Additionally, the order of the clusters
    are changing constantly. Having them as a 2D dictionary allows us to reference the 
    interactions in the same order as the clusters as they are defined in `clusters`.

    Tracing
    -------
    The interactions get traced on an OTU-OTU bases. In this class we assume there are no
    interactions within a cluster. If the indicator is False, we set the trace to np.nan.
    To get the indicators call `np.nan_to_num` on the trace. We do not trace the indicators 
    separately, but you can get the trace of the interactions by calling ~np.isnan(self.trace).

    Indicators
    ----------
    You can choose whether to use or not use indicators for the interactions. If you choose
    not to use the indicators, then we assume that every indicator is positive.

    Iterators
    ---------
    These interactions assume the following order during iterating:
        For target cluster in clusters:
            For source cluster in clusters:
                if they are the same cluster, skip
                else yield value[target][source]
    Clusters are ordered in the same way as clustering.

    Value and indicator initialization
    ----------------------------------
    The values and indicators for a new interaction that gets made need to be initialized to 
    a value so we use the parameters `value_initializer` and  `inidicator_initializer`. If they
    are not specified then we return `np.nan` During initialization of the inference these are 
    usually set to the priors of the variables.

    The initializer for the indicator is assumed to either return a `bool` or a float betwen 
    [0,1]. It will set it to true if the sampled value is >= 0.5. There is no checking for 
    this though.

    Parameters
    ----------
    clustering : Clustering
        Clustering object
    use_indicators : bool
        If True, use indicators. If False do not use indicators (automatically sets all indicators)
        to True
    value_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior. 
        Defaults always returning np.nan.
    indicator_initializer : callable, None
        This is the function that initializes the value of the `value` attribute for an interaction. 
        During MCMC you could set this to the sample method of the prior.         
        Defaults to always returning True
    '''
    def __init__(self, clustering, use_indicators, 
        value_initializer=None, indicator_initializer=None, 
        signal_when_clusters_change=True, **kwargs):

        Node.__init__(self, **kwargs)
        ClusterProperty.__init__(self, clustering=clustering, 
            signal_when_clusters_change=signal_when_clusters_change, 
            signal_when_otu_assignment_changes=False)

        if value_initializer is None:
            value_initializer = _always_return_nan
        if indicator_initializer is None:
            indicator_initializer = _always_return_nan
        if not np.all(util.itercheck([value_initializer, indicator_initializer], callable)):
            raise TypeError('`value_initializer` ({}) and `indicator_initializer` ({}) ' \
                'must be callable'.format(type(value_initializer), 
                type(indicator_initializer)))
        self.value_initializer = value_initializer
        self.indicator_initializer = indicator_initializer
        
        if not util.isbool(use_indicators):
            raise TypeError('`use_indicators` ({}) must be a bool'.format(type(use_indicators)))
        self.use_indicators = use_indicators
        if not self.use_indicators:
            self.indicator_initializer = _always_return_true

        order = self.clustering.order
        self.value = {}
        for tcid in order:
            self.value[tcid] = {}
            for scid in order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction( 
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer())

        self._shape = (len(self.clustering.otus), len(self.clustering.otus))
        self.dtype = float

    def __getitem__(self, key):
        return self.value[key]

    def __setitem__(self, key, val):
        self.value[key] = val

    def __iter__(self):
        '''Iterates over the interactions in order
        '''
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    yield temp[scid]

    def __str__(self):
        s=''
        for interaction in self:
            s += str(interaction) + '\n'
        return s
    
    @property
    def size(self):
        '''Return how many interactions there are possible according to the number of clusters.
        THIS IS NOT HOW MANY POSITIVE INTERACTIONS THERE ARE - USE `num_pos_interactions`

        Returns
        -------
        int
        '''
        n_clusters = len(self.clustering)
        return n_clusters * (n_clusters - 1)

    def iter_valid(self):
        '''Iterate only over the positive indicators
        '''
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield temp[scid]

    def iter_valid_pairs(self):
        '''Iterate only over the positive indicators
        '''
        order = self.clustering.order
        for tcid in order:
            temp = self.value[tcid] # Faster pointer
            for scid in order:
                if tcid != scid:
                    if temp[scid].indicator:
                        yield tcid, scid

    def iter_to_target(self, cid, only_valid=False):
        '''Iterates over interactions to the target cluster from all
        source clusters in the order specified by clusters

        Paramters
        ---------
        cid : int
            This is the target cluster id we are iterating from
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        '''
        order = self.clustering.order
        temp = self.value[cid] # For quicker pointer
        if only_valid:
            for scid in order:
                if scid != cid:
                    if temp[scid].indicator:
                        yield temp[scid]
        else:
            for scid in order:
                if scid != cid:
                    yield temp[scid]

    def iter_from_source(self, cid, only_valid=False):
        '''Iterates over interactions from the source cluster to all
        target clusters in the order specified by clusters

        Paramters
        ---------
        cid (int)
            This is the source cluster id
        only_valid : bool
            If True, only returns the interactions with a positive indicator
        '''
        order = self.clustering.order
        if only_valid:
            for tcid in order:
                if tcid != cid:
                    if self.value[tcid][cid].indicator:
                        yield self.value[tcid][cid]
        else:
            for tcid in order:
                if tcid != cid:
                    yield self.value[tcid][cid]

    def reset(self):
        self.value = {}
        for tcid in self.clustering.order:
            self.value[tcid] = {}
            for scid in self.clustering.order:
                if tcid == scid:
                    continue
                self.value[tcid][scid] = _Interaction(
                    source_cid=scid, target_cid=tcid,
                    value=self.value_initializer(),
                    indicator=self.indicator_initializer()>=.5)

    def iloc(self, idx):
        '''Get the interaction as a function of the index that it occurs at.
        Reverse indexing is allowed.

        Parameters
        ----------
        idx : int
            This is the index that the interaction occurs at

        Returns
        -------
        pylab.contrib._Interaction
        '''
        if not util.isint(idx):
            raise TypeError('`idx` ({}) must be an int'.format(idx))
        if idx >= self.size:
            raise ValueError('`idx` ({}) cannot be >= the number of interactions ({})'.format(
                idx, self.size))
        if idx < 0:
            idx = self.size - idx
        tcidx = idx // (len(self.clustering) - 1)
        scidx = idx - tcidx * (len(self.clustering) - 1)
        if scidx >= tcidx:
            scidx += 1
        return self.value[
            self.clustering.order[tcidx]][
            self.clustering.order[scidx]]

    def clusters_changed(self, cids_added, cids_removed):
        '''Remove all of the interactions to and from the clusters
        in `cids_removed` and make interactions for the `cid_added`
        '''
        # Remove interactions from clusters deleted
        if len(cids_removed) > 0:
            for cid in cids_removed:
                self.value.pop(cid, None)
            for cid in self.value.keys():
                for cid_del in cids_removed:
                    self.value[cid].pop(cid_del, None)
        if len(cids_added) > 0:
            for cid in cids_added:
                self._add_single_cluster(cid)
        
    def _add_single_cluster(self, cid):
        other_cids = self.value.keys()
        # Add the interaction from clusters already there and 
        # the new cluster
        for ocid in other_cids:
            self.value[ocid][cid] = _Interaction(
                source_cid=cid, target_cid=ocid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() >= 0.5)
        self.value[cid] = {}
        for ocid in other_cids:
            self.value[cid][ocid] = _Interaction(
                source_cid=ocid, target_cid=cid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer() >= 0.5)
    
    def key_pairs(self, only_valid=False):
        '''Returns (target,source) cluster ids in order

        Parameters
        ----------
        only_valid : bool
            If True, it will only return the key pairs that have a positive indicator.
            Else it will return all of the interactions regardless of the indicator.

        Returns 
        -------
        list((int,int))
            Return a list of the (target, source) cluster IDs for each interaciton
            in order.
        '''
        order = self.clustering.order
        l = []
        for tcid in order:
            for scid in order:
                if tcid != scid:
                    if only_valid:
                        if self.value[tcid][scid].indicator:
                            l.append((tcid, scid))
                    else:
                        l.append((tcid,scid))
        return l

    def num_neg_indicators(self, target_cid=None):
        '''Return the number of indicator variables that are 0

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the negative indicators going into the cluster 
            `target_cid`
        '''
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += not interaction.indicator
        else:
            for interaction in self:
                cumm += not interaction.indicator
        return cumm

    def num_pos_indicators(self, target_cid=None):
        '''Return the number of indicator variables that are 1

        If target_cid is not None, calculate them for only the interactions going into
        that cluster

        Paramters
        ---------
        target_cid : int, Optional
            If this is specified, get only the positive indicators going into the cluster 
            `target_cid`
        '''
        cumm = 0
        if target_cid is not None:
            for interaction in self.iter_to_target(target_cid):
                cumm += interaction.indicator
        else:
            for interaction in self:
                cumm += interaction.indicator
        return cumm

    def get_arg_indicators(self, target_cid=None, source_cid=None):
        '''Get the positive indicators as indices, in order -> same convention
        as `get_indicators`.

        If `target_cid` is specfied, it will get all of the positive indicator indicies 
        going to the target cluster `target_cid` in order. If `source_cid` is specified,
        then it will get all of the positive indicator indices going to the source cluster 
        `source_cid` in order. If both `target_cid` and `source_cid` are specified,
        it will return an empty array if the indicator is False or it will return
        an array of size 1 if the indicator is True.

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.

        Returns
        -------
        list(int)
            Returns a list of the interactions that are positive in order
        '''
        ret = []
        try:
            if target_cid is not None:
                n_clusters = len(self.clustering)
                tcidx = self.clustering.cid2cidx[target_cid]

                if source_cid is not None:
                    if self.value[target_cid][source_cid].indicator:
                        scidx = self.clustering.cid2cidx[source_cid]
                        if tcidx < scidx:
                            scidx -= 1
                        iidx = tcidx * (n_clusters - 1) + scidx
                        ret.append(iidx)
                else:
                    base_idx = tcidx * (n_clusters - 1)
                    for offset, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            ret.append(base_idx + offset)
            
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                scidx = self.clustering.cid2cidx[source_cid]
                for interaction in self.iter_from_source(source_cid):
                    if interaction.indicator:
                        tcidx = self.clustering.cid2cidx[interaction.target_cid]

                        iidx = tcidx * (n_clusters - 1) + scidx
                        if scidx > tcidx:
                            iidx -= 1
                        ret.append(iidx)

            else:
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        ret.append(idx)
            return ret
        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError('`Either `target_cid` ({}) or `source_cid` ({})' \
                        ' must be an int'.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError('`target_cid` ({}) and `source_cid` ({}) cannot' \
                        ' be the same'.format(target_cid, source_cid))
            raise

    def get_indicators(self, target_cid=None, source_cid=None):
        '''Return a the indicator variables as a vector in the order specified
        by the clusters.

        if `target_cid` is specified then it will return all indicators going
        to that cluster. If `source_cid` is specified then it will return all
        indicators going from that cluster. If both are specifeid then it
        will return an array of size 1 of a bool

        Parameters
        ----------
        target_cid, source_cid : int, None
            These are the target cluster ID and source cluster ID, respectively.
            If None then nothing is specified.

        Returns
        -------
        np.ndarray(n, dtype=bool)
            Returns a bool vector of the indicators in roder
        '''
        try:
            if target_cid is not None:
                if source_cid is not None:
                    ret = np.asarray([self.value[target_cid][source_cid].indicator])
                else:
                    l = len(self.clustering) - 1
                    ret = np.zeros(l, dtype=bool)
                    for iidx, interaction in enumerate(self.iter_to_target(target_cid)):
                        if interaction.indicator:
                            ret[iidx] = True
            elif source_cid is not None:
                # We do not need to check if target_cid is not None because 
                # it would have been covered in the previous check
                l = len(self.clustering) - 1
                ret = np.zeros(l, dtype=bool)
                for iidx, interaction in enumerate(self.iter_from_source(source_cid)):
                    if interaction.indicator:
                        ret[iidx] = True

            else:
                ret = np.zeros(self.size, dtype=bool)
                for idx, interaction in enumerate(self):
                    if interaction.indicator:
                        ret[idx] = True
                return ret

            return ret

        except:
            # Check to see if it is a key error, else it is something weird
            if target_cid is not None or source_cid is not None:
                if not util.isint(target_cid) or not util.isint(source_cid):
                    raise TypeError('`Either `target_cid` ({}) or `source_cid` ({})' \
                        ' must be an int'.format(type(target_cid), type(source_cid)))
                elif target_cid == source_cid:
                    raise ValueError('`target_cid` ({}) and `source_cid` ({}) cannot' \
                        ' be the same'.format(target_cid, source_cid))
            raise

    def set_indicators(self, arr):
        '''Sets the values of the indicators of the interactions from a vector.

        If `include_self_interactions` is True, assumes that `arr` contains the
        values for the self interactions. If False, assume that the indices are
        skipped.

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=bool)
            These are the indicator values to set, in order
        '''
        if len(arr) != self.size:
            raise ValueError('The number of elements in `arr` ({}) is not the ' \
                'same as the number of interactions ({})'.format(len(arr), self.size))
        for idx, interaction in enumerate(self):
            interaction.indicator = arr[idx]
            if interaction.indicator == 0:
                interaction.value = 0

    def set_values(self, arr, use_indicators=True):
        '''Sets the values of the interactions from a vector.

        If `use_indicators` is True, assumes that the values in the vector only contain
        values for interactions where the indicator variable is positive and the
        rest are skipped. If False, assumes the vector has values for where the
        indicator variables are positive and negative (all).

        Paramters
        ---------
        arr : np.ndarray(n, dtpye=float)
            These are the interaction values to set, in order
        use_indicators : bool, Optional
            If True, we only set the interactions with a positive indicator. Else we set every
            single interaction
        '''
        if not use_indicators:
            if len(arr) != self.size:
                raise ValueError('The number of elements in `arr` ({}) is not the ' \
                    'same as the number of interactions ({})'.format(len(arr), self.size))
            for idx, interaction in enumerate(self):
                interaction.value = arr[idx]
        else:
            # Dont check because it is too computationally intensive
            idx = 0
            for interaction in self:
                if not interaction.indicator:
                    continue
                interaction.value = arr[idx]
                idx += 1

    def get_values(self, use_indicators=True):
        '''Makes a vector of the interaction variables in the order of the
        clustering

        if use_indicators is True, it skips over the indices that have a negative
        indicator variable. if it is True, it goes over everthing

         Paramters
        ---------
        use_indicators : bool, Optional
            If True, we only return the interactions with a positive indicator. Else we get every
            single interaction

        Returns
        -------
        np.ndarray(n, dtype=float)
            Array of the interaction values, in order
        '''
        ret = np.zeros(self.size)
        idx = 0
        if use_indicators:
            for interaction in self.iter_valid():
                ret[idx] = interaction.value
                idx += 1
        else:
            for interaction in self:
                ret[idx] = interaction.value
                idx += 1
        # Trim if necessary
        return ret[:idx]

    def get_value_matrix(self, set_neg_indicators_to_nan=False):
        '''Get the interaction matrix at the clustert level (OTU-OTU). 
        The ordering of the clusters is the same as it is in clustering

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the OTU-OTU interaction value matrix
        '''
        n_clusters = len(self.clustering)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_clusters, n_clusters), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            tcidx = self.clustering.cid2cidx[interaction.target_cid]
            scidx = self.clustering.cid2cidx[interaction.source_cid]
            ret[tcidx, scidx] = interaction.value
        return ret

    def get_datalevel_value_matrix(self, set_neg_indicators_to_nan=False):
        '''Get the interaction matrix at the data level (OTU-OTU), not
        at the cluster level. The ordering of the OTUs is the same as 
        it is in the otuset in clustering (self.clustering.otus).

        If `set_neg_indicators_to_nan` is True, interactions that have a negative
        indicator are set to np.nan. Else, they are set to 0.

        Parameters
        ----------
        set_neg_indicators_to_nan : bool
            If True, it will set the negative interaction indicator values to 
            np.nan. Else, it will set them to 0.

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the OTU-OTU interaction value matrix
        '''
        n_otus = len(self.clustering.otus)
        if set_neg_indicators_to_nan:
            fill = np.nan
        else:
            fill = 0
        ret = np.full(shape=(n_otus, n_otus), fill_value=fill, dtype=float)
        for interaction in self:
            if not interaction.indicator:
                continue
            val = interaction.value
            for toidx in self.clustering.clusters[interaction.target_cid].members:
                for soidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[toidx, soidx] = val
        return ret
    
    def get_datalevel_indicator_matrix(self):
        '''Get the otu-otu indicator matrix.

        The ordering of the otus are the same as the order in
        self.clusters.otus.ids.order

        Returns
        -------
        np.ndarray((n,n), dtype=float)
            This is the OTU-OTU interaction value matrix
        '''
        n_otus = len(self.clustering.otus)
        ret = np.zeros(shape=(n_otus, n_otus), dtype=bool)
        for interaction in self:
            if not interaction.indicator:
                continue
            for toidx in self.clustering.clusters[interaction.target_cid].members:
                for soidx in self.clustering.clusters[interaction.source_cid].members:
                    ret[toidx, soidx] = True
        return ret

    def generate_bayes_factors_posthoc(self, prior):
        '''Generates the bayes factors on an OTU-OTU level, given the passed in prior.

        All negative indicators are set as `np.nan`s in the trace, so we do `~np.isnan`
        to get the indicators

        Parameters
        ----------
        prior : pylab.variables.Beta
            This assumes this is a beta distribution for the prior

        Returns
        -------
        np.ndarray((n,n), dtpye=float)
            These are the bayes factors for each of the interactions on an OTU-OTU level
        '''
        prior_factor = (prior.b + 1) / (prior.a + 1)
        trace = self.get_trace_from_disk()
        trace = ~ np.isnan(trace)
        ret = variables.summary(trace)['mean']
        ret = ret / (1. - ret)
        return ret * prior_factor

    def generate_in_out_degree_posthoc(self, section='posterior'):
        '''Returns a dictionary of arrays
        "in"
            For each index in the array, corresponding to the index of the OTUs, returns
            the number of incoming interactions for each iteration of the OTU
        "out"
            For each index in the array, corresponding to the index of the OTUs, returns
            the number of outgoing interactions for each iteration of the OTU

        Parameters
        ----------
        section : str
            Which section of the inference you want to choose. 
            Options:
                'posterior'
                    Only look at the posterior
                'burnin'
                    Returns the samples that were in the burnin
                'entire'
                    Returns all the samples
        '''
        trace = self.get_trace_from_disk(section=section)
        trace = ~np.isnan(trace)
        return {'in': np.sum(trace, axis=2), 'out':np.sum(trace, axis=1)}

    def set_trace(self):
        '''Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        '''
        tracer = self.G.tracer
        tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)

        self.ckpt_iter = 0
        self.sample_iter = 0
        shape = (tracer.ckpt, ) + self._shape
        self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)

    def add_trace(self):
        '''Adds the current value to the trace. If the buffer is full
        it will end it to disk
        '''
        self.trace[self.ckpt_iter] = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            shape = (self.G.tracer.ckpt, ) + self._shape
            self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
            self.ckpt_iter = 0

    def add_init_value(self):
        '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        '''
        self._init_value = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)

    def get_adjacent(self, cid, incoming, outgoing, use_indicators=True):
        '''Get all of the cluster IDs that have a positive interaction going into
        or from the cluster `cid`.

        Parameters
        ----------
        cid : int
            This is the Cluster ID you want to get the adjacent clusters of
        incoming : bool 
            Get the cids of the incoming edges
        outgoing : bool
            Get the cids of the outgoing edges
        use_indicators : bool
            If this is True then if the indicator is False then we do not include.
            If this is False then we always include the interaction

        Returns
        -------
        list
            List of cids
        '''
        if cid not in self.clustering.order:
            raise ValueError('`cid` ({}) not found'.format(cid))
        cids = []
        if incoming:
            for interaction in self.iter_from_source(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.target_cid)
        if outgoing:
            for interaction in self.iter_to_target(cid):
                if interaction.indicator or not use_indicators:
                    cids.append(interaction.source_cid)
        return cids
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.contrib.Interactions">Interactions</a></li>
          <li>pylab.cluster.ClusterProperty</li>
          <li>pylab.graph.Node</li>
          <li>pylab.graph.BaseNode</li>
          <li>pylab.base.Saveable</li>
          <li>pylab.base.Traceable</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, clustering, use_indicators, value_initializer=None, indicator_initializer=None, signal_when_clusters_change=True, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.__init__" class="source">
    <pre><code>def __init__(self, clustering, use_indicators, 
    value_initializer=None, indicator_initializer=None, 
    signal_when_clusters_change=True, **kwargs):
    Node.__init__(self, **kwargs)
    ClusterProperty.__init__(self, clustering=clustering, 
        signal_when_clusters_change=signal_when_clusters_change, 
        signal_when_otu_assignment_changes=False)
    if value_initializer is None:
        value_initializer = _always_return_nan
    if indicator_initializer is None:
        indicator_initializer = _always_return_nan
    if not np.all(util.itercheck([value_initializer, indicator_initializer], callable)):
        raise TypeError('`value_initializer` ({}) and `indicator_initializer` ({}) ' \
            'must be callable'.format(type(value_initializer), 
            type(indicator_initializer)))
    self.value_initializer = value_initializer
    self.indicator_initializer = indicator_initializer
    
    if not util.isbool(use_indicators):
        raise TypeError('`use_indicators` ({}) must be a bool'.format(type(use_indicators)))
    self.use_indicators = use_indicators
    if not self.use_indicators:
        self.indicator_initializer = _always_return_true
    order = self.clustering.order
    self.value = {}
    for tcid in order:
        self.value[tcid] = {}
        for scid in order:
            if tcid == scid:
                continue
            self.value[tcid][scid] = _Interaction( 
                source_cid=scid, target_cid=tcid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer())
    self._shape = (len(self.clustering.otus), len(self.clustering.otus))
    self.dtype = float
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.add_child">
    <p>def <span class="ident">add_child</span>(</p><p>self, child)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>child</code> as a child to the node
Also adds self as a parent to <code>child</code></p>
<h2>Parameters</h2>
<p>child : Node
    - node we want to set as a child</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.add_child', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.add_child" class="source">
    <pre><code>def add_child(self, child):
    '''Adds `child` as a child to the node
    Also adds self as a parent to `child`
    Parameters
    ----------
    child : Node
        - node we want to set as a child
    '''
    if not isnode(child):
        raise ValueError('child ({}) must be a (subclass of) Node'.format( 
            type(child)))
    if self.G.id != child.G.id:
        raise GraphIDError('Attempting to add a child `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, child.name))
    self.children[child.id] = child
    child.parents[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.add_init_value">
    <p>def <span class="ident">add_init_value</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the initialization value. This is called by <code>pylab.inference.BaseMCMC.run</code>
when first updating the variable. User should not use this function</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.add_init_value', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.add_init_value" class="source">
    <pre><code>def add_init_value(self):
    '''Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
    when first updating the variable. User should not use this function
    '''
    self._init_value = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.add_parent">
    <p>def <span class="ident">add_parent</span>(</p><p>self, parent)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>parent</code> as a parent to the node
Also adds self as a child to <code>parent</code></p>
<h2>Parameters</h2>
<p>parent : Node
    - node we want to set as a parent</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.add_parent', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.add_parent" class="source">
    <pre><code>def add_parent(self, parent):
    '''Adds `parent` as a parent to the node
    Also adds self as a child to `parent`
    Parameters
    ----------
    parent : Node
        - node we want to set as a parent
    '''
    if not isnode(parent):
        raise ValueError('parent ({}) must be a (subclass of) Node'.format( 
            type(parent)))
    if self.G.id != parent.G.id:
        raise GraphIDError('Attempting to add a parent `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, parent.name))
    self.parents[parent.id] = parent
    parent.children[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.add_prior">
    <p>def <span class="ident">add_prior</span>(</p><p>self, prior)</p>
    </div>
    

    
  
    <div class="desc"><p>Override the name of the passed in distribution <code>prior</code>.</p>
<h2>Parameters</h2>
<p>prior : Node
    - node we want to set as a prior</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.add_prior', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.add_prior" class="source">
    <pre><code>def add_prior(self, prior):
    '''Override the name of the passed in distribution `prior`.
    Parameters
    ----------
    prior : Node
        - node we want to set as a prior
    '''
    if not isnode(prior):
        raise ValueError('prior ({}) must be a (subclass of) Node'.format( 
            type(prior)))
    self.add_parent(prior)
    self.prior = prior
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.add_trace">
    <p>def <span class="ident">add_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds the current value to the trace. If the buffer is full
it will end it to disk</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.add_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.add_trace" class="source">
    <pre><code>def add_trace(self):
    '''Adds the current value to the trace. If the buffer is full
    it will end it to disk
    '''
    self.trace[self.ckpt_iter] = self.get_datalevel_value_matrix(set_neg_indicators_to_nan=True)
    self.ckpt_iter += 1
    self.sample_iter += 1
    if self.ckpt_iter == len(self.trace):
        # We have gotten the largest we can in the local buffer, write to disk
        self.G.tracer.write_to_disk(name=self.name)
        shape = (self.G.tracer.ckpt, ) + self._shape
        self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
        self.ckpt_iter = 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.add_undirected">
    <p>def <span class="ident">add_undirected</span>(</p><p>self, node)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds <code>node</code> as an undirected neighbor to the node
Does the same for <code>node</code></p>
<h2>Parameters</h2>
<p>node : Node
    - node we want to set as an undirected node</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.add_undirected', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.add_undirected" class="source">
    <pre><code>def add_undirected(self, node):
    '''Adds `node` as an undirected neighbor to the node
    Does the same for `node`
    Parameters
    ----------
    node : Node
        - node we want to set as an undirected node
    '''
    if not isnode(node):
        raise ValueError('node ({}) must be a (subclass of) Node'.format( 
            type(node)))
    if self.G.id != node.G.id:
        raise GraphIDError('Attempting to add a node `{}` to `{}` ' \
            'but they are not in the same graph'.format(self.name, node.name))
    self.undirected[node.id] = node
    node.undirected[self.id] = self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.assignments_changed">
    <p>def <span class="ident">assignments_changed</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.assignments_changed', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.assignments_changed" class="source">
    <pre><code>def assignments_changed(self):
    raise NeedToImplementError('User needs to implement this function')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.clusters_changed">
    <p>def <span class="ident">clusters_changed</span>(</p><p>self, cids_added, cids_removed)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove all of the interactions to and from the clusters
in <code>cids_removed</code> and make interactions for the <code>cid_added</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.clusters_changed', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.clusters_changed" class="source">
    <pre><code>def clusters_changed(self, cids_added, cids_removed):
    '''Remove all of the interactions to and from the clusters
    in `cids_removed` and make interactions for the `cid_added`
    '''
    # Remove interactions from clusters deleted
    if len(cids_removed) > 0:
        for cid in cids_removed:
            self.value.pop(cid, None)
        for cid in self.value.keys():
            for cid_del in cids_removed:
                self.value[cid].pop(cid_del, None)
    if len(cids_added) > 0:
        for cid in cids_added:
            self._add_single_cluster(cid)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.delete">
    <p>def <span class="ident">delete</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete itself from the graph</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.delete', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.delete" class="source">
    <pre><code>def delete(self):
    '''Delete itself from the graph
    '''
    if len(self.parents) > 0:
        for pid in self.parents:
            self.G.nodes[pid].children.pop(self.id, None)
    if len(self.children) > 0:
        for cid in self.children:
            self.G.nodes[cid].parents.pop(self.id, None)
    if len(self.undirected) > 0:
        for uid in self.undirected:
            self.G.nodes[uid].undirected.pop(self.id, None)
    BaseNode.delete(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.generate_bayes_factors_posthoc">
    <p>def <span class="ident">generate_bayes_factors_posthoc</span>(</p><p>self, prior)</p>
    </div>
    

    
  
    <div class="desc"><p>Generates the bayes factors on an OTU-OTU level, given the passed in prior.</p>
<p>All negative indicators are set as <code>np.nan</code>s in the trace, so we do <code>~np.isnan</code>
to get the indicators</p>
<h2>Parameters</h2>
<p>prior : pylab.variables.Beta
    This assumes this is a beta distribution for the prior</p>
<h2>Returns</h2>
<p>np.ndarray((n,n), dtpye=float)
    These are the bayes factors for each of the interactions on an OTU-OTU level</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.generate_bayes_factors_posthoc', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.generate_bayes_factors_posthoc" class="source">
    <pre><code>def generate_bayes_factors_posthoc(self, prior):
    '''Generates the bayes factors on an OTU-OTU level, given the passed in prior.
    All negative indicators are set as `np.nan`s in the trace, so we do `~np.isnan`
    to get the indicators
    Parameters
    ----------
    prior : pylab.variables.Beta
        This assumes this is a beta distribution for the prior
    Returns
    -------
    np.ndarray((n,n), dtpye=float)
        These are the bayes factors for each of the interactions on an OTU-OTU level
    '''
    prior_factor = (prior.b + 1) / (prior.a + 1)
    trace = self.get_trace_from_disk()
    trace = ~ np.isnan(trace)
    ret = variables.summary(trace)['mean']
    ret = ret / (1. - ret)
    return ret * prior_factor
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.generate_in_out_degree_posthoc">
    <p>def <span class="ident">generate_in_out_degree_posthoc</span>(</p><p>self, section=&#39;posterior&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a dictionary of arrays
"in"
    For each index in the array, corresponding to the index of the OTUs, returns
    the number of incoming interactions for each iteration of the OTU
"out"
    For each index in the array, corresponding to the index of the OTUs, returns
    the number of outgoing interactions for each iteration of the OTU</p>
<h2>Parameters</h2>
<p>section : str
    Which section of the inference you want to choose. 
    Options:
        'posterior'
            Only look at the posterior
        'burnin'
            Returns the samples that were in the burnin
        'entire'
            Returns all the samples</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.generate_in_out_degree_posthoc', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.generate_in_out_degree_posthoc" class="source">
    <pre><code>def generate_in_out_degree_posthoc(self, section='posterior'):
    '''Returns a dictionary of arrays
    "in"
        For each index in the array, corresponding to the index of the OTUs, returns
        the number of incoming interactions for each iteration of the OTU
    "out"
        For each index in the array, corresponding to the index of the OTUs, returns
        the number of outgoing interactions for each iteration of the OTU
    Parameters
    ----------
    section : str
        Which section of the inference you want to choose. 
        Options:
            'posterior'
                Only look at the posterior
            'burnin'
                Returns the samples that were in the burnin
            'entire'
                Returns all the samples
    '''
    trace = self.get_trace_from_disk(section=section)
    trace = ~np.isnan(trace)
    return {'in': np.sum(trace, axis=2), 'out':np.sum(trace, axis=1)}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_adjacent">
    <p>def <span class="ident">get_adjacent</span>(</p><p>self, cid, incoming, outgoing, use_indicators=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Get all of the cluster IDs that have a positive interaction going into
or from the cluster <code>cid</code>.</p>
<h2>Parameters</h2>
<p>cid : int
    This is the Cluster ID you want to get the adjacent clusters of
incoming : bool 
    Get the cids of the incoming edges
outgoing : bool
    Get the cids of the outgoing edges
use_indicators : bool
    If this is True then if the indicator is False then we do not include.
    If this is False then we always include the interaction</p>
<h2>Returns</h2>
<p>list
    List of cids</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_adjacent', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_adjacent" class="source">
    <pre><code>def get_adjacent(self, cid, incoming, outgoing, use_indicators=True):
    '''Get all of the cluster IDs that have a positive interaction going into
    or from the cluster `cid`.
    Parameters
    ----------
    cid : int
        This is the Cluster ID you want to get the adjacent clusters of
    incoming : bool 
        Get the cids of the incoming edges
    outgoing : bool
        Get the cids of the outgoing edges
    use_indicators : bool
        If this is True then if the indicator is False then we do not include.
        If this is False then we always include the interaction
    Returns
    -------
    list
        List of cids
    '''
    if cid not in self.clustering.order:
        raise ValueError('`cid` ({}) not found'.format(cid))
    cids = []
    if incoming:
        for interaction in self.iter_from_source(cid):
            if interaction.indicator or not use_indicators:
                cids.append(interaction.target_cid)
    if outgoing:
        for interaction in self.iter_to_target(cid):
            if interaction.indicator or not use_indicators:
                cids.append(interaction.source_cid)
    return cids
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_adjacent_keys">
    <p>def <span class="ident">get_adjacent_keys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the adjacent nodes</p>
<h2>Returns</h2>
<p>list(int)
    A list of all the IDs of the adjacent nodes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_adjacent_keys', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_adjacent_keys" class="source">
    <pre><code>def get_adjacent_keys(self):
    '''Get the adjacent nodes
    Returns
    -------
    list(int)
        A list of all the IDs of the adjacent nodes
    '''
    return list(self.parents.keys()) + list(self.children.keys())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_arg_indicators">
    <p>def <span class="ident">get_arg_indicators</span>(</p><p>self, target_cid=None, source_cid=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the positive indicators as indices, in order -&gt; same convention
as <code>get_indicators</code>.</p>
<p>If <code>target_cid</code> is specfied, it will get all of the positive indicator indicies 
going to the target cluster <code>target_cid</code> in order. If <code>source_cid</code> is specified,
then it will get all of the positive indicator indices going to the source cluster 
<code>source_cid</code> in order. If both <code>target_cid</code> and <code>source_cid</code> are specified,
it will return an empty array if the indicator is False or it will return
an array of size 1 if the indicator is True.</p>
<h2>Parameters</h2>
<p>target_cid, source_cid : int, None
    These are the target cluster ID and source cluster ID, respectively.
    If None then nothing is specified.</p>
<h2>Returns</h2>
<p>list(int)
    Returns a list of the interactions that are positive in order</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_arg_indicators', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_arg_indicators" class="source">
    <pre><code>def get_arg_indicators(self, target_cid=None, source_cid=None):
    '''Get the positive indicators as indices, in order -> same convention
    as `get_indicators`.
    If `target_cid` is specfied, it will get all of the positive indicator indicies 
    going to the target cluster `target_cid` in order. If `source_cid` is specified,
    then it will get all of the positive indicator indices going to the source cluster 
    `source_cid` in order. If both `target_cid` and `source_cid` are specified,
    it will return an empty array if the indicator is False or it will return
    an array of size 1 if the indicator is True.
    Parameters
    ----------
    target_cid, source_cid : int, None
        These are the target cluster ID and source cluster ID, respectively.
        If None then nothing is specified.
    Returns
    -------
    list(int)
        Returns a list of the interactions that are positive in order
    '''
    ret = []
    try:
        if target_cid is not None:
            n_clusters = len(self.clustering)
            tcidx = self.clustering.cid2cidx[target_cid]
            if source_cid is not None:
                if self.value[target_cid][source_cid].indicator:
                    scidx = self.clustering.cid2cidx[source_cid]
                    if tcidx < scidx:
                        scidx -= 1
                    iidx = tcidx * (n_clusters - 1) + scidx
                    ret.append(iidx)
            else:
                base_idx = tcidx * (n_clusters - 1)
                for offset, interaction in enumerate(self.iter_to_target(target_cid)):
                    if interaction.indicator:
                        ret.append(base_idx + offset)
        
        elif source_cid is not None:
            # We do not need to check if target_cid is not None because 
            # it would have been covered in the previous check
            scidx = self.clustering.cid2cidx[source_cid]
            for interaction in self.iter_from_source(source_cid):
                if interaction.indicator:
                    tcidx = self.clustering.cid2cidx[interaction.target_cid]
                    iidx = tcidx * (n_clusters - 1) + scidx
                    if scidx > tcidx:
                        iidx -= 1
                    ret.append(iidx)
        else:
            for idx, interaction in enumerate(self):
                if interaction.indicator:
                    ret.append(idx)
        return ret
    except:
        # Check to see if it is a key error, else it is something weird
        if target_cid is not None or source_cid is not None:
            if not util.isint(target_cid) or not util.isint(source_cid):
                raise TypeError('`Either `target_cid` ({}) or `source_cid` ({})' \
                    ' must be an int'.format(type(target_cid), type(source_cid)))
            elif target_cid == source_cid:
                raise ValueError('`target_cid` ({}) and `source_cid` ({}) cannot' \
                    ' be the same'.format(target_cid, source_cid))
        raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_datalevel_indicator_matrix">
    <p>def <span class="ident">get_datalevel_indicator_matrix</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the otu-otu indicator matrix.</p>
<p>The ordering of the otus are the same as the order in
self.clusters.otus.ids.order</p>
<h2>Returns</h2>
<p>np.ndarray((n,n), dtype=float)
    This is the OTU-OTU interaction value matrix</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_datalevel_indicator_matrix', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_datalevel_indicator_matrix" class="source">
    <pre><code>def get_datalevel_indicator_matrix(self):
    '''Get the otu-otu indicator matrix.
    The ordering of the otus are the same as the order in
    self.clusters.otus.ids.order
    Returns
    -------
    np.ndarray((n,n), dtype=float)
        This is the OTU-OTU interaction value matrix
    '''
    n_otus = len(self.clustering.otus)
    ret = np.zeros(shape=(n_otus, n_otus), dtype=bool)
    for interaction in self:
        if not interaction.indicator:
            continue
        for toidx in self.clustering.clusters[interaction.target_cid].members:
            for soidx in self.clustering.clusters[interaction.source_cid].members:
                ret[toidx, soidx] = True
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_datalevel_value_matrix">
    <p>def <span class="ident">get_datalevel_value_matrix</span>(</p><p>self, set_neg_indicators_to_nan=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the interaction matrix at the data level (OTU-OTU), not
at the cluster level. The ordering of the OTUs is the same as 
it is in the otuset in clustering (self.clustering.otus).</p>
<p>If <code>set_neg_indicators_to_nan</code> is True, interactions that have a negative
indicator are set to np.nan. Else, they are set to 0.</p>
<h2>Parameters</h2>
<p>set_neg_indicators_to_nan : bool
    If True, it will set the negative interaction indicator values to 
    np.nan. Else, it will set them to 0.</p>
<h2>Returns</h2>
<p>np.ndarray((n,n), dtype=float)
    This is the OTU-OTU interaction value matrix</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_datalevel_value_matrix', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_datalevel_value_matrix" class="source">
    <pre><code>def get_datalevel_value_matrix(self, set_neg_indicators_to_nan=False):
    '''Get the interaction matrix at the data level (OTU-OTU), not
    at the cluster level. The ordering of the OTUs is the same as 
    it is in the otuset in clustering (self.clustering.otus).
    If `set_neg_indicators_to_nan` is True, interactions that have a negative
    indicator are set to np.nan. Else, they are set to 0.
    Parameters
    ----------
    set_neg_indicators_to_nan : bool
        If True, it will set the negative interaction indicator values to 
        np.nan. Else, it will set them to 0.
    Returns
    -------
    np.ndarray((n,n), dtype=float)
        This is the OTU-OTU interaction value matrix
    '''
    n_otus = len(self.clustering.otus)
    if set_neg_indicators_to_nan:
        fill = np.nan
    else:
        fill = 0
    ret = np.full(shape=(n_otus, n_otus), fill_value=fill, dtype=float)
    for interaction in self:
        if not interaction.indicator:
            continue
        val = interaction.value
        for toidx in self.clustering.clusters[interaction.target_cid].members:
            for soidx in self.clustering.clusters[interaction.source_cid].members:
                ret[toidx, soidx] = val
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_indicators">
    <p>def <span class="ident">get_indicators</span>(</p><p>self, target_cid=None, source_cid=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a the indicator variables as a vector in the order specified
by the clusters.</p>
<p>if <code>target_cid</code> is specified then it will return all indicators going
to that cluster. If <code>source_cid</code> is specified then it will return all
indicators going from that cluster. If both are specifeid then it
will return an array of size 1 of a bool</p>
<h2>Parameters</h2>
<p>target_cid, source_cid : int, None
    These are the target cluster ID and source cluster ID, respectively.
    If None then nothing is specified.</p>
<h2>Returns</h2>
<p>np.ndarray(n, dtype=bool)
    Returns a bool vector of the indicators in roder</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_indicators', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_indicators" class="source">
    <pre><code>def get_indicators(self, target_cid=None, source_cid=None):
    '''Return a the indicator variables as a vector in the order specified
    by the clusters.
    if `target_cid` is specified then it will return all indicators going
    to that cluster. If `source_cid` is specified then it will return all
    indicators going from that cluster. If both are specifeid then it
    will return an array of size 1 of a bool
    Parameters
    ----------
    target_cid, source_cid : int, None
        These are the target cluster ID and source cluster ID, respectively.
        If None then nothing is specified.
    Returns
    -------
    np.ndarray(n, dtype=bool)
        Returns a bool vector of the indicators in roder
    '''
    try:
        if target_cid is not None:
            if source_cid is not None:
                ret = np.asarray([self.value[target_cid][source_cid].indicator])
            else:
                l = len(self.clustering) - 1
                ret = np.zeros(l, dtype=bool)
                for iidx, interaction in enumerate(self.iter_to_target(target_cid)):
                    if interaction.indicator:
                        ret[iidx] = True
        elif source_cid is not None:
            # We do not need to check if target_cid is not None because 
            # it would have been covered in the previous check
            l = len(self.clustering) - 1
            ret = np.zeros(l, dtype=bool)
            for iidx, interaction in enumerate(self.iter_from_source(source_cid)):
                if interaction.indicator:
                    ret[iidx] = True
        else:
            ret = np.zeros(self.size, dtype=bool)
            for idx, interaction in enumerate(self):
                if interaction.indicator:
                    ret[idx] = True
            return ret
        return ret
    except:
        # Check to see if it is a key error, else it is something weird
        if target_cid is not None or source_cid is not None:
            if not util.isint(target_cid) or not util.isint(source_cid):
                raise TypeError('`Either `target_cid` ({}) or `source_cid` ({})' \
                    ' must be an int'.format(type(target_cid), type(source_cid)))
            elif target_cid == source_cid:
                raise ValueError('`target_cid` ({}) and `source_cid` ({}) cannot' \
                    ' be the same'.format(target_cid, source_cid))
        raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_iter">
    <p>def <span class="ident">get_iter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the number of iterations saved to the hdf5 file of the variable</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_iter', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_iter" class="source">
    <pre><code>def get_iter(self):
    '''Get the number of iterations saved to the hdf5 file of the variable
    Returns
    -------
    int
    '''
    return self.G.tracer.get_iter(name=self.name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_trace_from_disk">
    <p>def <span class="ident">get_trace_from_disk</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
include the samples in the local buffer trace and could be very large</p>
<h2>Returns</h2>
<p>np.ndarray</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_trace_from_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_trace_from_disk" class="source">
    <pre><code>def get_trace_from_disk(self, *args, **kwargs):
    '''Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
    include the samples in the local buffer trace and could be very large
    Returns
    -------
    np.ndarray
    '''
    return self.G.tracer.get_trace(name=self.name, *args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_value_matrix">
    <p>def <span class="ident">get_value_matrix</span>(</p><p>self, set_neg_indicators_to_nan=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the interaction matrix at the clustert level (OTU-OTU). 
The ordering of the clusters is the same as it is in clustering</p>
<p>If <code>set_neg_indicators_to_nan</code> is True, interactions that have a negative
indicator are set to np.nan. Else, they are set to 0.</p>
<h2>Parameters</h2>
<p>set_neg_indicators_to_nan : bool
    If True, it will set the negative interaction indicator values to 
    np.nan. Else, it will set them to 0.</p>
<h2>Returns</h2>
<p>np.ndarray((n,n), dtype=float)
    This is the OTU-OTU interaction value matrix</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_value_matrix', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_value_matrix" class="source">
    <pre><code>def get_value_matrix(self, set_neg_indicators_to_nan=False):
    '''Get the interaction matrix at the clustert level (OTU-OTU). 
    The ordering of the clusters is the same as it is in clustering
    If `set_neg_indicators_to_nan` is True, interactions that have a negative
    indicator are set to np.nan. Else, they are set to 0.
    Parameters
    ----------
    set_neg_indicators_to_nan : bool
        If True, it will set the negative interaction indicator values to 
        np.nan. Else, it will set them to 0.
    Returns
    -------
    np.ndarray((n,n), dtype=float)
        This is the OTU-OTU interaction value matrix
    '''
    n_clusters = len(self.clustering)
    if set_neg_indicators_to_nan:
        fill = np.nan
    else:
        fill = 0
    ret = np.full(shape=(n_clusters, n_clusters), fill_value=fill, dtype=float)
    for interaction in self:
        if not interaction.indicator:
            continue
        tcidx = self.clustering.cid2cidx[interaction.target_cid]
        scidx = self.clustering.cid2cidx[interaction.source_cid]
        ret[tcidx, scidx] = interaction.value
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.get_values">
    <p>def <span class="ident">get_values</span>(</p><p>self, use_indicators=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Makes a vector of the interaction variables in the order of the
clustering</p>
<p>if use_indicators is True, it skips over the indices that have a negative
indicator variable. if it is True, it goes over everthing</p>
<h2>Paramters</h2>
<p>use_indicators : bool, Optional
    If True, we only return the interactions with a positive indicator. Else we get every
    single interaction</p>
<h2>Returns</h2>
<p>np.ndarray(n, dtype=float)
    Array of the interaction values, in order</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.get_values', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.get_values" class="source">
    <pre><code>def get_values(self, use_indicators=True):
    '''Makes a vector of the interaction variables in the order of the
    clustering
    if use_indicators is True, it skips over the indices that have a negative
    indicator variable. if it is True, it goes over everthing
     Paramters
    ---------
    use_indicators : bool, Optional
        If True, we only return the interactions with a positive indicator. Else we get every
        single interaction
    Returns
    -------
    np.ndarray(n, dtype=float)
        Array of the interaction values, in order
    '''
    ret = np.zeros(self.size)
    idx = 0
    if use_indicators:
        for interaction in self.iter_valid():
            ret[idx] = interaction.value
            idx += 1
    else:
        for interaction in self:
            ret[idx] = interaction.value
            idx += 1
    # Trim if necessary
    return ret[:idx]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.iloc">
    <p>def <span class="ident">iloc</span>(</p><p>self, idx)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the interaction as a function of the index that it occurs at.
Reverse indexing is allowed.</p>
<h2>Parameters</h2>
<p>idx : int
    This is the index that the interaction occurs at</p>
<h2>Returns</h2>
<p>pylab.contrib._Interaction</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.iloc', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.iloc" class="source">
    <pre><code>def iloc(self, idx):
    '''Get the interaction as a function of the index that it occurs at.
    Reverse indexing is allowed.
    Parameters
    ----------
    idx : int
        This is the index that the interaction occurs at
    Returns
    -------
    pylab.contrib._Interaction
    '''
    if not util.isint(idx):
        raise TypeError('`idx` ({}) must be an int'.format(idx))
    if idx >= self.size:
        raise ValueError('`idx` ({}) cannot be >= the number of interactions ({})'.format(
            idx, self.size))
    if idx < 0:
        idx = self.size - idx
    tcidx = idx // (len(self.clustering) - 1)
    scidx = idx - tcidx * (len(self.clustering) - 1)
    if scidx >= tcidx:
        scidx += 1
    return self.value[
        self.clustering.order[tcidx]][
        self.clustering.order[scidx]]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.iter_from_source">
    <p>def <span class="ident">iter_from_source</span>(</p><p>self, cid, only_valid=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Iterates over interactions from the source cluster to all
target clusters in the order specified by clusters</p>
<h2>Paramters</h2>
<p>cid (int)
    This is the source cluster id
only_valid : bool
    If True, only returns the interactions with a positive indicator</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.iter_from_source', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.iter_from_source" class="source">
    <pre><code>def iter_from_source(self, cid, only_valid=False):
    '''Iterates over interactions from the source cluster to all
    target clusters in the order specified by clusters
    Paramters
    ---------
    cid (int)
        This is the source cluster id
    only_valid : bool
        If True, only returns the interactions with a positive indicator
    '''
    order = self.clustering.order
    if only_valid:
        for tcid in order:
            if tcid != cid:
                if self.value[tcid][cid].indicator:
                    yield self.value[tcid][cid]
    else:
        for tcid in order:
            if tcid != cid:
                yield self.value[tcid][cid]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.iter_to_target">
    <p>def <span class="ident">iter_to_target</span>(</p><p>self, cid, only_valid=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Iterates over interactions to the target cluster from all
source clusters in the order specified by clusters</p>
<h2>Paramters</h2>
<p>cid : int
    This is the target cluster id we are iterating from
only_valid : bool
    If True, only returns the interactions with a positive indicator</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.iter_to_target', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.iter_to_target" class="source">
    <pre><code>def iter_to_target(self, cid, only_valid=False):
    '''Iterates over interactions to the target cluster from all
    source clusters in the order specified by clusters
    Paramters
    ---------
    cid : int
        This is the target cluster id we are iterating from
    only_valid : bool
        If True, only returns the interactions with a positive indicator
    '''
    order = self.clustering.order
    temp = self.value[cid] # For quicker pointer
    if only_valid:
        for scid in order:
            if scid != cid:
                if temp[scid].indicator:
                    yield temp[scid]
    else:
        for scid in order:
            if scid != cid:
                yield temp[scid]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.iter_valid">
    <p>def <span class="ident">iter_valid</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Iterate only over the positive indicators</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.iter_valid', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.iter_valid" class="source">
    <pre><code>def iter_valid(self):
    '''Iterate only over the positive indicators
    '''
    order = self.clustering.order
    for tcid in order:
        temp = self.value[tcid] # Faster pointer
        for scid in order:
            if tcid != scid:
                if temp[scid].indicator:
                    yield temp[scid]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.iter_valid_pairs">
    <p>def <span class="ident">iter_valid_pairs</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Iterate only over the positive indicators</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.iter_valid_pairs', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.iter_valid_pairs" class="source">
    <pre><code>def iter_valid_pairs(self):
    '''Iterate only over the positive indicators
    '''
    order = self.clustering.order
    for tcid in order:
        temp = self.value[tcid] # Faster pointer
        for scid in order:
            if tcid != scid:
                if temp[scid].indicator:
                    yield tcid, scid
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.key_pairs">
    <p>def <span class="ident">key_pairs</span>(</p><p>self, only_valid=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns (target,source) cluster ids in order</p>
<h2>Parameters</h2>
<p>only_valid : bool
    If True, it will only return the key pairs that have a positive indicator.
    Else it will return all of the interactions regardless of the indicator.</p>
<h2>Returns</h2>
<p>list((int,int))
    Return a list of the (target, source) cluster IDs for each interaciton
    in order.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.key_pairs', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.key_pairs" class="source">
    <pre><code>def key_pairs(self, only_valid=False):
    '''Returns (target,source) cluster ids in order
    Parameters
    ----------
    only_valid : bool
        If True, it will only return the key pairs that have a positive indicator.
        Else it will return all of the interactions regardless of the indicator.
    Returns 
    -------
    list((int,int))
        Return a list of the (target, source) cluster IDs for each interaciton
        in order.
    '''
    order = self.clustering.order
    l = []
    for tcid in order:
        for scid in order:
            if tcid != scid:
                if only_valid:
                    if self.value[tcid][scid].indicator:
                        l.append((tcid, scid))
                else:
                    l.append((tcid,scid))
    return l
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.num_neg_indicators">
    <p>def <span class="ident">num_neg_indicators</span>(</p><p>self, target_cid=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the number of indicator variables that are 0</p>
<p>If target_cid is not None, calculate them for only the interactions going into
that cluster</p>
<h2>Paramters</h2>
<p>target_cid : int, Optional
    If this is specified, get only the negative indicators going into the cluster 
    <code>target_cid</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.num_neg_indicators', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.num_neg_indicators" class="source">
    <pre><code>def num_neg_indicators(self, target_cid=None):
    '''Return the number of indicator variables that are 0
    If target_cid is not None, calculate them for only the interactions going into
    that cluster
    Paramters
    ---------
    target_cid : int, Optional
        If this is specified, get only the negative indicators going into the cluster 
        `target_cid`
    '''
    cumm = 0
    if target_cid is not None:
        for interaction in self.iter_to_target(target_cid):
            cumm += not interaction.indicator
    else:
        for interaction in self:
            cumm += not interaction.indicator
    return cumm
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.num_pos_indicators">
    <p>def <span class="ident">num_pos_indicators</span>(</p><p>self, target_cid=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the number of indicator variables that are 1</p>
<p>If target_cid is not None, calculate them for only the interactions going into
that cluster</p>
<h2>Paramters</h2>
<p>target_cid : int, Optional
    If this is specified, get only the positive indicators going into the cluster 
    <code>target_cid</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.num_pos_indicators', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.num_pos_indicators" class="source">
    <pre><code>def num_pos_indicators(self, target_cid=None):
    '''Return the number of indicator variables that are 1
    If target_cid is not None, calculate them for only the interactions going into
    that cluster
    Paramters
    ---------
    target_cid : int, Optional
        If this is specified, get only the positive indicators going into the cluster 
        `target_cid`
    '''
    cumm = 0
    if target_cid is not None:
        for interaction in self.iter_to_target(target_cid):
            cumm += interaction.indicator
    else:
        for interaction in self:
            cumm += interaction.indicator
    return cumm
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.overwrite_entire_trace_on_disk">
    <p>def <span class="ident">overwrite_entire_trace_on_disk</span>(</p><p>self, data, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrites the entire trace of the variable with the given data.</p>
<h2>Parameters</h2>
<p>data : np.ndarray
    Data you are overwriting the trace with.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.overwrite_entire_trace_on_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.overwrite_entire_trace_on_disk" class="source">
    <pre><code>def overwrite_entire_trace_on_disk(self, data, **kwargs):
    '''Overwrites the entire trace of the variable with the given data.
    Parameters
    ----------
    data : np.ndarray
        Data you are overwriting the trace with.
    '''
    self.G.tracer.overwrite_entire_trace_on_disk(
        name=self.name, data=data, dtype=self.dtype, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.reset">
    <p>def <span class="ident">reset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Call this function after you set the <code>signal_when_otu_assignment_changes</code> or
<code>signal_when_clusters_change</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.reset', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.reset" class="source">
    <pre><code>def reset(self):
    self.value = {}
    for tcid in self.clustering.order:
        self.value[tcid] = {}
        for scid in self.clustering.order:
            if tcid == scid:
                continue
            self.value[tcid][scid] = _Interaction(
                source_cid=scid, target_cid=tcid,
                value=self.value_initializer(),
                indicator=self.indicator_initializer()>=.5)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <code>pylab.base.Saveable.set_save_location</code>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.set_indicators">
    <p>def <span class="ident">set_indicators</span>(</p><p>self, arr)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the values of the indicators of the interactions from a vector.</p>
<p>If <code>include_self_interactions</code> is True, assumes that <code>arr</code> contains the
values for the self interactions. If False, assume that the indices are
skipped.</p>
<h2>Paramters</h2>
<p>arr : np.ndarray(n, dtpye=bool)
    These are the indicator values to set, in order</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.set_indicators', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.set_indicators" class="source">
    <pre><code>def set_indicators(self, arr):
    '''Sets the values of the indicators of the interactions from a vector.
    If `include_self_interactions` is True, assumes that `arr` contains the
    values for the self interactions. If False, assume that the indices are
    skipped.
    Paramters
    ---------
    arr : np.ndarray(n, dtpye=bool)
        These are the indicator values to set, in order
    '''
    if len(arr) != self.size:
        raise ValueError('The number of elements in `arr` ({}) is not the ' \
            'same as the number of interactions ({})'.format(len(arr), self.size))
    for idx, interaction in enumerate(self):
        interaction.indicator = arr[idx]
        if interaction.indicator == 0:
            interaction.value = 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.set_signal_when_clusters_change">
    <p>def <span class="ident">set_signal_when_clusters_change</span>(</p><p>self, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Switch the signal <code>signal_when_clusters_change</code> to <code>value</code></p>
<h2>Paramters</h2>
<p>value : bool
    This is what to set the <code>signal_when_clusters_change</code> flag to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.set_signal_when_clusters_change', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.set_signal_when_clusters_change" class="source">
    <pre><code>def set_signal_when_clusters_change(self, value):
    '''Switch the signal `signal_when_clusters_change` to `value`
    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_clusters_change` flag to
    '''
    if not util.isbool(value):
        raise ValueError('`value` ({}) must be a bool'.format(
            type(value)))
    # Only need to change if they are different
    if self.signal_when_clusters_change != value:
        if self.signal_when_clusters_change:
            # We need to take it out
            self.clustering.properties.signal_when_clusters_change.remove(self)
        else:
            self.clustering.properties.signal_when_clusters_change.append(self)
    self.signal_when_clusters_change = value
    self.reset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.set_signal_when_otu_assignment_changes">
    <p>def <span class="ident">set_signal_when_otu_assignment_changes</span>(</p><p>self, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Switch the signal <code>signal_when_otu_assignment_changes</code> to <code>value</code></p>
<h2>Paramters</h2>
<p>value : bool
    This is what to set the <code>signal_when_otu_assignment_changes</code> flag to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.set_signal_when_otu_assignment_changes', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.set_signal_when_otu_assignment_changes" class="source">
    <pre><code>def set_signal_when_otu_assignment_changes(self, value):
    '''Switch the signal `signal_when_otu_assignment_changes` to `value`
    Paramters
    ---------
    value : bool
        This is what to set the `signal_when_otu_assignment_changes` flag to
    '''
    if not util.isbool(value):
        raise ValueError('`value` ({}) must be a bool'.format(
            type(value)))
    # Only need to chagne if they are different
    if self.signal_when_otu_assignment_changes != value:
        if self.signal_when_otu_assignment_changes:
            # We need to take it out
            self.clustering.properties.signal_when_otu_assignment_changes.remove(self)
        else:
            self.clustering.properties.signal_when_otu_assignment_changes.append(self)
    self.signal_when_otu_assignment_changes = value
    self.reset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.set_trace">
    <p>def <span class="ident">set_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the trace arrays for the variable in the Tracer object. </p>
<p>It will initialize a buffer the size of the checkpoint size in Tracer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.set_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.set_trace" class="source">
    <pre><code>def set_trace(self):
    '''Initialize the trace arrays for the variable in the Tracer object. 
    It will initialize a buffer the size of the checkpoint size in Tracer
    '''
    tracer = self.G.tracer
    tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)
    self.ckpt_iter = 0
    self.sample_iter = 0
    shape = (tracer.ckpt, ) + self._shape
    self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.set_values">
    <p>def <span class="ident">set_values</span>(</p><p>self, arr, use_indicators=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the values of the interactions from a vector.</p>
<p>If <code>use_indicators</code> is True, assumes that the values in the vector only contain
values for interactions where the indicator variable is positive and the
rest are skipped. If False, assumes the vector has values for where the
indicator variables are positive and negative (all).</p>
<h2>Paramters</h2>
<p>arr : np.ndarray(n, dtpye=float)
    These are the interaction values to set, in order
use_indicators : bool, Optional
    If True, we only set the interactions with a positive indicator. Else we set every
    single interaction</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.set_values', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.set_values" class="source">
    <pre><code>def set_values(self, arr, use_indicators=True):
    '''Sets the values of the interactions from a vector.
    If `use_indicators` is True, assumes that the values in the vector only contain
    values for interactions where the indicator variable is positive and the
    rest are skipped. If False, assumes the vector has values for where the
    indicator variables are positive and negative (all).
    Paramters
    ---------
    arr : np.ndarray(n, dtpye=float)
        These are the interaction values to set, in order
    use_indicators : bool, Optional
        If True, we only set the interactions with a positive indicator. Else we set every
        single interaction
    '''
    if not use_indicators:
        if len(arr) != self.size:
            raise ValueError('The number of elements in `arr` ({}) is not the ' \
                'same as the number of interactions ({})'.format(len(arr), self.size))
        for idx, interaction in enumerate(self):
            interaction.value = arr[idx]
    else:
        # Dont check because it is too computationally intensive
        idx = 0
        for interaction in self:
            if not interaction.indicator:
                continue
            interaction.value = arr[idx]
            idx += 1
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.contrib.Interactions.degree" class="name">var <span class="ident">degree</span></p>
            

            
  
    <div class="desc"><p>Get the degree of the node</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.dtype" class="name">var <span class="ident">dtype</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.indicator_initializer" class="name">var <span class="ident">indicator_initializer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.initialization_value" class="name">var <span class="ident">initialization_value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.metropolis" class="name">var <span class="ident">metropolis</span></p>
            

            
  
    <div class="desc"><p>Get the metropolis object</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.size" class="name">var <span class="ident">size</span></p>
            

            
  
    <div class="desc"><p>Return how many interactions there are possible according to the number of clusters.
THIS IS NOT HOW MANY POSITIVE INTERACTIONS THERE ARE - USE <code>num_pos_interactions</code></p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.use_indicators" class="name">var <span class="ident">use_indicators</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.contrib.Interactions.value_initializer" class="name">var <span class="ident">value_initializer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.contrib.Interactions.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.contrib.Interactions.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.contrib.Interactions.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
