<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pylab.multiprocessing API documentation</title>
    <meta name="description" content="pylab.multiprocessing

This module has classes for specialized types of multiprocessing that can 
dr..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.multiprocessing.isDASW">isDASW</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.isSADW">isSADW</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.ispersistentpool">ispersistentpool</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.ispersistentworker">ispersistentworker</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pylab.multiprocessing.DestroyedFromPickling">DestroyedFromPickling</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.multiprocessing.DestroyedFromPickling.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.multiprocessing.PersistentPool">PersistentPool</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.add_worker">add_worker</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.kill">kill</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.map">map</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.reset">reset</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.staged_map_get">staged_map_get</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.staged_map_put">staged_map_put</a></li>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentPool.staged_map_start">staged_map_start</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.multiprocessing.PersistentWorker">PersistentWorker</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.multiprocessing.PersistentWorker.persistent_run">persistent_run</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.multiprocessing.PoolTypeError">PoolTypeError</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.multiprocessing.SerializationError">SerializationError</a></span>
        
        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pylab.multiprocessing</span> module</h1>
  <p>pylab.multiprocessing</p>
<p>This module has classes for specialized types of multiprocessing that can 
dramatically decrease the run time if there large I/O costs for certain
types of problems. These classes are not better than the standard Python
<code>multiprocessing</code> package if the problem requires very little I/O overhead.</p>
<p>These classes are built off of the standard Python <code>multiprocessing</code> library
so it is portable to any system that can run Python.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing" class="source">
    <pre><code>'''pylab.multiprocessing

This module has classes for specialized types of multiprocessing that can 
dramatically decrease the run time if there large I/O costs for certain
types of problems. These classes are not better than the standard Python
`multiprocessing` package if the problem requires very little I/O overhead.

These classes are built off of the standard Python `multiprocessing` library
so it is portable to any system that can run Python.
'''
import sys
import multiprocessing
import copy
import logging
import os
import time

from .errors import NeedToImplementError
from .graph import isgraph
from . import util

def ispersistentworker(x):
    '''Checks whether the input is a subclass of PersistentWorker

    Parameters
    ----------
    x : any
        Input instance to check the type of PersistentWorker

    Returns
    -------
    bool
        True if `x` is of type PersistentWorker, else False
    '''
    return x is not None and issubclass(x.__class__, PersistentWorker)

def ispersistentpool(x):
    '''Checks whether the input is a subclass of PersistentPool

    Parameters
    ----------
    x : any
        Input instance to check the type of PersistentPool

    Returns
    -------
    bool
        True if `x` is of type PersistentPool, else False
    '''
    return x is not None and issubclass(x.__class__, PersistentPool)

def isDASW(x):
    '''Checks whether the PersistentPool is Different Argument
    Single Worker

    Parameters
    ----------
    x : any
        Input instance to check the type of
        If it is not a persistent pool type then it will return False

    Returns
    -------
    bool
    '''
    if not ispersistentpool(x):
        return False
    return x.ptype == 'dasw'

def isSADW(x):
    '''Checks whether the PersistentPool is Same Argument
    Different Worker

    Parameters
    ----------
    x : any
        Input instance to check the type of
        If it is not a persistent pool type then it will return False

    Returns
    -------
    bool
    '''
    if not ispersistentpool(x):
        return False
    return x.ptype == 'sadw'


class PersistentWorker:
    '''
    '''
    def persistent_run(self, **kwargs):
        raise NeedToImplementError('The static function `persistent_run` needs to be ' \
            'defined where one of the arguemnts is obj - which is the object')


class PersistentPool:
    '''Manages a set of PersistentWorker objects for a pooling.

    By persistent we mean that the worker processes are always active, i.e. they
    are not created after the `map` function is called nor are they destroyed when
    the pool ends - They wait until arguments are sent to them. 
    This also means they have to be explicitly killed at the end of the program with
    the `kill` function and have to be explicitly created before `map` is called.

    An instance that you would want to use pylab.multiprocessing.PersistentPool
    class instead of the regular multiprocessing.Pool class is when you have very
    large arguments (large matrix, dictionaries, etc.) that do not change over time
    or you only need to send them once to the workers. This way you are getting rid of
    unnecessary I/O. It also gets rid of the overhead of creating and destroying
    Processes every time you call `map`.

    To add a worker to the pool, it must be an object that inherits from the class
    `PersistentWorker`. When the `map` function is called by the pool 
    (`PersistentPool`), it calls the function defined by the `func` parameter of `map`.

    NOTE: There is *NO* guarenteed order of the return of the arguments because in either
    case we do not assume an order of the workers or the arguments. Make sure you
    can somehow determine which arguments belong where.

    There are two different types of parallelization that can be accomplished using this
    class, which are specified using the `ptype` 'sadw' and 'dasw', which are explained
    below.

    SADW (Same Arguments Different Worker)
    --------------------------------------
    This type of parallelization has different instantiations at each of the workers
    and all of the workers get the same arguments when `map` is called. An instance 
    you would use pooling like this is if you have 5 different large matrices with 
    different data and you want to do the same operations on them. Here you pass in 
    a single dictionary of arguments.

    DASW (Different Arguments Same Worker)
    --------------------------------------
    This type of parallelization has the same data at each of the workers and we 
    want to run many different arguments. This is analogous to the classical type
    mapping. An instance you want to use this is when you have a single operation that
    takes a long time and you want to run that will multiple arguments. Here you pass
    in a list of arguments.
    
    Staged map
    -------------
    This is an option ONLY for DASW type of mapping. This lets you send out arguments in 
    stages instead of all at once. This is useful if it takes a while to generate the
    arguments. This allows you to send out the arguments as you get them instead of 
    waiting until you have all of the arguments. There are three parts to this:
        `staggered_map_start`: Defines `func` that you are mapping over
        `staggered_map_put`: Send argument/s to the available processes
        `staggered_map_get`: Get all of the arguments when they are ready

    Passing in a graph
    ------------------
    There is an option to pass in a graph. This is useful if you are running
    your code in inference. All this does is sends a pointer to the 
    graph so that if something fails and there is an exception, the graph
    can call `kill` on all the variables that have persistent workers. THIS IS
    NOT A NECESSARY ARGUMENT TO RUN THE MULTIPROCESSING.
    
    Pickling
    --------
    During checkpointing, we are unable to serialize multiprocessed objects, so we
    do not include the attributes `tasks`, `results`, or `workers` when we pickle 
    object - thus we cannot load this object

    Parameters
    ----------
    ptype : str
        This defines the type of parallelization to do.
        Options: 
            'sadw': Same argument, different worker
            'dasw': Different argument, same worker
    G : pylab.graph.Graph, None
        Optional graph to pass in
    '''
    def __init__(self, ptype, G=None):
        if not util.isstr(ptype):
            raise TypeError('`ptype` ({}) must be a str'.format(type(ptype)))
        if ptype not in ['sadw', 'dasw']:
            raise ValueError('`ptype` ({}) not recognized'.format(ptype))

        self.ptype = ptype
        self.tasks = multiprocessing.JoinableQueue()
        self.results = multiprocessing.Queue()
        self.num_workers = 0
        self.busy = False
        self.workers = []
        self._staged_running = False

        if G is not None:
            if not isgraph(G):
                raise TypeError('`G` ({}) must be a graph'.format(type(G)))
            G._persistent_pntr.append(self)

    def reset(self):
        '''Kill everything if necessary - start as if new
        '''
        if type(self.tasks) == multiprocessing.JoinableQueue:
            self.kill()
        self.tasks = multiprocessing.JoinableQueue()
        self.results = multiprocessing.Queue()
        self.num_workers = 0
        self.busy = False
        self.workers = []

    def add_worker(self, obj):
        '''Add a persistent worker

        Parameter
        ---------
        args : dict
            These are the persistent arguments for the process
        '''
        try:
            if not ispersistentworker(obj):
                raise TypeError('`obj` ({}) must be a subtype of PersistentWorker'.format(
                    type(obj)))
            self.workers.append(_PersistentWorker(
                task_queue=self.tasks,
                result_queue=self.results,
                obj=copy.deepcopy(obj)))
            self.num_workers += 1
            self.workers[-1].start()
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def map(self, func, args):
        '''Maps the function `func` over the list of arguments `lst`

        Parameters
        ----------
        func : str
            This is the name of the function that is defined in the object
        args : list(dict), dict
            If SADW, it should be a dict
            If DASW, it should be a list of dicts

        Returns
        -------
        list(any)
            Returns a list of results from the function `func`
        '''
        if not util.isstr(func):
            self.kill()
            raise TypeError('`func` ({}) must be a str'.format(type(func)))

        if self.ptype == 'sadw':
            if not util.isdict(args):
                self.kill()
                raise TypeError('`args` ({}) must be a dict'.format(type(args)))
            return self._sadw_map(func=func, args=args)
        else:
            if self._staged_running:
                self.kill()
                raise PoolTypeError('staged_map is already running. You must call ' \
                    '`staged_map_get` before you call `map`.')
            if not util.isarray(args):
                self.kill()
                raise TypeError('`args` ({}) must be a list'.format(type(args)))
            for arg in args:
                if not util.isdict(arg):
                    self.kill()
                    raise TypeError('Each arg in `args` ({}) must be a dict'.format(type(arg)))
            return self._dasw_map(func=func, args=args)

    def _sadw_map(self, func, args):
        '''Same argument different workers map
        '''
        try:
            self.busy = True
            ret = []
            
            try:
                for _ in range(self.num_workers):
                    self.tasks.put((func, args))
                self.tasks.join()
                for _ in range(self.num_workers):
                    result = self.results.get()
                    ret.append(result)
                self.busy = False
                return ret
            except:
                self.kill()
                logging.critical('A child threw an error')
                logging.critical('Error: {}'.format(sys.exc_info()[0]))
                raise
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def _dasw_map(self, func, args):
        '''Different arguemnts same worker map
        '''
        try:
            self.busy = True
            ret = []
            
            try:
                for i in range(len(args)):
                    self.tasks.put((func, args[i]))
                self.tasks.join()
                for _ in range(len(args)):
                    result = self.results.get()
                    ret.append(result)
                self.busy = False
                return ret
            except:
                self.kill()
                logging.critical('A child threw an error')
                logging.critical('Error: {}'.format(sys.exc_info()[0]))
                raise
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def staged_map_start(self, func):
        '''Staged mapping for DASW mappings

        Parameters
        ----------
        func : str
            This is the function name we are calling over the arguments
        '''
        if self.ptype != 'dasw':
            self.kill()
            raise PoolTypeError('Pool type is `{}`, must be DASW'.format(self.ptype))
        if self._staged_running:
            self.kill()
            raise PoolTypeError('staggered_map is already running. You must call ' \
                '`staggered_map_get` before you call it again.')
        self.func = func
        self.n = 0
        self._staged_running = True

    def staged_map_put(self, args):
        '''Add arguemnts to the queue

        Parameters
        ----------
        args : list(dict), dict
            Argument/s to send
        '''
        if not self._staged_running:
            self.kill()
            raise PoolTypeError('You must call `staggered_map_start` before this function')
        if util.isdict(args):
            args = [args]
        if not util.isarray(args):
            self.kill()
            raise TypeError('`args` ({}) must be a list or dict'.format(type(args)))
        for arg in args:
            if not util.isdict(arg):
                self.kill()
                raise TypeError('Each arg in `args` ({}) must be a dict'.format(type(arg)))
        try:
            for arg in args:
                self.tasks.put((self.func, arg))
            self.n += len(args)
        except:
            self.kill()
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                logging.critical('A child threw an error')
                logging.critical('Error: {}'.format(sys.exc_info()[0]))
                raise

    def staged_map_get(self, timeout=None):
        '''Get the results of a staged mapping

        Returns
        -------
        list
        '''
        if not self._staged_running:
            self.kill()
            raise PoolTypeError('You must call `staggered_map_start` before this function')

        self.tasks.join()
        ret = []
        for i in range(self.n):
            ret.append(self.results.get())
        
        self.n = None
        self.func = None
        self._staged_running = False
        return ret

    def kill(self):
        '''Kill all of the workers
        '''
        try:
            for _ in range(self.num_workers):
                self.tasks.put(None)
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def __getstate__(self):
        '''Do not include the multiprocessed objects during serialization
        '''
        state = self.__dict__.copy()
        state.pop('tasks')
        state.pop('results')
        state.pop('workers')
        return state

    def __setstate__(self, state):
        '''Set the multiprocessed objects as destroyed from serialization
        '''
        self.__dict__.update(state)
        self.workers = DestroyedFromPickling
        self.results = DestroyedFromPickling
        self.tasks = DestroyedFromPickling
        self.reset()


class _PersistentWorker(multiprocessing.Process):
    '''Custom worker class for running a process with persistent args
    and process location.

    Parameters
    ----------
    task_queue : multiprocessing.JoinableQueue((int, callable, dict))
        These are the tasks to get with some extra information:
        int 
            This is the index to put the result in the result queue
        callable
            This is the function to call
        dict
            These are the kwargs for the function
    result_queue : multiprocessing.Queue
        These are where the results go (int, any)
    obj : PersistentWorker
        Object to keep here and call `persistent_run`
    '''
    def __init__(self, task_queue, result_queue, obj):
        multiprocessing.Process.__init__(self)
        self.task_queue = task_queue
        self.result_queue = result_queue
        self.obj = obj

    def run(self):
        '''Wait until there is a task for it to do. When there is,
        get it and put the result in the result_queue.
        '''
        while True:
            new_args = self.task_queue.get()
            if new_args is None:
                # Poison pill means shutdown
                logging.critical('{}: Exiting'.format(self.name))
                self.task_queue.task_done()
                break
            func, kwargs = new_args

            # Push the exception if one is thrown
            try:
                answer = getattr(self.obj, func)(**kwargs)
            except:
                self.task_queue.task_done()
                self.result_queue.put(None)
                logging.critical('Child {} ({}) failed on function `{}`'.format(
                    self.name, os.getpid(), func))
                raise

            self.task_queue.task_done()
            self.result_queue.put(answer)
        return


class DestroyedFromPickling:
    def __init__(self):
        self.value = 'Must reinitialize'


class SerializationError(Exception):
    pass


class PoolTypeError(Exception):
    pass
</code></pre>
  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.isDASW">
    <p>def <span class="ident">isDASW</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the PersistentPool is Different Argument
Single Worker</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of
    If it is not a persistent pool type then it will return False</p>
<h2>Returns</h2>
<p>bool</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.isDASW', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.isDASW" class="source">
    <pre><code>def isDASW(x):
    '''Checks whether the PersistentPool is Different Argument
    Single Worker

    Parameters
    ----------
    x : any
        Input instance to check the type of
        If it is not a persistent pool type then it will return False

    Returns
    -------
    bool
    '''
    if not ispersistentpool(x):
        return False
    return x.ptype == 'dasw'
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.isSADW">
    <p>def <span class="ident">isSADW</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the PersistentPool is Same Argument
Different Worker</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of
    If it is not a persistent pool type then it will return False</p>
<h2>Returns</h2>
<p>bool</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.isSADW', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.isSADW" class="source">
    <pre><code>def isSADW(x):
    '''Checks whether the PersistentPool is Same Argument
    Different Worker

    Parameters
    ----------
    x : any
        Input instance to check the type of
        If it is not a persistent pool type then it will return False

    Returns
    -------
    bool
    '''
    if not ispersistentpool(x):
        return False
    return x.ptype == 'sadw'
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.ispersistentpool">
    <p>def <span class="ident">ispersistentpool</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of PersistentPool</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of PersistentPool</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type PersistentPool, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.ispersistentpool', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.ispersistentpool" class="source">
    <pre><code>def ispersistentpool(x):
    '''Checks whether the input is a subclass of PersistentPool

    Parameters
    ----------
    x : any
        Input instance to check the type of PersistentPool

    Returns
    -------
    bool
        True if `x` is of type PersistentPool, else False
    '''
    return x is not None and issubclass(x.__class__, PersistentPool)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.ispersistentworker">
    <p>def <span class="ident">ispersistentworker</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of PersistentWorker</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of PersistentWorker</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type PersistentWorker, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.ispersistentworker', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.ispersistentworker" class="source">
    <pre><code>def ispersistentworker(x):
    '''Checks whether the input is a subclass of PersistentWorker

    Parameters
    ----------
    x : any
        Input instance to check the type of PersistentWorker

    Returns
    -------
    bool
        True if `x` is of type PersistentWorker, else False
    '''
    return x is not None and issubclass(x.__class__, PersistentWorker)
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pylab.multiprocessing.DestroyedFromPickling" class="name">class <span class="ident">DestroyedFromPickling</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.DestroyedFromPickling', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.DestroyedFromPickling" class="source">
    <pre><code>class DestroyedFromPickling:
    def __init__(self):
        self.value = 'Must reinitialize'
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.multiprocessing.DestroyedFromPickling">DestroyedFromPickling</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.DestroyedFromPickling.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.DestroyedFromPickling.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.DestroyedFromPickling.__init__" class="source">
    <pre><code>def __init__(self):
    self.value = 'Must reinitialize'
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.multiprocessing.DestroyedFromPickling.value" class="name">var <span class="ident">value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.multiprocessing.PersistentPool" class="name">class <span class="ident">PersistentPool</span></p>
      
  
    <div class="desc"><p>Manages a set of PersistentWorker objects for a pooling.</p>
<p>By persistent we mean that the worker processes are always active, i.e. they
are not created after the <code>map</code> function is called nor are they destroyed when
the pool ends - They wait until arguments are sent to them. 
This also means they have to be explicitly killed at the end of the program with
the <code>kill</code> function and have to be explicitly created before <code>map</code> is called.</p>
<p>An instance that you would want to use pylab.multiprocessing.PersistentPool
class instead of the regular multiprocessing.Pool class is when you have very
large arguments (large matrix, dictionaries, etc.) that do not change over time
or you only need to send them once to the workers. This way you are getting rid of
unnecessary I/O. It also gets rid of the overhead of creating and destroying
Processes every time you call <code>map</code>.</p>
<p>To add a worker to the pool, it must be an object that inherits from the class
<code>PersistentWorker</code>. When the <code>map</code> function is called by the pool 
(<code>PersistentPool</code>), it calls the function defined by the <code>func</code> parameter of <code>map</code>.</p>
<p>NOTE: There is <em>NO</em> guarenteed order of the return of the arguments because in either
case we do not assume an order of the workers or the arguments. Make sure you
can somehow determine which arguments belong where.</p>
<p>There are two different types of parallelization that can be accomplished using this
class, which are specified using the <code>ptype</code> 'sadw' and 'dasw', which are explained
below.</p>
<h2>SADW (Same Arguments Different Worker)</h2>
<p>This type of parallelization has different instantiations at each of the workers
and all of the workers get the same arguments when <code>map</code> is called. An instance 
you would use pooling like this is if you have 5 different large matrices with 
different data and you want to do the same operations on them. Here you pass in 
a single dictionary of arguments.</p>
<h2>DASW (Different Arguments Same Worker)</h2>
<p>This type of parallelization has the same data at each of the workers and we 
want to run many different arguments. This is analogous to the classical type
mapping. An instance you want to use this is when you have a single operation that
takes a long time and you want to run that will multiple arguments. Here you pass
in a list of arguments.</p>
<h2>Staged map</h2>
<p>This is an option ONLY for DASW type of mapping. This lets you send out arguments in 
stages instead of all at once. This is useful if it takes a while to generate the
arguments. This allows you to send out the arguments as you get them instead of 
waiting until you have all of the arguments. There are three parts to this:
    <code>staggered_map_start</code>: Defines <code>func</code> that you are mapping over
    <code>staggered_map_put</code>: Send argument/s to the available processes
    <code>staggered_map_get</code>: Get all of the arguments when they are ready</p>
<h2>Passing in a graph</h2>
<p>There is an option to pass in a graph. This is useful if you are running
your code in inference. All this does is sends a pointer to the 
graph so that if something fails and there is an exception, the graph
can call <code>kill</code> on all the variables that have persistent workers. THIS IS
NOT A NECESSARY ARGUMENT TO RUN THE MULTIPROCESSING.</p>
<h2>Pickling</h2>
<p>During checkpointing, we are unable to serialize multiprocessed objects, so we
do not include the attributes <code>tasks</code>, <code>results</code>, or <code>workers</code> when we pickle 
object - thus we cannot load this object</p>
<h2>Parameters</h2>
<p>ptype : str
    This defines the type of parallelization to do.
    Options: 
        'sadw': Same argument, different worker
        'dasw': Different argument, same worker
G : pylab.graph.Graph, None
    Optional graph to pass in</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool" class="source">
    <pre><code>class PersistentPool:
    '''Manages a set of PersistentWorker objects for a pooling.

    By persistent we mean that the worker processes are always active, i.e. they
    are not created after the `map` function is called nor are they destroyed when
    the pool ends - They wait until arguments are sent to them. 
    This also means they have to be explicitly killed at the end of the program with
    the `kill` function and have to be explicitly created before `map` is called.

    An instance that you would want to use pylab.multiprocessing.PersistentPool
    class instead of the regular multiprocessing.Pool class is when you have very
    large arguments (large matrix, dictionaries, etc.) that do not change over time
    or you only need to send them once to the workers. This way you are getting rid of
    unnecessary I/O. It also gets rid of the overhead of creating and destroying
    Processes every time you call `map`.

    To add a worker to the pool, it must be an object that inherits from the class
    `PersistentWorker`. When the `map` function is called by the pool 
    (`PersistentPool`), it calls the function defined by the `func` parameter of `map`.

    NOTE: There is *NO* guarenteed order of the return of the arguments because in either
    case we do not assume an order of the workers or the arguments. Make sure you
    can somehow determine which arguments belong where.

    There are two different types of parallelization that can be accomplished using this
    class, which are specified using the `ptype` 'sadw' and 'dasw', which are explained
    below.

    SADW (Same Arguments Different Worker)
    --------------------------------------
    This type of parallelization has different instantiations at each of the workers
    and all of the workers get the same arguments when `map` is called. An instance 
    you would use pooling like this is if you have 5 different large matrices with 
    different data and you want to do the same operations on them. Here you pass in 
    a single dictionary of arguments.

    DASW (Different Arguments Same Worker)
    --------------------------------------
    This type of parallelization has the same data at each of the workers and we 
    want to run many different arguments. This is analogous to the classical type
    mapping. An instance you want to use this is when you have a single operation that
    takes a long time and you want to run that will multiple arguments. Here you pass
    in a list of arguments.
    
    Staged map
    -------------
    This is an option ONLY for DASW type of mapping. This lets you send out arguments in 
    stages instead of all at once. This is useful if it takes a while to generate the
    arguments. This allows you to send out the arguments as you get them instead of 
    waiting until you have all of the arguments. There are three parts to this:
        `staggered_map_start`: Defines `func` that you are mapping over
        `staggered_map_put`: Send argument/s to the available processes
        `staggered_map_get`: Get all of the arguments when they are ready

    Passing in a graph
    ------------------
    There is an option to pass in a graph. This is useful if you are running
    your code in inference. All this does is sends a pointer to the 
    graph so that if something fails and there is an exception, the graph
    can call `kill` on all the variables that have persistent workers. THIS IS
    NOT A NECESSARY ARGUMENT TO RUN THE MULTIPROCESSING.
    
    Pickling
    --------
    During checkpointing, we are unable to serialize multiprocessed objects, so we
    do not include the attributes `tasks`, `results`, or `workers` when we pickle 
    object - thus we cannot load this object

    Parameters
    ----------
    ptype : str
        This defines the type of parallelization to do.
        Options: 
            'sadw': Same argument, different worker
            'dasw': Different argument, same worker
    G : pylab.graph.Graph, None
        Optional graph to pass in
    '''
    def __init__(self, ptype, G=None):
        if not util.isstr(ptype):
            raise TypeError('`ptype` ({}) must be a str'.format(type(ptype)))
        if ptype not in ['sadw', 'dasw']:
            raise ValueError('`ptype` ({}) not recognized'.format(ptype))

        self.ptype = ptype
        self.tasks = multiprocessing.JoinableQueue()
        self.results = multiprocessing.Queue()
        self.num_workers = 0
        self.busy = False
        self.workers = []
        self._staged_running = False

        if G is not None:
            if not isgraph(G):
                raise TypeError('`G` ({}) must be a graph'.format(type(G)))
            G._persistent_pntr.append(self)

    def reset(self):
        '''Kill everything if necessary - start as if new
        '''
        if type(self.tasks) == multiprocessing.JoinableQueue:
            self.kill()
        self.tasks = multiprocessing.JoinableQueue()
        self.results = multiprocessing.Queue()
        self.num_workers = 0
        self.busy = False
        self.workers = []

    def add_worker(self, obj):
        '''Add a persistent worker

        Parameter
        ---------
        args : dict
            These are the persistent arguments for the process
        '''
        try:
            if not ispersistentworker(obj):
                raise TypeError('`obj` ({}) must be a subtype of PersistentWorker'.format(
                    type(obj)))
            self.workers.append(_PersistentWorker(
                task_queue=self.tasks,
                result_queue=self.results,
                obj=copy.deepcopy(obj)))
            self.num_workers += 1
            self.workers[-1].start()
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def map(self, func, args):
        '''Maps the function `func` over the list of arguments `lst`

        Parameters
        ----------
        func : str
            This is the name of the function that is defined in the object
        args : list(dict), dict
            If SADW, it should be a dict
            If DASW, it should be a list of dicts

        Returns
        -------
        list(any)
            Returns a list of results from the function `func`
        '''
        if not util.isstr(func):
            self.kill()
            raise TypeError('`func` ({}) must be a str'.format(type(func)))

        if self.ptype == 'sadw':
            if not util.isdict(args):
                self.kill()
                raise TypeError('`args` ({}) must be a dict'.format(type(args)))
            return self._sadw_map(func=func, args=args)
        else:
            if self._staged_running:
                self.kill()
                raise PoolTypeError('staged_map is already running. You must call ' \
                    '`staged_map_get` before you call `map`.')
            if not util.isarray(args):
                self.kill()
                raise TypeError('`args` ({}) must be a list'.format(type(args)))
            for arg in args:
                if not util.isdict(arg):
                    self.kill()
                    raise TypeError('Each arg in `args` ({}) must be a dict'.format(type(arg)))
            return self._dasw_map(func=func, args=args)

    def _sadw_map(self, func, args):
        '''Same argument different workers map
        '''
        try:
            self.busy = True
            ret = []
            
            try:
                for _ in range(self.num_workers):
                    self.tasks.put((func, args))
                self.tasks.join()
                for _ in range(self.num_workers):
                    result = self.results.get()
                    ret.append(result)
                self.busy = False
                return ret
            except:
                self.kill()
                logging.critical('A child threw an error')
                logging.critical('Error: {}'.format(sys.exc_info()[0]))
                raise
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def _dasw_map(self, func, args):
        '''Different arguemnts same worker map
        '''
        try:
            self.busy = True
            ret = []
            
            try:
                for i in range(len(args)):
                    self.tasks.put((func, args[i]))
                self.tasks.join()
                for _ in range(len(args)):
                    result = self.results.get()
                    ret.append(result)
                self.busy = False
                return ret
            except:
                self.kill()
                logging.critical('A child threw an error')
                logging.critical('Error: {}'.format(sys.exc_info()[0]))
                raise
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def staged_map_start(self, func):
        '''Staged mapping for DASW mappings

        Parameters
        ----------
        func : str
            This is the function name we are calling over the arguments
        '''
        if self.ptype != 'dasw':
            self.kill()
            raise PoolTypeError('Pool type is `{}`, must be DASW'.format(self.ptype))
        if self._staged_running:
            self.kill()
            raise PoolTypeError('staggered_map is already running. You must call ' \
                '`staggered_map_get` before you call it again.')
        self.func = func
        self.n = 0
        self._staged_running = True

    def staged_map_put(self, args):
        '''Add arguemnts to the queue

        Parameters
        ----------
        args : list(dict), dict
            Argument/s to send
        '''
        if not self._staged_running:
            self.kill()
            raise PoolTypeError('You must call `staggered_map_start` before this function')
        if util.isdict(args):
            args = [args]
        if not util.isarray(args):
            self.kill()
            raise TypeError('`args` ({}) must be a list or dict'.format(type(args)))
        for arg in args:
            if not util.isdict(arg):
                self.kill()
                raise TypeError('Each arg in `args` ({}) must be a dict'.format(type(arg)))
        try:
            for arg in args:
                self.tasks.put((self.func, arg))
            self.n += len(args)
        except:
            self.kill()
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                logging.critical('A child threw an error')
                logging.critical('Error: {}'.format(sys.exc_info()[0]))
                raise

    def staged_map_get(self, timeout=None):
        '''Get the results of a staged mapping

        Returns
        -------
        list
        '''
        if not self._staged_running:
            self.kill()
            raise PoolTypeError('You must call `staggered_map_start` before this function')

        self.tasks.join()
        ret = []
        for i in range(self.n):
            ret.append(self.results.get())
        
        self.n = None
        self.func = None
        self._staged_running = False
        return ret

    def kill(self):
        '''Kill all of the workers
        '''
        try:
            for _ in range(self.num_workers):
                self.tasks.put(None)
        except:
            if type(self.tasks) == DestroyedFromPickling:
                raise SerializationError('You cannot load this object from a pickle' \
                    ' because `tasks`, `results`, and `workers` are nonserializable.' \
                    ' You must reinitialize it')
            else:
                raise

    def __getstate__(self):
        '''Do not include the multiprocessed objects during serialization
        '''
        state = self.__dict__.copy()
        state.pop('tasks')
        state.pop('results')
        state.pop('workers')
        return state

    def __setstate__(self, state):
        '''Set the multiprocessed objects as destroyed from serialization
        '''
        self.__dict__.update(state)
        self.workers = DestroyedFromPickling
        self.results = DestroyedFromPickling
        self.tasks = DestroyedFromPickling
        self.reset()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.multiprocessing.PersistentPool">PersistentPool</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, ptype, G=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.__init__" class="source">
    <pre><code>def __init__(self, ptype, G=None):
    if not util.isstr(ptype):
        raise TypeError('`ptype` ({}) must be a str'.format(type(ptype)))
    if ptype not in ['sadw', 'dasw']:
        raise ValueError('`ptype` ({}) not recognized'.format(ptype))
    self.ptype = ptype
    self.tasks = multiprocessing.JoinableQueue()
    self.results = multiprocessing.Queue()
    self.num_workers = 0
    self.busy = False
    self.workers = []
    self._staged_running = False
    if G is not None:
        if not isgraph(G):
            raise TypeError('`G` ({}) must be a graph'.format(type(G)))
        G._persistent_pntr.append(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.add_worker">
    <p>def <span class="ident">add_worker</span>(</p><p>self, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a persistent worker</p>
<h2>Parameter</h2>
<p>args : dict
    These are the persistent arguments for the process</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.add_worker', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.add_worker" class="source">
    <pre><code>def add_worker(self, obj):
    '''Add a persistent worker
    Parameter
    ---------
    args : dict
        These are the persistent arguments for the process
    '''
    try:
        if not ispersistentworker(obj):
            raise TypeError('`obj` ({}) must be a subtype of PersistentWorker'.format(
                type(obj)))
        self.workers.append(_PersistentWorker(
            task_queue=self.tasks,
            result_queue=self.results,
            obj=copy.deepcopy(obj)))
        self.num_workers += 1
        self.workers[-1].start()
    except:
        if type(self.tasks) == DestroyedFromPickling:
            raise SerializationError('You cannot load this object from a pickle' \
                ' because `tasks`, `results`, and `workers` are nonserializable.' \
                ' You must reinitialize it')
        else:
            raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.kill">
    <p>def <span class="ident">kill</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Kill all of the workers</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.kill', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.kill" class="source">
    <pre><code>def kill(self):
    '''Kill all of the workers
    '''
    try:
        for _ in range(self.num_workers):
            self.tasks.put(None)
    except:
        if type(self.tasks) == DestroyedFromPickling:
            raise SerializationError('You cannot load this object from a pickle' \
                ' because `tasks`, `results`, and `workers` are nonserializable.' \
                ' You must reinitialize it')
        else:
            raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.map">
    <p>def <span class="ident">map</span>(</p><p>self, func, args)</p>
    </div>
    

    
  
    <div class="desc"><p>Maps the function <code>func</code> over the list of arguments <code>lst</code></p>
<h2>Parameters</h2>
<p>func : str
    This is the name of the function that is defined in the object
args : list(dict), dict
    If SADW, it should be a dict
    If DASW, it should be a list of dicts</p>
<h2>Returns</h2>
<p>list(any)
    Returns a list of results from the function <code>func</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.map', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.map" class="source">
    <pre><code>def map(self, func, args):
    '''Maps the function `func` over the list of arguments `lst`
    Parameters
    ----------
    func : str
        This is the name of the function that is defined in the object
    args : list(dict), dict
        If SADW, it should be a dict
        If DASW, it should be a list of dicts
    Returns
    -------
    list(any)
        Returns a list of results from the function `func`
    '''
    if not util.isstr(func):
        self.kill()
        raise TypeError('`func` ({}) must be a str'.format(type(func)))
    if self.ptype == 'sadw':
        if not util.isdict(args):
            self.kill()
            raise TypeError('`args` ({}) must be a dict'.format(type(args)))
        return self._sadw_map(func=func, args=args)
    else:
        if self._staged_running:
            self.kill()
            raise PoolTypeError('staged_map is already running. You must call ' \
                '`staged_map_get` before you call `map`.')
        if not util.isarray(args):
            self.kill()
            raise TypeError('`args` ({}) must be a list'.format(type(args)))
        for arg in args:
            if not util.isdict(arg):
                self.kill()
                raise TypeError('Each arg in `args` ({}) must be a dict'.format(type(arg)))
        return self._dasw_map(func=func, args=args)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.reset">
    <p>def <span class="ident">reset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Kill everything if necessary - start as if new</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.reset', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.reset" class="source">
    <pre><code>def reset(self):
    '''Kill everything if necessary - start as if new
    '''
    if type(self.tasks) == multiprocessing.JoinableQueue:
        self.kill()
    self.tasks = multiprocessing.JoinableQueue()
    self.results = multiprocessing.Queue()
    self.num_workers = 0
    self.busy = False
    self.workers = []
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.staged_map_get">
    <p>def <span class="ident">staged_map_get</span>(</p><p>self, timeout=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the results of a staged mapping</p>
<h2>Returns</h2>
<p>list</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.staged_map_get', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.staged_map_get" class="source">
    <pre><code>def staged_map_get(self, timeout=None):
    '''Get the results of a staged mapping
    Returns
    -------
    list
    '''
    if not self._staged_running:
        self.kill()
        raise PoolTypeError('You must call `staggered_map_start` before this function')
    self.tasks.join()
    ret = []
    for i in range(self.n):
        ret.append(self.results.get())
    
    self.n = None
    self.func = None
    self._staged_running = False
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.staged_map_put">
    <p>def <span class="ident">staged_map_put</span>(</p><p>self, args)</p>
    </div>
    

    
  
    <div class="desc"><p>Add arguemnts to the queue</p>
<h2>Parameters</h2>
<p>args : list(dict), dict
    Argument/s to send</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.staged_map_put', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.staged_map_put" class="source">
    <pre><code>def staged_map_put(self, args):
    '''Add arguemnts to the queue
    Parameters
    ----------
    args : list(dict), dict
        Argument/s to send
    '''
    if not self._staged_running:
        self.kill()
        raise PoolTypeError('You must call `staggered_map_start` before this function')
    if util.isdict(args):
        args = [args]
    if not util.isarray(args):
        self.kill()
        raise TypeError('`args` ({}) must be a list or dict'.format(type(args)))
    for arg in args:
        if not util.isdict(arg):
            self.kill()
            raise TypeError('Each arg in `args` ({}) must be a dict'.format(type(arg)))
    try:
        for arg in args:
            self.tasks.put((self.func, arg))
        self.n += len(args)
    except:
        self.kill()
        if type(self.tasks) == DestroyedFromPickling:
            raise SerializationError('You cannot load this object from a pickle' \
                ' because `tasks`, `results`, and `workers` are nonserializable.' \
                ' You must reinitialize it')
        else:
            logging.critical('A child threw an error')
            logging.critical('Error: {}'.format(sys.exc_info()[0]))
            raise
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentPool.staged_map_start">
    <p>def <span class="ident">staged_map_start</span>(</p><p>self, func)</p>
    </div>
    

    
  
    <div class="desc"><p>Staged mapping for DASW mappings</p>
<h2>Parameters</h2>
<p>func : str
    This is the function name we are calling over the arguments</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentPool.staged_map_start', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentPool.staged_map_start" class="source">
    <pre><code>def staged_map_start(self, func):
    '''Staged mapping for DASW mappings
    Parameters
    ----------
    func : str
        This is the function name we are calling over the arguments
    '''
    if self.ptype != 'dasw':
        self.kill()
        raise PoolTypeError('Pool type is `{}`, must be DASW'.format(self.ptype))
    if self._staged_running:
        self.kill()
        raise PoolTypeError('staggered_map is already running. You must call ' \
            '`staggered_map_get` before you call it again.')
    self.func = func
    self.n = 0
    self._staged_running = True
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.multiprocessing.PersistentPool.busy" class="name">var <span class="ident">busy</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.multiprocessing.PersistentPool.num_workers" class="name">var <span class="ident">num_workers</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.multiprocessing.PersistentPool.ptype" class="name">var <span class="ident">ptype</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.multiprocessing.PersistentPool.results" class="name">var <span class="ident">results</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.multiprocessing.PersistentPool.tasks" class="name">var <span class="ident">tasks</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.multiprocessing.PersistentPool.workers" class="name">var <span class="ident">workers</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.multiprocessing.PersistentWorker" class="name">class <span class="ident">PersistentWorker</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentWorker', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentWorker" class="source">
    <pre><code>class PersistentWorker:
    '''
    '''
    def persistent_run(self, **kwargs):
        raise NeedToImplementError('The static function `persistent_run` needs to be ' \
            'defined where one of the arguemnts is obj - which is the object')
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.multiprocessing.PersistentWorker">PersistentWorker</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.multiprocessing.PersistentWorker.persistent_run">
    <p>def <span class="ident">persistent_run</span>(</p><p>self, **kwargs)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PersistentWorker.persistent_run', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PersistentWorker.persistent_run" class="source">
    <pre><code>def persistent_run(self, **kwargs):
    raise NeedToImplementError('The static function `persistent_run` needs to be ' \
        'defined where one of the arguemnts is obj - which is the object')
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.multiprocessing.PoolTypeError" class="name">class <span class="ident">PoolTypeError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.PoolTypeError', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.PoolTypeError" class="source">
    <pre><code>class PoolTypeError(Exception):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.multiprocessing.PoolTypeError">PoolTypeError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pylab.multiprocessing.PoolTypeError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.multiprocessing.SerializationError" class="name">class <span class="ident">SerializationError</span></p>
      
  
    <div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.multiprocessing.SerializationError', this);">Show source &equiv;</a></p>
  <div id="source-pylab.multiprocessing.SerializationError" class="source">
    <pre><code>class SerializationError(Exception):
    pass
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.multiprocessing.SerializationError">SerializationError</a></li>
          <li>builtins.Exception</li>
          <li>builtins.BaseException</li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="pylab.multiprocessing.SerializationError.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
