<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pylab.visualization API documentation</title>
    <meta name="description" content="Visualization funtions for pylab

Heatmap Rendering
-----------------
These functions render heatmap..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_ACCEPTANCE_RATE_PREV">DEFAULT_ACCEPTANCE_RATE_PREV</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_INCLUDE_COLORBAR">DEFAULT_INCLUDE_COLORBAR</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_INCLUDE_TICK_MARKS">DEFAULT_INCLUDE_TICK_MARKS</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_LINECOLOR">DEFAULT_LINECOLOR</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_LINEWIDTHS">DEFAULT_LINEWIDTHS</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_MAX_BAYES_FACTOR">DEFAULT_MAX_BAYES_FACTOR</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_N_COLORS">DEFAULT_N_COLORS</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_PLT_TYPE">DEFAULT_PLT_TYPE</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_SNS_CMAP">DEFAULT_SNS_CMAP</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_TAX_LEVEL">DEFAULT_TAX_LEVEL</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_TRACE_COLOR">DEFAULT_TRACE_COLOR</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_XTICKLABELS">DEFAULT_XTICKLABELS</a></li>
    <li class="mono"><a href="#pylab.visualization.DEFAULT_YTICKLABELS">DEFAULT_YTICKLABELS</a></li>
    <li class="mono"><a href="#pylab.visualization.PERTURBATION_COLOR">PERTURBATION_COLOR</a></li>
    <li class="mono"><a href="#pylab.visualization.PLT_TITLE_LABEL">PLT_TITLE_LABEL</a></li>
    <li class="mono"><a href="#pylab.visualization.PLT_XLABEL_LABEL">PLT_XLABEL_LABEL</a></li>
    <li class="mono"><a href="#pylab.visualization.PLT_YLABEL_LABEL">PLT_YLABEL_LABEL</a></li>
    <li class="mono"><a href="#pylab.visualization.XTICK_FREQUENCY">XTICK_FREQUENCY</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.visualization.abundance_over_time">abundance_over_time</a></li>
    <li class="mono"><a href="#pylab.visualization.alpha_diversity_over_time">alpha_diversity_over_time</a></li>
    <li class="mono"><a href="#pylab.visualization.render_acceptance_rate_trace">render_acceptance_rate_trace</a></li>
    <li class="mono"><a href="#pylab.visualization.render_bayes_factors">render_bayes_factors</a></li>
    <li class="mono"><a href="#pylab.visualization.render_cocluster_proportions">render_cocluster_proportions</a></li>
    <li class="mono"><a href="#pylab.visualization.render_growth_vector">render_growth_vector</a></li>
    <li class="mono"><a href="#pylab.visualization.render_interaction_strength">render_interaction_strength</a></li>
    <li class="mono"><a href="#pylab.visualization.render_trace">render_trace</a></li>
    <li class="mono"><a href="#pylab.visualization.set_default_tax_level">set_default_tax_level</a></li>
    <li class="mono"><a href="#pylab.visualization.set_default_trace_color">set_default_trace_color</a></li>
    <li class="mono"><a href="#pylab.visualization.set_perturbation_color">set_perturbation_color</a></li>
    <li class="mono"><a href="#pylab.visualization.set_xtick_frequency">set_xtick_frequency</a></li>
    <li class="mono"><a href="#pylab.visualization.shade_in_perturbations">shade_in_perturbations</a></li>
    <li class="mono"><a href="#pylab.visualization.taxonomic_distribution_over_time">taxonomic_distribution_over_time</a></li>
  </ul>

    </li>


    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pylab.visualization</span> module</h1>
  <p>Visualization funtions for pylab</p>
<h2>Heatmap Rendering</h2>
<p>These functions render heatmaps of matrix data:
    - render_bayes_factors
    - render_cocluster_proportions
    - render_interaction_strength
    - render_growth_vector</p>
<h2>Abundance functions</h2>
<p>These functions either plot the abundance of the data or a metric of them:
    - alpha_diversity_over_time
    - qpcr_over_time
    - abundance_over_time
    - taxonomic_distribution_over_time</p>
<h2>Tracing functions</h2>
<p>These functions plot how the value of a variable changes over inference:
    - render_acceptance_rate_trace
    - render_trace</p>
<p>Linewidths are automatically shutoff if the number of OTUs is greater than 75</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization" class="source">
    <pre><code>'''Visualization funtions for pylab

Heatmap Rendering
-----------------
These functions render heatmaps of matrix data:
    - render_bayes_factors
    - render_cocluster_proportions
    - render_interaction_strength
    - render_growth_vector

Abundance functions
-------------------
These functions either plot the abundance of the data or a metric of them:
    - alpha_diversity_over_time
    - qpcr_over_time
    - abundance_over_time
    - taxonomic_distribution_over_time

Tracing functions
-----------------
These functions plot how the value of a variable changes over inference:
    - render_acceptance_rate_trace
    - render_trace

Linewidths are automatically shutoff if the number of OTUs is greater than 75
'''
import numpy as np
import logging
import math
import warnings
import re
import pandas
import sys

import matplotlib.pyplot as plt
import matplotlib as mpl
import seaborn as sns
from matplotlib.pyplot import arrow
import matplotlib.ticker as plticker

from .base import isotuset, issubjectset, issubject
from .cluster import isclustering
from .variables import Variable as pylabVariable
from .variables import isVariable
from . import util
from .metropolis import isMetropKernel, acceptance_rate
from .graph import hasprior

warnings.filterwarnings('ignore')
_plt_labels = ['title', 'xlabel', 'ylabel']

# Constants
DEFAULT_TAX_LEVEL = None
PERTURBATION_COLOR = 'orange'
XTICK_FREQUENCY = 5 # in days
DEFAULT_SNS_CMAP = 'deep'

DEFAULT_MAX_BAYES_FACTOR = 15
DEFAULT_LINEWIDTHS = 0.8
DEFAULT_LINECOLOR = 'black'
DEFAULT_N_COLORS = 100
DEFAULT_XTICKLABELS = util.INDEX_FORMATTER
DEFAULT_YTICKLABELS = '{} {}'.format(
        util.NAME_FORMATTER, util.INDEX_FORMATTER)
DEFAULT_INCLUDE_COLORBAR = True
DEFAULT_INCLUDE_TICK_MARKS = False
DEFAULT_ACCEPTANCE_RATE_PREV = 50
DEFAULT_PLT_TYPE = 'both'
DEFAULT_TRACE_COLOR = 'steelblue'
PLT_TITLE_LABEL = 'title'
PLT_XLABEL_LABEL = 'xlabel'
PLT_YLABEL_LABEL = 'ylabel'

# ----------------
# Global Functions
# ----------------
def set_default_tax_level(level):
    '''This sets the default taxa level to plot at.
    
    Parameters
    ----------
    level : str
        This is the level to set it at. It must be either:
            'kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'OTU'
    '''
    global DEFAULT_TAX_LEVEL
    if not util.isstr(level):
        raise ValueError('`level` ({}) must be a str'.format(type(level)))
    if level not in ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'otu']:
        raise ValueError('`level` ({}) not valid'.format(level))
    DEFAULT_TAX_LEVEL = level

def set_perturbation_color(color):
    '''Set the color for the perturbation shading. Must be matplotlib compatible.

    Parameters
    ----------
    color : any
        This is the color to set it to.

    See Also
    --------
    https://matplotlib.org/2.0.2/api/colors_api.html
    '''
    global PERTURBATION_COLOR
    PERTURBATION_COLOR = color

def set_xtick_frequency(x):
    '''Sets the xtick frequency (how often a label on the x axis should occur)

    Parameters
    ----------
    x : numeric
        How often it should occur (in days)
    '''
    global XTICK_FREQUENCY
    if not util.isnumeric(x):
        raise ValueError('x ({}) must be a numeric'.format(type(x)))
    if x <= 0:
        raise ValueError('x ({}) must be >= 0'.format(x))
    XTICK_FREQUENCY = x

def set_default_trace_color(color):
    '''Sets defalt color of the trace. Must be matplotlib compatible.

    Parameters
    ----------
    color : any
        This is the color to set it to.

    See Also
    --------
    https://matplotlib.org/2.0.2/api/colors_api.html
    '''
    global DEFAULT_TRACE_COLOR
    DEFAULT_TRACE_COLOR = color

def shade_in_perturbations(ax, perturbations, textcolor='black', textsize=None):
    '''Shade in the axis where there are perturbations and adds the label of
    the perturbation above it.

    Parameters
    ----------
    ax : matplotlib.pyplot.Axes
        Axis we are plotting on
    subjset : pylab.base.SubjectSet
        Subject set to plot on

    Returns
    -------
    matplotlib.pyplot.Axes
    '''
    if perturbations is None:
        return ax

    pert_locs = []
    pert_names = []
    for pidx, perturbation in enumerate(perturbations):
        ax.axvspan(
            xmin=perturbation.start,
            xmax=perturbation.end, 
            facecolor=PERTURBATION_COLOR, 
            alpha=0.25)
        pert_locs.append((perturbation.end + perturbation.start) / 2)
        name = perturbation.name
        if name is None:
            name = 'pert{}'.format(pidx)
        pert_names.append(name)

    # Set the names on the top x-axis
    ax2 = ax.twiny()
    ax2.set_xlim(ax.get_xlim())
    ax2.set_xticks(pert_locs)
    ax2.set_xticklabels(pert_names)
    ax2.tick_params('x', which='both', length=0, colors=textcolor, 
        labelsize=textsize)

    return ax

# --------
# Heatmaps
# --------
def render_bayes_factors(bayes_factors, otus, clustering=None, ax=None,
    n_colors=None, max_value=None, xticklabels=None, yticklabels=None,
    include_tick_marks=None, linewidths=None, linecolor=None,cmap=None,
    include_colorbar=None, title='Microbe Interaction Bayes Factors', figure_size=None,
    order=None):
    '''Renders the bayes factors for each of the interactions. Self interactions
    are automatically set to np.nan.

    Parameters
    ----------
    bayes_factors : 2-dim np.ndarray
        - Square matrix indicating the bayes factors of the interaction
    otus (pylab.data.OTUSet)
        - This is the object that contains all of the OTU metadata
    clustering : pylab.cluster.ClusteringBase, Optional
        - Clustering object if you want the OTUs in the same cluster to be grouped
          together
    ax : matplotlib.pyplot.Axes, Optional
        - The axes to plot on. If nothing is provided a new figure will be created
    n_colors : int, Optional
        - The number of colors to generate for the colormap.
    max_value : float, int, Optional
        - Clips all of the values above this limit
        - If None, then there is no clipping
    xticklabels, yticklabels : str, list, None, Optional
        - These are the labels for the x and y axis, respectively.
        - If it is a list then it must have `otus.n_otus` elements.
        - If it is a string, it is the formatter for each of the rows/columns.
        - If it is None, then do not make any ticklabels
    include_tick_marks : bool, Optional
        - If True, include tick marks. If False get rid of them
    linewidths : float, Optional
        - The width of the lines separating the squares
    linecolor : str, Optional
        - The color of the lines separating the squares
    cmap : colormap object, Optional
        - Overrides the default colormap. If specified, we ignore `n_colors`
    include_colorbar : bool, Optional
        - If True, it will render the colorbar, if not then it wont.
    title : str, None, Optional
        - Title of the figure
        - If None then do not put any title
    figure_size : 2-tuple, Optional
        - This is the size of the figure (in inches)
        - If nothing is specified it will default to adding 10 inches in each
          dimension for every 50 OTUs
    
    Returns
    -------
    matplotlib.pyplot.Axes
        Axes object that has the image rendering on it
    '''
    if max_value is None:
        max_value = DEFAULT_MAX_BAYES_FACTOR
    # Set default parameters
    d = _set_heatmap_default_args(linewidths=linewidths, linecolor=linecolor, 
        n_colors=n_colors, xticklabels=xticklabels, yticklabels=yticklabels, 
        include_colorbar=include_colorbar, include_tick_marks=include_tick_marks)
    linewidths = d['linewidths']
    linecolor = d['linecolor']
    n_colors = d['n_colors']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    include_colorbar = d['include_colorbar']
    include_tick_marks = d['include_tick_marks']

    # Type checking and initialization
    d = _init_parameters_heatmap(matrix=bayes_factors,
        otus=otus, clustering=clustering, xticklabels=xticklabels,
        yticklabels=yticklabels, ax=ax, figure_size=figure_size,
        linewidths=linewidths, order=order)
    ax = d['ax']
    bayes_factors = d['matrix']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    cbar_kws = d['cbar_kws']
    linewidths = d['linewidths']

    if np.any(bayes_factors < 0):
        raise ValueError('There should be no negative values in `bayes_factors`')
    for i in range(otus.n_otus):
        bayes_factors[i,i] = np.nan
    if cmap is None:
        cmap = sns.color_palette('Blues', n_colors=n_colors)
    if max_value is not None:
        bayes_factors[bayes_factors > max_value] = max_value

    ax = sns.heatmap(
        data=bayes_factors,
        square=True,
        linewidths=linewidths,
        linecolor=linecolor,
        cmap=cmap,
        cbar=include_colorbar,
        robust=True,
        cbar_kws=cbar_kws,
        xticklabels=xticklabels,
        yticklabels=yticklabels)

    if not include_tick_marks:
        ax.tick_params(bottom=False, left=False)
    if title is not None:
        ax.set_title(title)
    return ax

def render_cocluster_proportions(coclusters, otus, clustering=None, ax=None,
    n_colors=None, xticklabels=None, yticklabels=None,
    include_tick_marks=None, linewidths=None, linecolor=None, cmap=None,
    include_colorbar=None, title='Microbe Co-cluster Proportions', figure_size=None,
    order=None):
    '''Render the cocluster proportions. Values in coclusters should be [0,1].

    Parameters
    ----------
    coclusters : 2-dim np.ndarray
        - Square matrix indicating the cocluster proportions
    otus : pylab.base.OTUSet
        - This is the object that contains all of the OTU metadata
    clustering : pylab.cluster.ClusteringBase, Optional
        - Clustering object if you want the OTUs in the same cluster to be grouped
          together
    ax : matplotlib.pyplot.Axes, Optional
        - The axes to plot on. If nothing is provided a new figure will be created
    n_colors : int, Optional
        - The number of colors to generate for the colormap.
    xticklabels, yticklabels : str, list, None, Optional
        - These are the labels for the x and y axis, respectively.
        - If it is a list then it must have `otus.n_otus` elements.
        - If it is a string, it is the formatter for each of the rows/columns.
        - If it is None, then do not make any ticklabels
    include_tick_marks : bool, Optional
        - If True, include tick marks. If False get rid of them
    linewidths : float, Optional
        - The width of the lines separating the squares
    linecolor : str, Optional
        - The color of the lines separating the squares
    cmap : colormap object, Optional
        - Overrides the default colormap. If specified, we ignore `n_colors`
    include_colorbar : bool, Optional
        - If True, it will render the colorbar, if not then it wont.
    title : str, None, Optional
        - Title of the figure
        - If None then do not put any title
    figure_size : 2-tuple, Optional
        - This is the size of the figure (in inches)
        - If nothing is specified it will default to adding 10 inches in each
          dimension for every 50 OTUs

    Returns
    -------
    matplotlib.pyplot.Axes
        Axes object that has the image rendering on it
    '''
    # Set default parameters
    d = _set_heatmap_default_args(linewidths=linewidths, linecolor=linecolor, 
        n_colors=n_colors, xticklabels=xticklabels, yticklabels=yticklabels, 
        include_colorbar=include_colorbar, include_tick_marks=include_tick_marks)
    linewidths = d['linewidths']
    linecolor = d['linecolor']
    n_colors = d['n_colors']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    include_colorbar = d['include_colorbar']
    include_tick_marks = d['include_tick_marks']

    # Type checking and initialization
    d = _init_parameters_heatmap(matrix=coclusters,
        otus=otus, clustering=clustering, xticklabels=xticklabels,
        yticklabels=yticklabels, ax=ax, figure_size=figure_size,
        linewidths=linewidths, order=order)
    ax = d['ax']
    coclusters = d['matrix']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    cbar_kws = d['cbar_kws']
    linewidths = d['linewidths']

    if cmap is None:
        cmap = sns.color_palette('Blues', n_colors=n_colors)
    if np.any(coclusters < 0) or np.any(coclusters > 1):
        raise ValueError('All values of coclusters should be in [0,1]')

    ax = sns.heatmap(
        data=coclusters,
        square=True,
        linewidths=linewidths,
        linecolor=linecolor,
        cmap=cmap,
        cbar_kws=cbar_kws,
        cbar=include_colorbar,
        xticklabels=xticklabels,
        robust=True,
        yticklabels=yticklabels)

    if not include_tick_marks:
        ax.tick_params(bottom=False, left=False)
    if title is not None:
        ax.set_title(title)
    return ax

def render_interaction_strength(interaction_matrix, log_scale, otus, clustering=None,
    ax=None, center_colors=False, n_colors=None, xticklabels=None, vmax=None, vmin=None,
    yticklabels=None, include_tick_marks=None, linewidths=None, linecolor=None,
    cmap=None, include_colorbar=None, title='Microbe Interaction Strength',
    figure_size=None, order=None):
    '''Render the interaction strength matrix. If you want the values in log scale,
    it will annotate the box with the sign of the interaction and plot the absolute
    value of the interaction. If you want the OTUs in the same clusters to be grouped
    together, specify the clustering object in `cluster`.

    Parameters
    ----------
    interaction_matrix : 2-dim np.ndarray
        - Square matrix indicating the interaction strengths
    log_scale : bool
        - If True, plots with log scale. If False it plots with regular
          scale
    otus : pylab.base.OTUSet
        - This is the object that contains all of the OTU metadata
    clustering : pylab.cluster.ClusteringBase, Optional
        - Clustering object if you want the OTUs in the same cluster to be grouped
          together
    ax : matplotlib.pyplot.Axes, Optional
        - The axes to plot on. If nothing is provided a new figure will be created
    center_colors : bool, Optional
        - If True, it will center the colors for the colormap
        - This is overriden if `log_scale` is True
    n_colors : int, Optional
        - The number of colors to generate for the colormap.
    vmax, vmin : float
        - Lower and upper values to plot. If nothing is provided then it is
          infered from the data
    xticklabels, yticklabels : str, list, None, Optional
        - These are the labels for the x and y axis, respectively.
        - For details on the format, look at `pylab.util.otuname_formatter`
        - If it is a list then it must have `otus.n_otus` elements.
        - If it is a string, it is the formatter for each of the rows/columns.
        - If it is None, then do not make any ticklabels
    include_tick_marks : bool, Optional
        - If True, include tick marks. If False get rid of them
    linewidths : float, Optional
        - The width of the lines separating the squares
    linecolor : str, Optional
        - The color of the lines separating the squares
    cmap : colormap object, Optional
        - Overrides the default colormap. If specified, we ignore `n_colors`
    include_colorbar : bool, Optional
        - If True, it will render the colorbar, if not then it wont.
    title : str, None, Optional
        - Title of the figure
        - If None then do not put any title
    figure_size : 2-tuple, Optional
        - This is the size of the figure (in inches)
        - If nothing is specified it will default to adding 10 inches in each
          dimension for every 50 OTUs
    
    Returns
    -------
    matplotlib.pyplot.Axes
        Axes object that has the image rendering on it
    '''
    # Set default parameters
    d = _set_heatmap_default_args(linewidths=linewidths, linecolor=linecolor, 
        n_colors=n_colors, xticklabels=xticklabels, yticklabels=yticklabels, 
        include_colorbar=include_colorbar, include_tick_marks=include_tick_marks)
    linewidths = d['linewidths']
    linecolor = d['linecolor']
    n_colors = d['n_colors']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    include_colorbar = d['include_colorbar']
    include_tick_marks = d['include_tick_marks']

    # Type checking and initialization
    d = _init_parameters_heatmap(matrix=interaction_matrix,
        otus=otus, clustering=clustering, xticklabels=xticklabels,
        yticklabels=yticklabels, ax=ax, figure_size=figure_size,
        linewidths=linewidths, order=order)
    ax = d['ax']
    interaction_matrix = d['matrix']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    cbar_kws = d['cbar_kws']
    linewidths = d['linewidths']

    if cmap is None:
        cmap = sns.cubehelix_palette(n_colors)
    if center_colors and not log_scale:
        cmap = sns.color_palette("RdBu_r", n_colors)
        center_colors=0 # center at 0
        if vmin is not None and vmax is not None:
            absmax = np.max(np.absolute([vmin,vmax]))
            vmin = -absmax
            vmax = absmax

    log_scale = bool(log_scale)
    center_colors = bool(center_colors)
    include_tick_marks = bool(include_tick_marks)
    linewidths = float(linewidths)
    linecolor = str(linecolor)
    include_colorbar = bool(include_colorbar)
    n_colors = int(n_colors)

    # Add annotation and override parameters if we are doing log scale
    if log_scale:
        ann = []
        for i in range(interaction_matrix.shape[0]):
            ann.append([])
            for j in range(interaction_matrix.shape[1]):
                b = '+'
                if interaction_matrix[i,j] < 0:
                    b = '\u2212' # uicode minus sign
                ann[-1].append(b)
        annot = np.asarray(ann)
        interaction_matrix = np.log10(np.absolute(interaction_matrix))
        interaction_matrix[~np.isfinite(interaction_matrix)] = np.nan
        interaction_matrix[interaction_matrix == 0] = np.nan

        center_colors = None
        # if vmax is not None:
        #     vmax=np.absolute(vmax)
        # if vmin is not None:
        #     vmin=np.absolute(vmin)
    else:
        annot = None

    try:
        ax = sns.heatmap(
            data=interaction_matrix,
            annot=annot,
            fmt='',
            center=center_colors,
            square=True,
            # vmin=vmin,
            # vmax=vmax,
            robust=True,
            linewidths=linewidths,
            linecolor=linecolor,
            cmap=cmap,
            cbar=include_colorbar,
            cbar_kws=cbar_kws,
            xticklabels=xticklabels,
            yticklabels=yticklabels)
        if not include_tick_marks:
            ax.tick_params(bottom=False, left=False)
        if title is not None:
            ax.set_title(title)
        if log_scale:
            ax.collections[0].colorbar.ax.set_title("$\\log_{10}$")
    except Exception as e:
        logging.critical('Could not plot heatmap because of error message: "{}".' \
            ' This is likely because `interaction_matrix` has either only NaNs ' \
            'or 0s ({}). We are clearing the current axis and are going to skip' \
            'plotting this axis.'.format(str(e), _is_just_zero_or_nan(interaction_matrix)))
    return ax

def render_growth_vector(growth, difference=False, ax=None, light_palette='Navy', **kwargs):
    '''Renders the growth terms of the regression coefficients as an image. Pass
    in the raw regression coefficients and

    Parameters
    ----------
    growth : np.ndarray
        - growth terms from the interaction matrix
    ax : matplotlib.pyplot.Axes, Optional
        - Axis to plot on.
        - If nothing is provided, a new figure is created with a subplot
          that takes up the entire figure.
    difference : bool, Optional
        - If True, Resets the colormap so that a 0 difference is white and
          it is diverging.
    light_palette : str, Optional
        - Palette to use for the colormap
    kwargs : dict
        - optional arguments for plt.imshow
        - Default values:
            'vmin' = - max(abs(max(raw_regress_coeff)), abs(min(raw_regress_coeff)))
            'vmin' = + max(abs(max(raw_regress_coeff)), abs(min(raw_regress_coeff)))

    Returns
    -------
    matplotlib.pyplot.Axes
        - Axis object that has the rendering of the growth values
    '''

    growth = growth.reshape(-1,1)
    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111)

    # Set labels if necessary
    ax, kwargs = _set_plt_labels(kwargs, ax)

    # Set default values if necessary
    if difference:
        kwargs['cmap'] = sns.diverging_palette(240,10,n=DEFAULT_N_COLORS, as_cmap=True)
    else:
        kwargs['cmap'] = sns.light_palette(light_palette, as_cmap=True)

    _max = np.max(np.absolute(growth))
    if 'vmin' not in kwargs and difference:
        kwargs['vmin'] = -_max
    if 'vmax' not in kwargs and difference:
        kwargs['vmax'] = _max

    im = ax.imshow(growth, **kwargs)

    # Set ticks so that you can discern between pixels
    ax.set_yticks(np.arange(-.5, growth.shape[0], 1), minor = False)
    ax.set_yticks(np.arange(0, growth.shape[0], 1), minor = True)

    ax.set_xticklabels([])
    ax.set_yticklabels(labels = np.arange(0, growth.shape[0], dtype=int), minor = True)
    ax.tick_params(which = 'major',labelbottom = False, labelleft = False,
        labelright = False, labeltop = False)
    ax.tick_params(which = 'minor',labelbottom = False, labelleft = True,
        labelright = False, labeltop = False)
    ax.grid(color='black', linewidth = 1.5, which='major', axis='y')
    return im

# ------
# Traces
# ------
def render_acceptance_rate_trace(var, prev='default', ax=None, include_burnin=True, **kwargs):
    '''Visualize the acceptance rate over time for a
    metropolis._BaseKernel object.

    Parameters
    ----------
    var : array, subclass pylab.metropolis._BaseKernel
        - Array to do the trace on
        - If it is not a metropolis kernel then we automatically set
          `include_burnin` to False
    prev : int, str, None, Optional
        - For each iteration, calculate the acceptance rate based on the previous `prev`
          iterations. If None, does it over the entire trace. If it is a str, the options
          are:
            'default': sets it to the default 
            'all': Same as None
    ax : matplotlib.pyplot.Axes, Optional
        - Axes to plot on
        - If nothing is provided, a new figure with a single subplot
          will be created and returned
    inlcude_burnin : bool, Optional
        - If True, it will plot the burnin trace as negative numbers
          in the trace as well
    kwargs : dict, Optional
        - Optional arguments:
            - 'color' : str
                - Default color is 'blue'
            - 'alpha' : float
                - Default alpha is 0.5 for the trace
            - 'title' : str
                - Nothing
            - 'xlabel' : str
                - Default is 'Iteration'
            - 'ylabel' : str
                - Default is 'Acceptance Rate

    Returns
    -------
    matplotlib.pyplot.Axes
        - Axis object that contains the rendering of the acceptance rate
    '''
    if util.isstr(prev):
        if prev == 'all':
            prev = float('inf')
        elif prev == 'default':
            prev = DEFAULT_ACCEPTANCE_RATE_PREV
        else:
            raise ValueError('str `default` ({}) not recognized'.format(prev))
    elif prev is None:
        prev = float('inf')
    elif not util.isint(prev):
        raise ValueError('`prev` ({}) must either be None or an int'.format(type(prev)))
    if not util.isbool(include_burnin):
        raise ValueError('`include_burnin` ({}) must be a bool'.format(type(include_burnin)))

    if util.isarray(var):
        logging.info('Overriding `include_burning` to False')
        trace = np.asarray(var)
        points = np.arange(len(trace))

    elif isVariable(var):
        trace = var.get_trace_from_disk()
        if include_burnin:
            burnin_trace = var.trace_from_disk(section='burnin')
            points = np.append(
                np.arange(-len(burnin_trace),0,1),
                np.arange(len(trace)))
            trace = np.append(burnin_trace, trace)
        else:
            points = np.arange(len(trace))
    else:
        raise ValueError('`var` ({}) must either an array or a metropolis Kernel'.format(
            type(var)))

    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111)
    # extract labels
    if 'xlabel' not in kwargs:
        kwargs['xlabel'] = 'Iteration'
    if 'ylabel' not in kwargs:
        kwargs['ylabel'] = 'Acceptance Rate'
    ax, kwargs = _set_plt_labels(kwargs, ax)

    # Calculate the acceptance rate overtime
    value = np.zeros(len(trace), dtype=float)
    for i in range(len(value)):
        if i <= prev:
            start = 0
        else:
            start = i - prev
        value[i] = acceptance_rate(var, start, i)

    if 'alpha' not in kwargs:
        kwargs['alpha'] = 0.5
    try:
        ax.plot(points, np.squeeze(value), **kwargs)
    except:
        logging.info('`ax.plot` failed. No points to plot')
    return ax

def render_trace(var, idx=None, ax=None, plt_type=None, include_burnin=True, 
    scatter=True, log_scale=False, n_burnin=None, **kwargs):
    '''
    Visualizes the Trace of a random variable.
    Produces a historgram of the values and a plot of the sample
    values over the iterations.

    Parameters
    ----------
    var : array, pylab.variables.Variable
        - Array to do the trace on.
        - If it is not a pylab variable object, then we need to pass in how many 
          burnin iterations there are with the parameter `n_burnin` orelse we 
          automatically set `include_burnin` to False
    idx : int, tuple, Optional
        - If the variable is not a scalar, this indexes the index that you want to trace on
    ax : matplotlib.pyplot.Axes, Optional
        - Axes to plot on
        - If nothing is provided, a new figure with a single subplot
          will be created and returned
    plt_type : str, Optional
        - The type of plot that will make
        - Options:
            - 'hist'
                - Histogram of the values. This is the posterior
            - 'trace' (Default)
                - The value of the random variable for each iteration
            - 'both' (Default)
                - Makes a new figure and plots 'hist' on the left
                  and 'trace' on the right.
                - If specified, `ax` is ignored.
    inlcude_burnin : bool, Optional
        - If True, it will plot the burnin trace as negative numbers
          in the trace as well
        - If `plt_type` == 'hist', `include_burnin` is automatically set to False
    scatter : bool
        - Only applies to plt_type=='trace'
        - If True, it will plot the points as a scatter plot
        - Else it will plot the points as a line
    log_scale : bool
        If True, plots the points in log-scale. If any of the points are negative, then we 
        take the absolute value of the values that we are plotting
    n_burnin : int
        Only required if `var` is an array, not a pylab.variables.Variable.
        Tells how big the burnin array is.
    kwargs : Optional values for the figure
        - Optional arguments:
            - 'color' : str
                - Default color is 'blue'
            - 'alpha' : float
                - Default alpha is 0.5 for the trace
            - 'title' : str
                - Nothing
            - 'xlabel' : str
                - Label of the horizontal axis
                - Default is 'Iteration' if the `plt_type` is 'trace'.
                - Default is 'Value' if the `plt_type` is 'hist'
            - 'ylabel' : str
                - Label of the vertical axis
                - Default is 'Value' if the `plt_type` is 'trace'.
                - Default is 'Count' if the `plt_type` is 'hist'
        
    Returns
    -------
    matplotlib.pyplot.Axes, 2-tuple
        - This is the Axis that contains the rendered figure
        - If `plt_type` == 'both' then it will return both Axes
    '''
    _valid_kwargs = ['color', 'alpha', 'xlabel', 'ylabel', 'label', 'title']

    # Set defaults
    if plt_type is None:
        plt_type = DEFAULT_PLT_TYPE
    if 'color' not in kwargs:
        kwargs['color'] = DEFAULT_TRACE_COLOR
    if not util.isbool(scatter):
        raise TypeError('`scatter` ({}) must be a bool'.format(type(scatter)))
    if not util.isbool(log_scale):
        raise TypeError('`log_scale` ({}) must be a bool'.format(type(log_scale)))
    
    # check the kwargs
    for k in kwargs:
        if k not in _valid_kwargs:
            raise TypeError('`render_trace` got unexpected keyword argument "{}"'.format(k))

    if plt_type == 'both':
        fig = plt.figure()
        ax1 = render_trace(
            var=var, ax=fig.add_subplot(1,2,1), plt_type='hist',
            idx=idx, log_scale=log_scale,  **kwargs)
        ax2 = render_trace(
            var=var, ax=fig.add_subplot(1,2,2), plt_type='trace',
            scatter=scatter, log_scale=log_scale, idx=idx, **kwargs)
        fig.tight_layout()
        fig.subplots_adjust(top=0.85)
        return ax1, ax2
    elif plt_type == 'hist':
        include_burnin = False

    if idx is not None:
        # Then it is multidimensional
        if type(idx) == int:
            idxs = (..., idx)
        elif type(idx) == tuple:
            idxs = (..., ) + idx
        else:
            raise ValueError('`idx` ({}) must either be an int or a tuple'.format(
                type(idx)))
    else:
        idxs = ()

    if not isVariable(var):
        trace = np.asarray(var)
        if util.isint(n_burnin):
            if n_burnin < 0:
                raise ValueError('`n_burnin` ({}) must be >= 0'.format(n_burnin))
            points = np.append(
                np.arange(-n_burnin, 0, 1),
                np.arange(len(trace) - n_burnin))
        else:
            points = np.arange(trace.shape[0])
        trace = trace[idxs]
        include_burnin = False
        
    else:
        trace = var.get_trace_from_disk()[idxs]
        if include_burnin:
            burnin_trace = var.get_trace_from_disk(section='burnin')
            burnin_trace = burnin_trace[idxs]
            points = np.append(
                np.arange(-len(burnin_trace),0,1),
                np.arange(len(trace)))
            trace = np.append(burnin_trace, trace)
        else:
            points = np.arange(len(trace))

    if trace[idxs].ndim > 1:
        raise ValueError('`render_trace` only supports vectors ({})'.format(trace.shape))

    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111)
    # extract labels
    if 'xlabel' not in kwargs:
        if plt_type == 'hist':
            kwargs['xlabel'] = 'Value'
        else:
            kwargs['xlabel'] = 'Iteration'
    if 'ylabel' not in kwargs:
        if plt_type == 'hist':
            kwargs['ylabel'] = 'Probability'
        else:
            kwargs['ylabel'] = 'Value'
    if 'title' not in kwargs:
        if plt_type == 'hist':
            kwargs['title'] = 'Posterior'
        else:
            kwargs['title'] = 'Trace'
    ax, kwargs = _set_plt_labels(kwargs, ax)

    if plt_type == 'trace':
        if 'alpha' not in kwargs:
            kwargs['alpha'] = 0.5
        try:
            if log_scale:
                if np.any(trace < 0):
                    logging.warning('Some values in trace are negative, take absolute value of vector')
                    trace = np.absolute(trace)
                ax.set_yscale('log')
            if scatter:
                ax.scatter(points, np.squeeze(trace), s=1.5, **kwargs)
            else:
                ax.plot(points, np.squeeze(trace), **kwargs)
        except:
            logging.info('`ax.plot` failed. No points to plot')
        if log_scale:
            ax.set_yscale('log')
    elif plt_type == 'hist':
        if 'alpha' not in kwargs:
            kwargs['alpha'] = 0.25
        try:
            if log_scale:
                if np.any(trace < 0):
                    logging.warning('Some values in trace are negative, take absolute value of vector')
                    trace = np.absolute(trace)
                hist, bins = np.histogram(trace, bins=30)
                logbins = np.logspace(np.log10(bins[0]),np.log10(bins[-1]),len(bins))
                ax.hist(x=trace, bins=logbins, density=True, **kwargs)
                ax.set_xscale('log')
            else:
                ax.hist(x=trace, density=True, bins=20, **kwargs)
            # ax.axvline(x=np.mean(trace), color = 'red')
            # ax.axvline(x=np.median(trace), color = 'blue')

        except Exception as e:
            logging.info('`ax.hist` failed: {}'.format(e))
            return None
    else:
        raise ValueError('plt_type ({}) not recognized'.format(plt_type))
    return ax

# ----------
# Abundances
# ----------
def alpha_diversity_over_time(subjs, metric, taxlevel=None, drop_nan_taxa=False, 
    highlight=None, marker='o', markersize=4, shade_perturbations=True, 
    legend=True, cmap=None, alpha=1.0, linestyle='-', ax=None, grid=False, **kwargs):
    '''Plots the alpha diversity over time for the subject

    Parameters
    ----------
    subjs : pylab.base.Subject, list(pylab.base.Subject)
        This is the subject that we are getting the data from, or a list of subjects
        we are doing together
    metric : callable
        This is the function we want to calculate the alpha diversity with.
        This function usually comes from `diversity.alpha`
    taxlevel : str, None
        This is the taxa level to aggregate the data at. If 'default' is specified
        then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
    drop_nan_taxa : bool
        If True, it will not plot taxas that are not specified (NaNs). If False, it
        will conglomerate all the taxas into a single category called 'Unclassified'
    highlight : list(float), None
        These are a list of tuples (subjectname, timepoint) we want to highlight (circle). 
        Each element must be a time in `subj.times`. If nothing is specified then we do not
        circle anything
    marker : str
        Type of marker to have on the plot
    markersize : numeric
        How big to make the marker
    shade_perturbations : bool
        If True, shade in the perturbations
    legend : bool
        If True, add a legend
    cmap : str
        This is the colormap to use. It uses `seaborn.color_palette` to generate the 
        colormap and `camp` is which colormap to use. Default (None) is `DEFAULT_SNS_CMAP`.
    alpha : float
        How dark to make the line. Default is 1.0
    linestyle : str
        Linestyle for matplotlib. The type is not checked with this because it is checked 
        within matplotlib
    kwargs : dict
        xlabel, ylabel, title : str
            Default 'title' is the type of alpha diversity and the level
        ax : matplotlib.pyplot.Axes, None
            This is the axis to plot on. If nothing is specified then we will create a 
            new figure with this as the only axis.
        figsize : 2-tuple
            Size of the figure
        legend : bool
            If True, add a legend
    
    Returns
    -------
    matplotlib.pyplot.Axes
    '''
    # Type checking
    if not util.isbool(grid):
        raise TypeError('`grid` ({}) must be a bool'.format(type(grid)))
    if issubject(subjs):
        subjs = [subjs]
    if not util.isarray(subjs):
        raise ValueError('`subjs` ({}) must be a pylab.base.Subject or an array'.format(type(subjs)))
    if not callable(metric):
        raise ValueError('`metric` ({}) must be callable'.format(type(metric)))
    if not util.isbool(drop_nan_taxa):
        raise ValueError('`drop_nan_taxa` ({}) must be a bool'.format(
            type(drop_nan_taxa)))
    if not util.isbool(shade_perturbations):
        raise ValueError('`shade_perturbations` ({}) must be a bool'.format(
            type(shade_perturbations)))
    if not util.isbool(legend):
        raise ValueError('If `legend` ({}) is specified, it must be a bool'.format(
            type(legend)))
    if cmap is None:
        cmap = DEFAULT_SNS_CMAP
    elif not util.isstr(cmap):
        raise TypeError('`cmap` ({}) must either be None or a str'.format(type(cmap)))

    if 'title' not in kwargs:
        kwargs['title'] = '{} over time, {} level'.format( 
            metric.__name__.capitalize(), taxlevel)
    if 'xlabel' not in kwargs:
        kwargs['xlabel'] = 'Day'
    ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
    taxlevel = _set_taxlevel(taxlevel)

    colors = sns.color_palette(cmap, n_colors=len(subjs))
    for sidx, subj in enumerate(subjs):
        df = subj.cluster_by_taxlevel(dtype='raw', drop_nan_taxa=drop_nan_taxa,
            taxlevel=taxlevel)

        # Calculate the alpha diversity over time and plot
        vals = np.zeros(len(df.columns))
        for i in range(len(vals)):
            vals[i] = metric(df.values[:,i])
        ax.plot(subj.times, vals, label=subj.name, marker=marker, markersize=markersize,
            color=colors[sidx], alpha=alpha, linestyle=linestyle)

    # Check if there are any points to highlight
    if highlight is not None:
        for a in highlight:
            if type(a) != tuple:
                raise ValueError('Each element in highlight must be a tuple ({})'.format(
                    type(a)))
            if len(a) != 2:
                raise ValueError('The tuple must be length 2 ({})'.format(len(a)))
            
            subjname, timepoint = a
            subj = None
            for b in subjs:
                if b.name == subjname:
                    subj = b
            if subj is None:
                raise ValueError('`subjname` ({}) not a valid subject name'.format(subjname))
            if not util.isnumeric(timepoint):
                raise ValueError('invalid timepoint ({}) in `highlight`. ' \
                    'It must be a numeric'.format(type(timepoint)))
            if timepoint not in subj.times:
                raise ValueError('timepoint ({}) not found in times ({})'.format(
                    timepoint, subj.times))
            tidx = np.searchsorted(subj.times, timepoint)
            ax.scatter( 
                [timepoint],
                [vals[tidx]],
                s=140,
                facecolor='None',
                edgecolors='black',
                zorder=100)

    ax = _set_xticks(ax)
    if shade_perturbations:
        ax = shade_in_perturbations(ax, subjs[0].parent.perturbations)
    if legend:
        ax.legend(bbox_to_anchor=(1,1))
    if grid:
        ax.grid()
    return ax

def abundance_over_time(subj, dtype, taxlevel=None, drop_nan_taxa=False, yscale_log=None,
    plot_abundant=None, plot_specific=None, plot_clusters=None, highlight=None, marker='o',
    ylim=None, markersize=4, shade_perturbations=True, legend=True, set_0_to_nan=False, 
    color_code_clusters=False, clustering=None, cmap=None, alpha=1.0, linestyle='-', ax=None,
    include_errorbars=False, grid=False, label_formatter=None, **kwargs):
    '''Plots the abundance over time for the OTUs in `subj`.

    What you're plotting
    --------------------
    There are several different types of abundances you can plot, which is specified using
    the `dtype` (str) parameter:
    'raw'
        This plots the counts of the OTUs. `subj` must be a single pl.base.Subject object.
    'rel'
        This plots the relative abundance of the OTUs. `subj` must be a single 
        pl.base.Subject object.
    'abs'
        This plots the absolute abundance of the OTUs. `subj` must be a single 
        pl.base.Subject object.
    'qpcr'
        This plots the qPCR measurements at each time point. `subj` can also be a 
        list of pl.base.Subject objects, or a `pl.base.SubjectSet` object.
    'read-depth'
        These are the the read depths at each timepoint. `subj` can also be a 
        list of pl.base.Subject objects, or a `pl.base.SubjectSet` object.
    
    Aggregating by taxanomic level
    ------------------------------
    If the taxonomy of the OTUs are specified, you can aggregate OTUs into specific 
    taxonomic levels and plot them as a trajectory by using the parameter `taxlevel`.
    Example: if `taxlevel='phylum'` then we add all of the abundances/reads of the OTUs
    that are in the same Phylum. If `taxlevel=None` then we do no aggregation. If you 
    set `taxlevel='default'` then it aggregates at the default taxonomic level, which 
    can be set using the function `plotting.set_default_tax_level(level)`. NOTE: these 
    are only necessary if dtype is either 'raw', 're', or 'abs'.

    The `label_formatter` (str) tells the function how to set the index of the dataframe
    it returns using `pylab.util.otuname_formatter`. If nothing is specified then it 
    will return the entire taxonomy as a label for the taxa. NOTE, you cannot specifiy
    a taxonomy *below* that youre clustering at. For example, you cannot cluster at the 
    'class' level and then specify `'%(genus)s'` in `label_formatter`.

    What to plot?
    -------------
    You can plot a subset of the OTUs by using the `plot_` arguments. If None of those
    parameters are specified, then it will plot everything. NOTE: You can only specify 
    one of the `plot_` at a time. NOTE: these are only necessary if dtype is either 
    'raw', 're', or 'abs'.

    plot_abundant : int
    If you want to only plot the x most abundant OTUs, specify that number 
    with `plot_abundant` (`int`) as a positive number. Example: `plot_abundant = 15` will
    only plot the 15 most abundant. If `plot_abundant` is a negative number, it will
    plot the least abundant. Example: `plot_abundant = -15` will only plot the 15 least 
    abundant. 
    
    plot_specific : list
    If you want to only plot specific OTUs, you can specify them by any identification
    (index, name, ID, etc.) as a list of OTUs to plot.
    NOTE: If you specify `plot_specific` and you are clustering along a taxonomic level, then
    you specify the names at the taxonomic level you clustered at.
    Example::
        If taxlevel = 'phylum'
        VALID: plot_specific = [('Bacteria', 'Bacteroidetes'), ('Bacteria', 'Firmicutes')]
        INVALID: plot_specific = ['Bacteroidetes', 'Firmicutes'] # Need full taxonomy
        INVALID: plot_specific = ['Bacteroidia', 'Clostridia'] # This is at the class level
        INVALID: plot_specific = ['OTU_32'] # These names are no longer valid

    plot_clusters : list(int), int
    If you want to plot specific clusters (or a single cluster), you can specify the cluster
    ID/s to plot. Note that you must also specify the `clustering` parameter as well and you
    cannot aggregate the data into taxonomic classes.

    Log-scale and NaN's
    -------------------
    We will automatically plot the yscale as log for the 'raw' and 'abs' 
    datatypes and regular for 'rel'. If you want to do something different
    then set the `yscale_log` parameter.

    If you want to NaN out all of the points that have a zero abundance so that there are not
    vertical lines everywhere, use parameter `set_0_to_nan` to True

    Parameters
    ----------
    subj : pylab.base.Subject, pylab.base.SubjectSet, list(pylab.base.Subject)
        Subject/s we are getting the data from. Must be a single object if 
        `dtype` is 'raw', 'rel', or 'abs'. Must be multiple or single object.
        If `dtype` is 'qpcr' or 'read-depth', then this can also be a list of 
        Subject objects or a SubjectSet object,
    dtype : str
        Datatype to plot.
            'raw': Count data
            'rel': Relative abundance
            'abs': Absolute abudance 
            'qpcr': qPCR measurements
            'read-depth': read depths
    taxlevel : str, None
        This is the taxa level to aggregate the data at. If 'default' is specified
        then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
    drop_nan_taxa : bool
        If True, it will not plot taxas that are not specified (NaNs). If False, it
        will conglomerate all the taxas into a single category called 'Unclassified'
    yscale : bool, None
        If True, it will plot the y-axis in log scale. If nothing is specified then it 
        will pick it automatically.
    plot_abundant : int, None
        If specified, it will plot only this number most abundant OTUs
    plot_specific : array_like, None
        If specified, it will only plot the OTUs specified indicated in here. Else
        it will plot everything
    plot_clusters : array_like, None
        If specified, only plots the clusters specified. Note that the `clustering` parameter
        must also be specified
    highlight : list(float), None
        These are a list of tuples (otu, timepoint) we want to highlight (circle). 
        Each element must be a time in `subj.times`. If nothing is specified then we do not
        circle anything
    ylim : 2-tuple, Optional
        Sets lower and upper bounds for the y-axis. 
    marker : str
        Type of marker to have on the plot
    markersize : numeric
        How big to make the marker
    legend : bool
        If True, add a legend
    shade_perturbations : bool
        If True, shade in the perturbations
    color_code_clusters : bool
        If True, set all of the OTUs in a cluster to the same color. Note that the `clustering` 
        parameter must also be specified. NOTE: if you are aggregating the data at a taxonomic 
        level (taxlevel is not None or 'otu'), then this is automatically overridden to False.
        If specified, it overrides the legend to False.
    clustering : pylab.cluster.Clustering
        Clustering object. Only necessary if `plot_clusters` or `color_code_clusters` are specified
    cmap : str
        This is the colormap to use. It uses `seaborn.color_palette` to generate the 
        colormap and `camp` is which colormap to use. Default (None) is `DEFAULT_SNS_CMAP`.
    alpha : float
        How dark to make the line. Default is 1.0
    linestyle : str
        Linestyle for matplotlib. The type is not checked with this because it is checked 
        within matplotlib
    include_errorbars : bool
        If True, we include the errorbars (standard deviation) for each point. This is only
        used if `dtype` == 'qpcr'
    highlight : list(2-tuple), None
        If this is specified, this highlights the points specified in the 2-tuple:
        (subject ID, timepoint). This is only used if `dtype` == 'qpcr' or 'read-depth'
    grid : bool
        If True, plots with a grid
    kwargs : dict
        xlabel, ylabel, title : str
            Default 'title' is the type of alpha diversity and the level
        ax : matplotlib.pyplot.Axes, None
            This is the axis to plot on. If nothing is specified then we will create a 
            new figure with this as the only axis.
        figsize : 2-tuple
            Size of the figure

    Returns
    -------
    matplotlib.pyplot.Axes
    '''
    # Type checking
    taxlevel = _set_taxlevel(taxlevel)
    if not util.isstr(dtype):
        raise TypeError('`dtype` ({}) must be a str'.format(type(dtype)))
    if dtype not in ['raw', 'rel', 'abs', 'qpcr', 'read-depth']:
        raise TypeError('`dtype` ({}) not recognized'.format(dtype))
    if dtype == 'qpcr':
        if not util.isbool(include_errorbars):
            raise ValueError('`include_errorbars ({}) must be a bool'.format(type(include_errorbars)))
    if not util.isbool(grid):
        raise TypeError('`grid` ({}) must be a bool'.format(type(grid)))
    if not issubject(subj):
        if dtype not in ['qpcr', 'read-depth']:
            raise TypeError('`subj` ({}) must be a pylab.base.Subject'.format(type(subj)))
        else:
            if util.isarray(subj):
                for s in subj:
                    if not issubject(s):
                        raise TypeError('Every element in `subj` ({}) must be a ' \
                            'pl.base.Subject'.format(type(s)))
            if not issubjectset(subj):
                raise TypeError('`subj` ({}) type not recognized'.format(type(subj)))
    if not util.isbool(drop_nan_taxa):
        raise TypeError('`drop_nan_taxa` ({}) must be a bool'.format(
            type(drop_nan_taxa)))
    if yscale_log is None:
        if dtype == 'rel':
            yscale_log = False
        else:
            yscale_log = True
    if not util.isbool(yscale_log):
        raise TypeError('`yscale_log` ({}) must be a bool'.format(
            type(yscale_log)))
    if not util.isbool(shade_perturbations):
        raise TypeError('`shade_perturbations` ({}) must be a bool'.format(
            type(shade_perturbations)))
    if not util.isbool(legend):
        raise TypeError('If `legend` ({}) is specified, it must be a bool'.format(
            type(legend)))
    if not util.isbool(set_0_to_nan):
        raise TypeError('`set_0_to_nan` ({}) must be a bool'.format(type(set_0_to_nan)))
    if clustering is not None:
        if not isclustering(clustering):
            raise TypeError('`clustering` ({}) must be a pylab.cluster.Clustering' \
                ' object if specified'.format(type(clustering)))
    if color_code_clusters and clustering is None:
        raise ValueError('If `color_code_clusters` is True, `clustering` must also' \
            ' be specified')
    if cmap is None:
        cmap = DEFAULT_SNS_CMAP
    elif not util.isstr(cmap):
        raise TypeError('`cmap` ({}) must either be None or a str'.format(type(cmap)))
    if dtype in ['raw', 'rel', 'abs']:
        if plot_abundant is not None:
            if not util.isint(plot_abundant):
                raise TypeError('`plot_abundant` ({}) must be an int'.format(
                    type(plot_abundant)))
            if plot_abundant == 0:
                raise ValueError('`plot_abundant` cannot be zero')
        if plot_specific is not None:
            if not util.isarray(plot_specific):
                plot_specific = [plot_specific]
        if util.isint(plot_clusters):
            plot_clusters = [plot_clusters]
        if plot_clusters is not None:
            if not util.isarray(plot_clusters):
                raise TypeError('If `plot_clusters` ({}) is specified, it must either be ' \
                    'an int or an array'.format(type(plot_clusters)))
            else:
                for ele in plot_clusters:
                    if not util.isint(ele):
                        raise TypeError('Every element in `plot_clusters` ({}) ({}) must ' \
                            'be an int'.format(plot_clusters,
                                util.itercheck(plot_clusters, util.isint)))
            if taxlevel != 'otu':
                raise ValueError('Cannot plot clusters (`plot_clusters` ({})) and aggregate by a' \
                    ' taxonomic level (`taxlevel` ({}))'.format(plot_clusters, taxlevel))            
            if not isclustering(clustering):
                raise ValueError('If `plot_clusters` is specified, then clustering ({}) must be ' \
                    'specified'.format(type(clustering)))
        if not util.isbool(color_code_clusters):
            raise TypeError('`color_code_clusters` ({}) must be a bool'.format(
                type(color_code_clusters)))
        if color_code_clusters:
            if taxlevel != 'otu':
                logging.warning('Overriding `color_code_clusters` to False because `taxlevel`' \
                    ' ({}) is not None nor "otu"'.format(taxlevel))
                color_code_clusters = False
            if legend:
                logging.warning('Overriding `legend` to False because `color_code_clusters` is True')
            legend = False

        _cumm = 0
        if plot_abundant is not None:
            _cumm += 1
        if plot_specific is not None:
            _cumm += 1
        if plot_clusters is not None:
            _cumm += 1
        if _cumm > 1:
            raise ValueError('Only one `plot_` parameter can be specified. You specified {}'.format(_cumm))

        df = subj.cluster_by_taxlevel(dtype=dtype, drop_nan_taxa=drop_nan_taxa, taxlevel=taxlevel,
            index_formatter=label_formatter)
        times = subj.times

        if 'title' not in kwargs:
            kwargs['title'] = 'Abundance, Subject {}, {} level'.format(subj.name, taxlevel)
        if 'xlabel' not in kwargs:
            kwargs['xlabel'] = 'Days'
        if 'ylabel' not in kwargs:
            if dtype == 'rel':
                kwargs['ylabel'] = 'Relative abundance'
            elif dtype == 'raw':
                kwargs['ylabel'] = 'Counts'
            else:
                kwargs['ylabel'] = 'CFUs/g'

        ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
        idxs = np.arange(len(df.index))
        if plot_specific is not None:
            for i in range(len(plot_specific)):
                if util.isint(plot_specific[i]):
                    plot_specific[i] = subj.otus[plot_specific[i]].name
                plot_specific[i] = plot_specific[i].replace("'",'') #.replace(' ','').lower()
            idxs = []
            for i in range(len(plot_specific)):
                valid=False
                for j in range(len(df.index)):
                    if df.index[j] == plot_specific[i]:
                        valid=True
                        idxs.append(j)
                        break
                if not valid:
                    logging.error('Name `{}` not found in OTUs'.format(plot_specific[i]))
        elif plot_abundant is not None:
            matrix = df.values
            abnds = np.sum(matrix, axis=1)
            if plot_abundant < 0:
                plot_abundant *= -1
                idxs = np.argsort(abnds)[:plot_abundant]
            else:
                idxs = np.argsort(abnds)[-plot_abundant:]

        elif plot_clusters is not None:
            idxs = []
            for cid in plot_clusters:
                idxs = np.append(idxs, list(clustering[cid].members))
            idxs = np.asarray(idxs, dtype=int)

        if color_code_clusters:
            colors = {}
            ccs = sns.color_palette(cmap, n_colors=len(clustering.clusters))
            for i, cluster in enumerate(clustering):
                for idx in cluster.members:
                    colors[idx] = ccs[i]
        else:
            ccs = sns.color_palette(cmap, n_colors=len(idxs))
            colors = {}
            for i,idx in enumerate(idxs):
                colors[idx] = ccs[i]

                
        for idx in idxs:
            label = df.index[idx]
            # Only get the last name of the entire taxonomy
            label = re.findall(r"([^,)(' ]+)",label)[-1]
            datapoints = np.asarray(list(df.iloc[idx]))
            if set_0_to_nan:
                for i,val in enumerate(datapoints):
                    if val == 0:
                        datapoints[i] = np.nan
            ax.plot(times, datapoints, label=label, marker=marker, color=colors[idx], 
                markersize=markersize, alpha=alpha, linestyle=linestyle)
        
        if highlight is not None:
            logging.warning('`highlight` is not implemented for dtype ({}). Skipping'.format(
                dtype))
    else:
        if dtype == 'qpcr':
            if 'title' not in kwargs:
                kwargs['title'] = 'qPCR over time'
            if 'xlabel' not in kwargs:
                kwargs['xlabel'] = 'Day'
            if 'ylabel' not in kwargs:
                kwargs['ylabel'] = 'CFUs/g'
        else:
            if 'title' not in kwargs:
                kwargs['title'] = 'Read depth over time'
            if 'xlabel' not in kwargs:
                kwargs['xlabel'] = 'Day'
            if 'ylabel' not in kwargs:
                kwargs['ylabel'] = 'Counts'
        ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
        if ylim is not None:
            ax.set_ylim(*ylim)
        if issubject(subj):
            subj = [subj]
        colors = sns.color_palette(cmap, n_colors=len(subj))
        
        for sidx, ss in enumerate(subj):
            subj_kwargs = {'label': ss.name, 'marker': marker,
                'color': colors[sidx], 'markersize': markersize, 
                'alpha': alpha, 'linestyle': linestyle}

            if dtype == 'qpcr':
                mean = np.zeros(len(ss.times))
                std = np.zeros(len(ss.times))
                for i, t in enumerate(ss.times):
                    mean[i] = ss.qpcr[t].mean
                    std[i] = ss.qpcr[t].std
                if not include_errorbars:
                    std = None
                ax.errorbar(ss.times, mean, yerr=std, **subj_kwargs)
            else:
                rds = []
                for t in ss.times:
                    rds.append(np.sum(ss.reads[t]))
                ax.plot(ss.times, rds, **subj_kwargs)
        
        # Check if there are any points to highlight
        if highlight is not None:
            for a in highlight:
                if type(a) != tuple:
                    raise ValueError('Each element in highlight must be a tuple ({})'.format(
                        type(a)))
                if len(a) != 2:
                    raise ValueError('The tuple must be length 2 ({})'.format(len(a)))
                
                subjname, timepoint = a
                ss = None
                for b in subj:
                    if b.name == subjname:
                        ss = b
                if ss is None:
                    raise ValueError('`subjname` ({}) not a valid subject name'.format(subjname))
                if not util.isnumeric(timepoint):
                    raise ValueError('invalid timepoint ({}) in `highlight`. ' \
                        'It must be a numeric'.format(type(timepoint)))
                if timepoint not in ss.times:
                    raise ValueError('timepoint ({}) not found in times ({})'.format(
                        timepoint, ss.times))
                if dtype == 'qpcr':
                    yy = ss.qpcr[timepoint].mean
                else:
                    yy = np.sum(ss.reads[timepoint])
                ax.scatter( 
                    [timepoint],
                    [yy],
                    s=140,
                    facecolor='None',
                    edgecolors='black',
                    zorder=100)

    # Set the other parameters for the plot
    if yscale_log:
        ax.set_yscale('log')
    ax = _set_xticks(ax)
    if shade_perturbations:
        if issubject(subj):
            perturbations = subj.parent.perturbations
        elif issubjectset(subj):
            perturbations = subj.perturbations
        else:
            # Else it is an array of subjsets
            perturbations = subj[0].parent.perturbations
        ax = shade_in_perturbations(ax, perturbations)

    if legend:
        ax.legend(bbox_to_anchor=(1,1))
    if ylim is not None:
        ax.set_ylim(*ylim)
    if grid:
        ax.grid()
    return ax

def taxonomic_distribution_over_time(subj, taxlevel=None, drop_nan_taxa=False, 
    legend=True, ax=None, plot_abundant=None, label_formatter=None, **kwargs):
    '''Produces a taxonomic bar graph for each datapoint

    Aggregating by taxanomic level
    ------------------------------
    If the taxonomy of the OTUs are specified, you can aggregate OTUs into specific 
    taxonomic levels and plot them using the parameter `taxlevel`.
    Example: if `taxlevel='phylum'` then we add all of the reads of the OTUs
    that are in the same Phylum. If `taxlevel=None` then we do no aggregation. If you 
    set `taxlevel='default'` then it aggregates at the default taxonomic level, which 
    can be set using the function `plotting.set_default_tax_level(level)`.

    The `label_formatter` (str) tells the function how to set the index of the dataframe
    it returns using `pylab.util.otuname_formatter`. If nothing is specified then it 
    will return the entire taxonomy as a label for the taxa. NOTE, you cannot specifiy
    a taxonomy *below* that youre clustering at. For example, you cannot cluster at the 
    'class' level and then specify `'%(genus)s'` in `label_formatter`.

    plot_abundant : int
    If you want to only plot the x most abundant OTUs, specify that number 
    with `plot_abundant` (`int`) as a positive number. Example: `plot_abundant = 15` will
    only plot the 15 most abundant. If `plot_abundant` is a negative number, it will
    plot the least abundant. Example: `plot_abundant = -15` will only plot the 15 least 
    abundant. The abundances are calculated using the reads.

    Parameters
    ----------
    subj : pylab.base.Subject
        Subject we are getting the data from
    taxlevel : str, None
        This is the taxa level to aggregate the data at. If 'default' is specified
        then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
    drop_nan_taxa : bool
        If True, it will not plot taxas that are not specified (NaNs). If False, it
        will conglomerate all the taxas into a single category called 'Unclassified'
    plot_abundant: int, None
        If specified, only plots the top or bottom `plot_abundant` elements.
        If None then nothing happens
    label_formatter : str, None
        If specified, it will tell how to make the legend using the otuname_formatter.
        This can only be used if the `taxlevel` is not specified.
    kwargs : dict
        xlabel, ylabel, title : str
            Default 'title' is the type of alpha diversity and the level
        ax : matplotlib.pyplot.Axes, None
            This is the axis to plot on. If nothing is specified then we will create a 
            new figure with this as the only axis.
        figsize : 2-tuple
            Size of the figure
        legend : bool
            If True, add a legend
    
    Returns
    -------
    matplotlib.pyplot.Axes
    ''' 
    # Type checking
    if not issubject(subj):
        raise ValueError('`subj` ({}) must be a pylab.base.Subject'.format(type(subj)))
    if not util.isbool(drop_nan_taxa):
        raise ValueError('`drop_nan_taxa` ({}) must be a bool'.format(
            type(drop_nan_taxa)))
    if not util.isbool(legend):
        raise ValueError('`legend` ({}) must be a bool'.format(type(legend)))
    taxlevel = _set_taxlevel(taxlevel)

    if plot_abundant is not None:
        if not util.isint(plot_abundant):
            raise TypeError('`plot_abundant` ({}) must be an int'.format(
                type(plot_abundant)))
        if plot_abundant == 0:
            raise ValueError('`plot_abundant` cannot be zero')

    if 'title' not in kwargs:
        kwargs['title'] = 'Taxonomic Distribution, {} level'.format(taxlevel.capitalize())
    if 'xlabel' not in kwargs:
        kwargs['xlabel'] = 'Days'
    if 'ylabel' not in kwargs:
        kwargs['ylabel'] = 'Relative Abundance'

    ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
    if len(kwargs) != 0:
        raise ValueError('Arguemnts {} not recognized'.format(list(kwargs.keys())))
    df = subj.cluster_by_taxlevel(dtype='rel', drop_nan_taxa=drop_nan_taxa, taxlevel=taxlevel, 
        index_formatter=label_formatter)

    if plot_abundant is not None:
        matrix = df.values
        abnds = np.sum(matrix, axis=1)
        if plot_abundant < 0:
            plot_abundant *= -1
            idxs = np.argsort(abnds)[:plot_abundant]
        else:
            idxs = np.argsort(abnds)[-plot_abundant:]
        df = df.iloc[idxs, :]

        # Add everything else as 'Everything else'
        vals = []
        for col in df.columns:
            vals.append(1 - df[col].sum())
        df2 = pandas.DataFrame([vals], columns=df.columns, index=['Other'])
        df = df.append(df2)
        
        

    ax = df.T.plot(ax=ax, kind='bar', stacked=True)

    if legend:
        # handles, labels = ax.get_legend_handles_labels()
        # Reverse the inferit order of the legend so it matches the graph
        # ax.legend(handles[::-1], labels[::-1], bbox_to_anchor=(1,1))
        ax.legend(bbox_to_anchor=(1,1))

    # ax = _set_xticks(ax)
    return ax

# ---------------
# INNER FUNCTIONS
# ---------------
def _is_just_zero_or_nan(matrix):
    '''Returns True if the input matrix has only zero or only NaNs

    Parameters
    ----------
    matrix : np.ndarray(n,n)
        - Square matrix

    Returns
    -------
    bool
        True if `matrix` has only 0s or `np.nan`s
    '''
    matrix = np.asarray(matrix)
    for i in range(matrix.shape[0]):
        for j in range(matrix.shape[1]):
            if not (matrix[i,j] == 0 or np.isnan(matrix[i,j])):
                return False
    return True

def _format_ticklabel(format, order, otus):
    '''Format the xtick labels witha  slightly different format than that in 
    `pylab.util.otuname_formatter`: Overrides the %(index)s to be where it appears 
    in the local order, not the global order

    Parameters
    ----------
    format : str
        - This is the format to make the ticklabel for each OTU. The format can be 
          seen in `pylab.util.otuname_formatter`.
    order : array_like
        - This is the list of the OTU indices in the order that they should appear.
    otus : pylab.base.OTUSet
        - This is where all the information is stored for the OTUs

    Returns
    -------
    list(str)
        - These are the list of strings that are the labels for the ticks

    See also
    --------
    pylab.util.otuname_formatter
    '''
    ticklabels =[]

    for num, idx in enumerate(order):
        fmt = format.replace('%(index)s', str(num))
        label = util.otuname_formatter(format=fmt, otu=idx, otus=otus)
        ticklabels.append(label)
    return ticklabels

def _set_heatmap_default_args(linewidths=None, linecolor=None, n_colors=None, xticklabels=None,
    yticklabels=None, include_colorbar=None, include_tick_marks=None):
    '''Sets the defaults of the above parameters if they are None.

    Parameters
    ----------
    linewidths : float
        How wide the lines should be on a heatmap
    linecolor : str
        What color the lines should be on the heatmap
    n_colors : int
        How many colors to make the palette with
    xticklabels : str
        Label format on the x-axis of the heatmap
    yticklabels : str
        Label format on the y-axis of the heatmap
    include_colorbar : bool
        If True, includes the colorbar on the Axes render
    include_tick_marks : bool
        If True includes the tickmarks along the perimeter of the axis
    
    Returns
    -------
    dict
        Dictionary of all the values
    '''
    if linewidths is None:
        linewidths = DEFAULT_LINEWIDTHS
    if linecolor is None:
        linecolor = DEFAULT_LINECOLOR
    if n_colors is None:
        n_colors = DEFAULT_N_COLORS
    if xticklabels is None:
        xticklabels = DEFAULT_XTICKLABELS
    if yticklabels is None:
        yticklabels = DEFAULT_YTICKLABELS
    if include_colorbar is None:
        include_colorbar = DEFAULT_INCLUDE_COLORBAR
    if include_tick_marks is None:
        include_tick_marks = DEFAULT_INCLUDE_TICK_MARKS

    return {'linewidths': linewidths, 'linecolor': linecolor, 'n_colors': n_colors, 
        'xticklabels': xticklabels, 'yticklabels': yticklabels, 
        'include_colorbar': include_colorbar, 'include_tick_marks': include_tick_marks}

def _init_parameters_heatmap(matrix, otus, clustering, xticklabels, yticklabels, ax, figure_size,
    linewidths, order):
    '''Checks if the parameters are initialized correctly for the standard arguments
    for `render_interaction_strength`, `render_cocluster_proportions`, and
    `render_bayes_factors`.

    Parameters
    ----------
    matrix : array_like (2-dimensional)
        - 2D matrix that can be casted to a numpy ndarray
    otus : pylab.Base.OTUSet
        - This is the OTUSet that contains all of the information about the OTUs
    clustering : pylab.cluster.Clustering
        - This is the clustering object that tells the assignments for each of the OTUs
    xticklables, yticklables : str, array_like
        - These are either the string formats to make each of the labels or they are 
          the actual labels for each of the entries for the horizontal or vertical axis
    ax : matplotlib.pyplot.Axes, None
        - This is the Axis to plot on. If nothing is provided then a Figure and an Axis
          object will be created
    figure_size : 2-tuple(numeric, numeric), None
        - This is the size to create the figure. If nothing is provided it will be
          automatically set based on the number of OTUs
    linewidths : numeric
        - If the number of OTUs exceeds a certain number (75), it will automatically set 
          the linewidths to 0
    order : array_like, None
        - This is the order to set for the OTUs. The order has the OTU identifier (name, index, 
          id, etc.) for each OTU. If None then it does it by the order of the OTUs or by the 
          clustering object.
    Returns
    -------
    dict
        'matrix'
            - This is the input matrix, reorganized if necessary
        'xticklabels'
            - These are the labels for the horizontal axis based on the input format, if 
              necessary
        'yticklabels'
            - These are the labels for the vertical axis based on the input format, if 
              necessary
        'ax'
            - This is the matplotlib.pyplot.Axes object that has the appropriate scaled 
              size
        'fig'
            - This is the matplotlib.pyplot.Figure object that is associated with `ax`
        'cbar_kws'
            - These are the colobar arguments, if any
        'linewidths'
            - These are the linewidths for the rendering
    '''
    # Type checking
    matrix = np.asarray(matrix, dtype=float)
    if matrix.ndim != 2:
        raise ValueError('`matrix` ({}) must be 2 dimensions'.format(
            matrix.ndim))
    if matrix.shape[0] != matrix.shape[1]:
        raise ValueError('`matrix` ({}) must be square'.format(
            matrix.shape))
    if not isotuset(otus):
        raise ValueError('`otus` ({}) must be a subclass of pylab.data.OTUSet'.format(
            otus.__class__))
    if matrix.shape[0] != otus.n_otus:
        raise ValueError('The size of the interaction matrix ({}) must ' \
            'equal the number of OTUs in `otus` ({})'.format(
                matrix.shape[0], otus.n_otus))
    if clustering is not None:
        if not isclustering(clustering):
            raise ValueError('`clustering` ({}) must be a subclass of ' \
                'pylab.cluster.ClusteringBase'.format(clustering.__class__))
    if not (xticklabels is None or type(xticklabels) == str or util.isarray(xticklabels)):
        raise ValueError('xticklabels ({}) must either be None, str, or a list/np.ndarray' \
            ''.format(type(xticklabels)))
    if type(xticklabels) == list or type(xticklabels) == np.ndarray:
        if len(xticklabels) != otus.n_otus:
            raise ValueError('If xticklabels is a list, the length ({}) must ' \
                'be equal to the number of otus ({})'.format(len(xticklabels), otus.n_otus))
    if not (yticklabels is None or type(yticklabels) == str or type(yticklabels) == list \
        or type(yticklabels) == np.ndarray):
        raise ValueError('yticklabels ({}) must either be None, str, or a list/np.ndarray' \
            ''.format(type(yticklabels)))
    if type(yticklabels) == list or type(yticklabels) == np.ndarray:
        if len(yticklabels) != otus.n_otus:
            raise ValueError('If yticklabels is a list, the length ({}) must ' \
                'be equal to the number of otus ({})'.format(len(yticklabels), otus.n_otus))
    if order is not None:
        if not util.isarray(order):
            raise TypeError('`order` ({}) if specified must be an array'.format(type(order)))
        if len(order) != len(otus):
            raise TypeError('`order` ({}) must be {} elements'.format(len(order), len(otus)))
        for i in order:
            if i not in otus:
                raise IndexError('OTU identifier ({}) not found in OTUs'.format(i))

    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(1,1,1)

        # Set figure size
        if figure_size is None:
            # For each 50 OTUs add 10 inches to each dimension
            x = math.ceil(len(otus)/50)
            l = int(10*x)
            figure_size = (l,l)
        fig.set_size_inches(*figure_size)
    else:
        fig = plt.gcf()

    # Make otu order based on clusters if necessary
    if order is not None:
        temp = []
        for oidx in order:
            temp.append(otus[oidx].idx)
        order = temp
    elif clustering is not None:
        # get the index order
        reordered_idxs = []
        for cid in clustering.clusters:
            for oidx in clustering.clusters[cid].members:
                reordered_idxs.append(oidx)
        order = reordered_idxs
    else:
        order = np.arange(len(otus))

    # reorganize
    temp = np.zeros(shape=matrix.shape, dtype=float)
    for i in range(temp.shape[0]):
        for j in range(temp.shape[1]):
            temp[i,j] = matrix[
                order[i],
                order[j]]
    matrix = temp
        
    if xticklabels is None:
        xticklabels = False
    if yticklabels is None:
        yticklabels = False
    if type(xticklabels) == str:
        xticklabels = _format_ticklabel(format=xticklabels, order=order, otus=otus)
    if type(yticklabels) == str:
        yticklabels = _format_ticklabel(format=yticklabels, order=order, otus=otus)
    if len(otus) > 75:
        linewidths = 0

    return {'matrix':matrix, 'xticklabels':xticklabels, 'yticklabels':yticklabels,
        'ax':ax, 'fig':fig, 'cbar_kws': None, 'linewidths':linewidths}

def _set_plt_labels(d, ax=None):
    '''Removes labels form the dictionay and puts it in
    a new dictionary. This is useful so that we can pass
    **kwargs into matplotlib functions without throwing
    errors.

    Parameters
    ----------
    d : dict
        - This is a dictionary of arguements that contains arguments both
          for matplotlib.pyplot.Axes objects and that are not
    ax : matplotlib.pyplot.Axes
        - Object that we are plotting on.

    Returns
    -------
    dict
        This is an augmented dictionary form the input that removes the labels that 
        were used for Axes object
    '''
    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111)

    labels = {}
    for ele in _plt_labels:
        if ele in d:
            labels[ele] = d[ele]
            d.pop(ele, None)

    if PLT_TITLE_LABEL in labels:
        ax.set_title(labels[PLT_TITLE_LABEL])
    if PLT_XLABEL_LABEL in labels:
        ax.set_xlabel(labels[PLT_XLABEL_LABEL])
    if PLT_YLABEL_LABEL in labels:
        ax.set_ylabel(labels[PLT_YLABEL_LABEL])
    return ax, d

def _set_xticks(ax):

    loc = plticker.MultipleLocator(base=XTICK_FREQUENCY)
    ax.xaxis.set_major_locator(loc)
    return ax

def _set_taxlevel(taxlevel):
    if taxlevel == 'default':
        taxlevel = DEFAULT_TAX_LEVEL
    if taxlevel is None:
        taxlevel = 'otu'
    elif not util.isstr(taxlevel):
        raise ValueError('`taxlevel` ({}) must be a str'.format(type(taxlevel)))
    elif taxlevel not in ['kingdom', 'phylum', 'class', 
        'order', 'family', 'genus', 'otu']:
        raise ValueError('taxlevel ({}) not recognized'.format(taxlevel))
    return taxlevel

def _set_default_matplotlib_params(ax=None, title=None, xlabel=None, ylabel=None, figsize=None):
    '''Sets standard stuff with plotting and matplotlib

    Parameters
    ----------
    ax : matplotlib.pyplot.Axes, None
        Axes we are plotting on. If None we make a new one
    title : str
        Title to set or the Axes. If None we do not make a title
    xlabel, ylabel : str
        Label for the x and y axis. If None we do not make any
    figsize : 2-tuple
        Only necessary is `ax` is `None`. This is the size of the figure

    Returns
    -------
    matplotlib.pyplot.Axes
    '''
    if ax is None:
        if figsize is None:
            fig = plt.figure()
        else:
            fig = plt.figure(figsize=figsize)
        ax = fig.add_subplot(111)

    if title is not None:
        ax.set_title(title)
    if xlabel is not None:
        ax.set_xlabel(xlabel)
    if ylabel is not None:
        ax.set_ylabel(ylabel)
    return ax
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_ACCEPTANCE_RATE_PREV" class="name">var <span class="ident">DEFAULT_ACCEPTANCE_RATE_PREV</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_INCLUDE_COLORBAR" class="name">var <span class="ident">DEFAULT_INCLUDE_COLORBAR</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_INCLUDE_TICK_MARKS" class="name">var <span class="ident">DEFAULT_INCLUDE_TICK_MARKS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_LINECOLOR" class="name">var <span class="ident">DEFAULT_LINECOLOR</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_LINEWIDTHS" class="name">var <span class="ident">DEFAULT_LINEWIDTHS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_MAX_BAYES_FACTOR" class="name">var <span class="ident">DEFAULT_MAX_BAYES_FACTOR</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_N_COLORS" class="name">var <span class="ident">DEFAULT_N_COLORS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_PLT_TYPE" class="name">var <span class="ident">DEFAULT_PLT_TYPE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_SNS_CMAP" class="name">var <span class="ident">DEFAULT_SNS_CMAP</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_TAX_LEVEL" class="name">var <span class="ident">DEFAULT_TAX_LEVEL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_TRACE_COLOR" class="name">var <span class="ident">DEFAULT_TRACE_COLOR</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_XTICKLABELS" class="name">var <span class="ident">DEFAULT_XTICKLABELS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.DEFAULT_YTICKLABELS" class="name">var <span class="ident">DEFAULT_YTICKLABELS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.PERTURBATION_COLOR" class="name">var <span class="ident">PERTURBATION_COLOR</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.PLT_TITLE_LABEL" class="name">var <span class="ident">PLT_TITLE_LABEL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.PLT_XLABEL_LABEL" class="name">var <span class="ident">PLT_XLABEL_LABEL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.PLT_YLABEL_LABEL" class="name">var <span class="ident">PLT_YLABEL_LABEL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.visualization.XTICK_FREQUENCY" class="name">var <span class="ident">XTICK_FREQUENCY</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pylab.visualization.abundance_over_time">
    <p>def <span class="ident">abundance_over_time</span>(</p><p>subj, dtype, taxlevel=None, drop_nan_taxa=False, yscale_log=None, plot_abundant=None, plot_specific=None, plot_clusters=None, highlight=None, marker=&#39;o&#39;, ylim=None, markersize=4, shade_perturbations=True, legend=True, set_0_to_nan=False, color_code_clusters=False, clustering=None, cmap=None, alpha=1.0, linestyle=&#39;-&#39;, ax=None, include_errorbars=False, grid=False, label_formatter=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Plots the abundance over time for the OTUs in <code>subj</code>.</p>
<h2>What you're plotting</h2>
<p>There are several different types of abundances you can plot, which is specified using
the <code>dtype</code> (str) parameter:
'raw'
    This plots the counts of the OTUs. <code>subj</code> must be a single pl.base.Subject object.
'rel'
    This plots the relative abundance of the OTUs. <code>subj</code> must be a single 
    pl.base.Subject object.
'abs'
    This plots the absolute abundance of the OTUs. <code>subj</code> must be a single 
    pl.base.Subject object.
'qpcr'
    This plots the qPCR measurements at each time point. <code>subj</code> can also be a 
    list of pl.base.Subject objects, or a <code>pl.base.SubjectSet</code> object.
'read-depth'
    These are the the read depths at each timepoint. <code>subj</code> can also be a 
    list of pl.base.Subject objects, or a <code>pl.base.SubjectSet</code> object.</p>
<h2>Aggregating by taxanomic level</h2>
<p>If the taxonomy of the OTUs are specified, you can aggregate OTUs into specific 
taxonomic levels and plot them as a trajectory by using the parameter <code>taxlevel</code>.
Example: if <code>taxlevel='phylum'</code> then we add all of the abundances/reads of the OTUs
that are in the same Phylum. If <code>taxlevel=None</code> then we do no aggregation. If you 
set <code>taxlevel='default'</code> then it aggregates at the default taxonomic level, which 
can be set using the function <code>plotting.set_default_tax_level(level)</code>. NOTE: these 
are only necessary if dtype is either 'raw', 're', or 'abs'.</p>
<p>The <code>label_formatter</code> (str) tells the function how to set the index of the dataframe
it returns using <code>pylab.util.otuname_formatter</code>. If nothing is specified then it 
will return the entire taxonomy as a label for the taxa. NOTE, you cannot specifiy
a taxonomy <em>below</em> that youre clustering at. For example, you cannot cluster at the 
'class' level and then specify <code>'%(genus)s'</code> in <code>label_formatter</code>.</p>
<h2>What to plot?</h2>
<p>You can plot a subset of the OTUs by using the <code>plot_</code> arguments. If None of those
parameters are specified, then it will plot everything. NOTE: You can only specify 
one of the <code>plot_</code> at a time. NOTE: these are only necessary if dtype is either 
'raw', 're', or 'abs'.</p>
<p>plot_abundant : int
If you want to only plot the x most abundant OTUs, specify that number 
with <code>plot_abundant</code> (<code>int</code>) as a positive number. Example: <code>plot_abundant = 15</code> will
only plot the 15 most abundant. If <code>plot_abundant</code> is a negative number, it will
plot the least abundant. Example: <code>plot_abundant = -15</code> will only plot the 15 least 
abundant. </p>
<p>plot_specific : list
If you want to only plot specific OTUs, you can specify them by any identification
(index, name, ID, etc.) as a list of OTUs to plot.
NOTE: If you specify <code>plot_specific</code> and you are clustering along a taxonomic level, then
you specify the names at the taxonomic level you clustered at.
Example::
    If taxlevel = 'phylum'
    VALID: plot_specific = [('Bacteria', 'Bacteroidetes'), ('Bacteria', 'Firmicutes')]
    INVALID: plot_specific = ['Bacteroidetes', 'Firmicutes'] # Need full taxonomy
    INVALID: plot_specific = ['Bacteroidia', 'Clostridia'] # This is at the class level
    INVALID: plot_specific = ['OTU_32'] # These names are no longer valid</p>
<p>plot_clusters : list(int), int
If you want to plot specific clusters (or a single cluster), you can specify the cluster
ID/s to plot. Note that you must also specify the <code>clustering</code> parameter as well and you
cannot aggregate the data into taxonomic classes.</p>
<h2>Log-scale and NaN's</h2>
<p>We will automatically plot the yscale as log for the 'raw' and 'abs' 
datatypes and regular for 'rel'. If you want to do something different
then set the <code>yscale_log</code> parameter.</p>
<p>If you want to NaN out all of the points that have a zero abundance so that there are not
vertical lines everywhere, use parameter <code>set_0_to_nan</code> to True</p>
<h2>Parameters</h2>
<p>subj : pylab.base.Subject, pylab.base.SubjectSet, list(pylab.base.Subject)
    Subject/s we are getting the data from. Must be a single object if 
    <code>dtype</code> is 'raw', 'rel', or 'abs'. Must be multiple or single object.
    If <code>dtype</code> is 'qpcr' or 'read-depth', then this can also be a list of 
    Subject objects or a SubjectSet object,
dtype : str
    Datatype to plot.
        'raw': Count data
        'rel': Relative abundance
        'abs': Absolute abudance 
        'qpcr': qPCR measurements
        'read-depth': read depths
taxlevel : str, None
    This is the taxa level to aggregate the data at. If 'default' is specified
    then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
drop_nan_taxa : bool
    If True, it will not plot taxas that are not specified (NaNs). If False, it
    will conglomerate all the taxas into a single category called 'Unclassified'
yscale : bool, None
    If True, it will plot the y-axis in log scale. If nothing is specified then it 
    will pick it automatically.
plot_abundant : int, None
    If specified, it will plot only this number most abundant OTUs
plot_specific : array_like, None
    If specified, it will only plot the OTUs specified indicated in here. Else
    it will plot everything
plot_clusters : array_like, None
    If specified, only plots the clusters specified. Note that the <code>clustering</code> parameter
    must also be specified
highlight : list(float), None
    These are a list of tuples (otu, timepoint) we want to highlight (circle). 
    Each element must be a time in <code>subj.times</code>. If nothing is specified then we do not
    circle anything
ylim : 2-tuple, Optional
    Sets lower and upper bounds for the y-axis. 
marker : str
    Type of marker to have on the plot
markersize : numeric
    How big to make the marker
legend : bool
    If True, add a legend
shade_perturbations : bool
    If True, shade in the perturbations
color_code_clusters : bool
    If True, set all of the OTUs in a cluster to the same color. Note that the <code>clustering</code> 
    parameter must also be specified. NOTE: if you are aggregating the data at a taxonomic 
    level (taxlevel is not None or 'otu'), then this is automatically overridden to False.
    If specified, it overrides the legend to False.
clustering : pylab.cluster.Clustering
    Clustering object. Only necessary if <code>plot_clusters</code> or <code>color_code_clusters</code> are specified
cmap : str
    This is the colormap to use. It uses <code>seaborn.color_palette</code> to generate the 
    colormap and <code>camp</code> is which colormap to use. Default (None) is <code>DEFAULT_SNS_CMAP</code>.
alpha : float
    How dark to make the line. Default is 1.0
linestyle : str
    Linestyle for matplotlib. The type is not checked with this because it is checked 
    within matplotlib
include_errorbars : bool
    If True, we include the errorbars (standard deviation) for each point. This is only
    used if <code>dtype</code> == 'qpcr'
highlight : list(2-tuple), None
    If this is specified, this highlights the points specified in the 2-tuple:
    (subject ID, timepoint). This is only used if <code>dtype</code> == 'qpcr' or 'read-depth'
grid : bool
    If True, plots with a grid
kwargs : dict
    xlabel, ylabel, title : str
        Default 'title' is the type of alpha diversity and the level
    ax : matplotlib.pyplot.Axes, None
        This is the axis to plot on. If nothing is specified then we will create a 
        new figure with this as the only axis.
    figsize : 2-tuple
        Size of the figure</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.abundance_over_time', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.abundance_over_time" class="source">
    <pre><code>def abundance_over_time(subj, dtype, taxlevel=None, drop_nan_taxa=False, yscale_log=None,
    plot_abundant=None, plot_specific=None, plot_clusters=None, highlight=None, marker='o',
    ylim=None, markersize=4, shade_perturbations=True, legend=True, set_0_to_nan=False, 
    color_code_clusters=False, clustering=None, cmap=None, alpha=1.0, linestyle='-', ax=None,
    include_errorbars=False, grid=False, label_formatter=None, **kwargs):
    '''Plots the abundance over time for the OTUs in `subj`.

    What you're plotting
    --------------------
    There are several different types of abundances you can plot, which is specified using
    the `dtype` (str) parameter:
    'raw'
        This plots the counts of the OTUs. `subj` must be a single pl.base.Subject object.
    'rel'
        This plots the relative abundance of the OTUs. `subj` must be a single 
        pl.base.Subject object.
    'abs'
        This plots the absolute abundance of the OTUs. `subj` must be a single 
        pl.base.Subject object.
    'qpcr'
        This plots the qPCR measurements at each time point. `subj` can also be a 
        list of pl.base.Subject objects, or a `pl.base.SubjectSet` object.
    'read-depth'
        These are the the read depths at each timepoint. `subj` can also be a 
        list of pl.base.Subject objects, or a `pl.base.SubjectSet` object.
    
    Aggregating by taxanomic level
    ------------------------------
    If the taxonomy of the OTUs are specified, you can aggregate OTUs into specific 
    taxonomic levels and plot them as a trajectory by using the parameter `taxlevel`.
    Example: if `taxlevel='phylum'` then we add all of the abundances/reads of the OTUs
    that are in the same Phylum. If `taxlevel=None` then we do no aggregation. If you 
    set `taxlevel='default'` then it aggregates at the default taxonomic level, which 
    can be set using the function `plotting.set_default_tax_level(level)`. NOTE: these 
    are only necessary if dtype is either 'raw', 're', or 'abs'.

    The `label_formatter` (str) tells the function how to set the index of the dataframe
    it returns using `pylab.util.otuname_formatter`. If nothing is specified then it 
    will return the entire taxonomy as a label for the taxa. NOTE, you cannot specifiy
    a taxonomy *below* that youre clustering at. For example, you cannot cluster at the 
    'class' level and then specify `'%(genus)s'` in `label_formatter`.

    What to plot?
    -------------
    You can plot a subset of the OTUs by using the `plot_` arguments. If None of those
    parameters are specified, then it will plot everything. NOTE: You can only specify 
    one of the `plot_` at a time. NOTE: these are only necessary if dtype is either 
    'raw', 're', or 'abs'.

    plot_abundant : int
    If you want to only plot the x most abundant OTUs, specify that number 
    with `plot_abundant` (`int`) as a positive number. Example: `plot_abundant = 15` will
    only plot the 15 most abundant. If `plot_abundant` is a negative number, it will
    plot the least abundant. Example: `plot_abundant = -15` will only plot the 15 least 
    abundant. 
    
    plot_specific : list
    If you want to only plot specific OTUs, you can specify them by any identification
    (index, name, ID, etc.) as a list of OTUs to plot.
    NOTE: If you specify `plot_specific` and you are clustering along a taxonomic level, then
    you specify the names at the taxonomic level you clustered at.
    Example::
        If taxlevel = 'phylum'
        VALID: plot_specific = [('Bacteria', 'Bacteroidetes'), ('Bacteria', 'Firmicutes')]
        INVALID: plot_specific = ['Bacteroidetes', 'Firmicutes'] # Need full taxonomy
        INVALID: plot_specific = ['Bacteroidia', 'Clostridia'] # This is at the class level
        INVALID: plot_specific = ['OTU_32'] # These names are no longer valid

    plot_clusters : list(int), int
    If you want to plot specific clusters (or a single cluster), you can specify the cluster
    ID/s to plot. Note that you must also specify the `clustering` parameter as well and you
    cannot aggregate the data into taxonomic classes.

    Log-scale and NaN's
    -------------------
    We will automatically plot the yscale as log for the 'raw' and 'abs' 
    datatypes and regular for 'rel'. If you want to do something different
    then set the `yscale_log` parameter.

    If you want to NaN out all of the points that have a zero abundance so that there are not
    vertical lines everywhere, use parameter `set_0_to_nan` to True

    Parameters
    ----------
    subj : pylab.base.Subject, pylab.base.SubjectSet, list(pylab.base.Subject)
        Subject/s we are getting the data from. Must be a single object if 
        `dtype` is 'raw', 'rel', or 'abs'. Must be multiple or single object.
        If `dtype` is 'qpcr' or 'read-depth', then this can also be a list of 
        Subject objects or a SubjectSet object,
    dtype : str
        Datatype to plot.
            'raw': Count data
            'rel': Relative abundance
            'abs': Absolute abudance 
            'qpcr': qPCR measurements
            'read-depth': read depths
    taxlevel : str, None
        This is the taxa level to aggregate the data at. If 'default' is specified
        then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
    drop_nan_taxa : bool
        If True, it will not plot taxas that are not specified (NaNs). If False, it
        will conglomerate all the taxas into a single category called 'Unclassified'
    yscale : bool, None
        If True, it will plot the y-axis in log scale. If nothing is specified then it 
        will pick it automatically.
    plot_abundant : int, None
        If specified, it will plot only this number most abundant OTUs
    plot_specific : array_like, None
        If specified, it will only plot the OTUs specified indicated in here. Else
        it will plot everything
    plot_clusters : array_like, None
        If specified, only plots the clusters specified. Note that the `clustering` parameter
        must also be specified
    highlight : list(float), None
        These are a list of tuples (otu, timepoint) we want to highlight (circle). 
        Each element must be a time in `subj.times`. If nothing is specified then we do not
        circle anything
    ylim : 2-tuple, Optional
        Sets lower and upper bounds for the y-axis. 
    marker : str
        Type of marker to have on the plot
    markersize : numeric
        How big to make the marker
    legend : bool
        If True, add a legend
    shade_perturbations : bool
        If True, shade in the perturbations
    color_code_clusters : bool
        If True, set all of the OTUs in a cluster to the same color. Note that the `clustering` 
        parameter must also be specified. NOTE: if you are aggregating the data at a taxonomic 
        level (taxlevel is not None or 'otu'), then this is automatically overridden to False.
        If specified, it overrides the legend to False.
    clustering : pylab.cluster.Clustering
        Clustering object. Only necessary if `plot_clusters` or `color_code_clusters` are specified
    cmap : str
        This is the colormap to use. It uses `seaborn.color_palette` to generate the 
        colormap and `camp` is which colormap to use. Default (None) is `DEFAULT_SNS_CMAP`.
    alpha : float
        How dark to make the line. Default is 1.0
    linestyle : str
        Linestyle for matplotlib. The type is not checked with this because it is checked 
        within matplotlib
    include_errorbars : bool
        If True, we include the errorbars (standard deviation) for each point. This is only
        used if `dtype` == 'qpcr'
    highlight : list(2-tuple), None
        If this is specified, this highlights the points specified in the 2-tuple:
        (subject ID, timepoint). This is only used if `dtype` == 'qpcr' or 'read-depth'
    grid : bool
        If True, plots with a grid
    kwargs : dict
        xlabel, ylabel, title : str
            Default 'title' is the type of alpha diversity and the level
        ax : matplotlib.pyplot.Axes, None
            This is the axis to plot on. If nothing is specified then we will create a 
            new figure with this as the only axis.
        figsize : 2-tuple
            Size of the figure

    Returns
    -------
    matplotlib.pyplot.Axes
    '''
    # Type checking
    taxlevel = _set_taxlevel(taxlevel)
    if not util.isstr(dtype):
        raise TypeError('`dtype` ({}) must be a str'.format(type(dtype)))
    if dtype not in ['raw', 'rel', 'abs', 'qpcr', 'read-depth']:
        raise TypeError('`dtype` ({}) not recognized'.format(dtype))
    if dtype == 'qpcr':
        if not util.isbool(include_errorbars):
            raise ValueError('`include_errorbars ({}) must be a bool'.format(type(include_errorbars)))
    if not util.isbool(grid):
        raise TypeError('`grid` ({}) must be a bool'.format(type(grid)))
    if not issubject(subj):
        if dtype not in ['qpcr', 'read-depth']:
            raise TypeError('`subj` ({}) must be a pylab.base.Subject'.format(type(subj)))
        else:
            if util.isarray(subj):
                for s in subj:
                    if not issubject(s):
                        raise TypeError('Every element in `subj` ({}) must be a ' \
                            'pl.base.Subject'.format(type(s)))
            if not issubjectset(subj):
                raise TypeError('`subj` ({}) type not recognized'.format(type(subj)))
    if not util.isbool(drop_nan_taxa):
        raise TypeError('`drop_nan_taxa` ({}) must be a bool'.format(
            type(drop_nan_taxa)))
    if yscale_log is None:
        if dtype == 'rel':
            yscale_log = False
        else:
            yscale_log = True
    if not util.isbool(yscale_log):
        raise TypeError('`yscale_log` ({}) must be a bool'.format(
            type(yscale_log)))
    if not util.isbool(shade_perturbations):
        raise TypeError('`shade_perturbations` ({}) must be a bool'.format(
            type(shade_perturbations)))
    if not util.isbool(legend):
        raise TypeError('If `legend` ({}) is specified, it must be a bool'.format(
            type(legend)))
    if not util.isbool(set_0_to_nan):
        raise TypeError('`set_0_to_nan` ({}) must be a bool'.format(type(set_0_to_nan)))
    if clustering is not None:
        if not isclustering(clustering):
            raise TypeError('`clustering` ({}) must be a pylab.cluster.Clustering' \
                ' object if specified'.format(type(clustering)))
    if color_code_clusters and clustering is None:
        raise ValueError('If `color_code_clusters` is True, `clustering` must also' \
            ' be specified')
    if cmap is None:
        cmap = DEFAULT_SNS_CMAP
    elif not util.isstr(cmap):
        raise TypeError('`cmap` ({}) must either be None or a str'.format(type(cmap)))
    if dtype in ['raw', 'rel', 'abs']:
        if plot_abundant is not None:
            if not util.isint(plot_abundant):
                raise TypeError('`plot_abundant` ({}) must be an int'.format(
                    type(plot_abundant)))
            if plot_abundant == 0:
                raise ValueError('`plot_abundant` cannot be zero')
        if plot_specific is not None:
            if not util.isarray(plot_specific):
                plot_specific = [plot_specific]
        if util.isint(plot_clusters):
            plot_clusters = [plot_clusters]
        if plot_clusters is not None:
            if not util.isarray(plot_clusters):
                raise TypeError('If `plot_clusters` ({}) is specified, it must either be ' \
                    'an int or an array'.format(type(plot_clusters)))
            else:
                for ele in plot_clusters:
                    if not util.isint(ele):
                        raise TypeError('Every element in `plot_clusters` ({}) ({}) must ' \
                            'be an int'.format(plot_clusters,
                                util.itercheck(plot_clusters, util.isint)))
            if taxlevel != 'otu':
                raise ValueError('Cannot plot clusters (`plot_clusters` ({})) and aggregate by a' \
                    ' taxonomic level (`taxlevel` ({}))'.format(plot_clusters, taxlevel))            
            if not isclustering(clustering):
                raise ValueError('If `plot_clusters` is specified, then clustering ({}) must be ' \
                    'specified'.format(type(clustering)))
        if not util.isbool(color_code_clusters):
            raise TypeError('`color_code_clusters` ({}) must be a bool'.format(
                type(color_code_clusters)))
        if color_code_clusters:
            if taxlevel != 'otu':
                logging.warning('Overriding `color_code_clusters` to False because `taxlevel`' \
                    ' ({}) is not None nor "otu"'.format(taxlevel))
                color_code_clusters = False
            if legend:
                logging.warning('Overriding `legend` to False because `color_code_clusters` is True')
            legend = False

        _cumm = 0
        if plot_abundant is not None:
            _cumm += 1
        if plot_specific is not None:
            _cumm += 1
        if plot_clusters is not None:
            _cumm += 1
        if _cumm > 1:
            raise ValueError('Only one `plot_` parameter can be specified. You specified {}'.format(_cumm))

        df = subj.cluster_by_taxlevel(dtype=dtype, drop_nan_taxa=drop_nan_taxa, taxlevel=taxlevel,
            index_formatter=label_formatter)
        times = subj.times

        if 'title' not in kwargs:
            kwargs['title'] = 'Abundance, Subject {}, {} level'.format(subj.name, taxlevel)
        if 'xlabel' not in kwargs:
            kwargs['xlabel'] = 'Days'
        if 'ylabel' not in kwargs:
            if dtype == 'rel':
                kwargs['ylabel'] = 'Relative abundance'
            elif dtype == 'raw':
                kwargs['ylabel'] = 'Counts'
            else:
                kwargs['ylabel'] = 'CFUs/g'

        ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
        idxs = np.arange(len(df.index))
        if plot_specific is not None:
            for i in range(len(plot_specific)):
                if util.isint(plot_specific[i]):
                    plot_specific[i] = subj.otus[plot_specific[i]].name
                plot_specific[i] = plot_specific[i].replace("'",'') #.replace(' ','').lower()
            idxs = []
            for i in range(len(plot_specific)):
                valid=False
                for j in range(len(df.index)):
                    if df.index[j] == plot_specific[i]:
                        valid=True
                        idxs.append(j)
                        break
                if not valid:
                    logging.error('Name `{}` not found in OTUs'.format(plot_specific[i]))
        elif plot_abundant is not None:
            matrix = df.values
            abnds = np.sum(matrix, axis=1)
            if plot_abundant < 0:
                plot_abundant *= -1
                idxs = np.argsort(abnds)[:plot_abundant]
            else:
                idxs = np.argsort(abnds)[-plot_abundant:]

        elif plot_clusters is not None:
            idxs = []
            for cid in plot_clusters:
                idxs = np.append(idxs, list(clustering[cid].members))
            idxs = np.asarray(idxs, dtype=int)

        if color_code_clusters:
            colors = {}
            ccs = sns.color_palette(cmap, n_colors=len(clustering.clusters))
            for i, cluster in enumerate(clustering):
                for idx in cluster.members:
                    colors[idx] = ccs[i]
        else:
            ccs = sns.color_palette(cmap, n_colors=len(idxs))
            colors = {}
            for i,idx in enumerate(idxs):
                colors[idx] = ccs[i]

                
        for idx in idxs:
            label = df.index[idx]
            # Only get the last name of the entire taxonomy
            label = re.findall(r"([^,)(' ]+)",label)[-1]
            datapoints = np.asarray(list(df.iloc[idx]))
            if set_0_to_nan:
                for i,val in enumerate(datapoints):
                    if val == 0:
                        datapoints[i] = np.nan
            ax.plot(times, datapoints, label=label, marker=marker, color=colors[idx], 
                markersize=markersize, alpha=alpha, linestyle=linestyle)
        
        if highlight is not None:
            logging.warning('`highlight` is not implemented for dtype ({}). Skipping'.format(
                dtype))
    else:
        if dtype == 'qpcr':
            if 'title' not in kwargs:
                kwargs['title'] = 'qPCR over time'
            if 'xlabel' not in kwargs:
                kwargs['xlabel'] = 'Day'
            if 'ylabel' not in kwargs:
                kwargs['ylabel'] = 'CFUs/g'
        else:
            if 'title' not in kwargs:
                kwargs['title'] = 'Read depth over time'
            if 'xlabel' not in kwargs:
                kwargs['xlabel'] = 'Day'
            if 'ylabel' not in kwargs:
                kwargs['ylabel'] = 'Counts'
        ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
        if ylim is not None:
            ax.set_ylim(*ylim)
        if issubject(subj):
            subj = [subj]
        colors = sns.color_palette(cmap, n_colors=len(subj))
        
        for sidx, ss in enumerate(subj):
            subj_kwargs = {'label': ss.name, 'marker': marker,
                'color': colors[sidx], 'markersize': markersize, 
                'alpha': alpha, 'linestyle': linestyle}

            if dtype == 'qpcr':
                mean = np.zeros(len(ss.times))
                std = np.zeros(len(ss.times))
                for i, t in enumerate(ss.times):
                    mean[i] = ss.qpcr[t].mean
                    std[i] = ss.qpcr[t].std
                if not include_errorbars:
                    std = None
                ax.errorbar(ss.times, mean, yerr=std, **subj_kwargs)
            else:
                rds = []
                for t in ss.times:
                    rds.append(np.sum(ss.reads[t]))
                ax.plot(ss.times, rds, **subj_kwargs)
        
        # Check if there are any points to highlight
        if highlight is not None:
            for a in highlight:
                if type(a) != tuple:
                    raise ValueError('Each element in highlight must be a tuple ({})'.format(
                        type(a)))
                if len(a) != 2:
                    raise ValueError('The tuple must be length 2 ({})'.format(len(a)))
                
                subjname, timepoint = a
                ss = None
                for b in subj:
                    if b.name == subjname:
                        ss = b
                if ss is None:
                    raise ValueError('`subjname` ({}) not a valid subject name'.format(subjname))
                if not util.isnumeric(timepoint):
                    raise ValueError('invalid timepoint ({}) in `highlight`. ' \
                        'It must be a numeric'.format(type(timepoint)))
                if timepoint not in ss.times:
                    raise ValueError('timepoint ({}) not found in times ({})'.format(
                        timepoint, ss.times))
                if dtype == 'qpcr':
                    yy = ss.qpcr[timepoint].mean
                else:
                    yy = np.sum(ss.reads[timepoint])
                ax.scatter( 
                    [timepoint],
                    [yy],
                    s=140,
                    facecolor='None',
                    edgecolors='black',
                    zorder=100)

    # Set the other parameters for the plot
    if yscale_log:
        ax.set_yscale('log')
    ax = _set_xticks(ax)
    if shade_perturbations:
        if issubject(subj):
            perturbations = subj.parent.perturbations
        elif issubjectset(subj):
            perturbations = subj.perturbations
        else:
            # Else it is an array of subjsets
            perturbations = subj[0].parent.perturbations
        ax = shade_in_perturbations(ax, perturbations)

    if legend:
        ax.legend(bbox_to_anchor=(1,1))
    if ylim is not None:
        ax.set_ylim(*ylim)
    if grid:
        ax.grid()
    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.alpha_diversity_over_time">
    <p>def <span class="ident">alpha_diversity_over_time</span>(</p><p>subjs, metric, taxlevel=None, drop_nan_taxa=False, highlight=None, marker=&#39;o&#39;, markersize=4, shade_perturbations=True, legend=True, cmap=None, alpha=1.0, linestyle=&#39;-&#39;, ax=None, grid=False, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Plots the alpha diversity over time for the subject</p>
<h2>Parameters</h2>
<p>subjs : pylab.base.Subject, list(pylab.base.Subject)
    This is the subject that we are getting the data from, or a list of subjects
    we are doing together
metric : callable
    This is the function we want to calculate the alpha diversity with.
    This function usually comes from <code>diversity.alpha</code>
taxlevel : str, None
    This is the taxa level to aggregate the data at. If 'default' is specified
    then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
drop_nan_taxa : bool
    If True, it will not plot taxas that are not specified (NaNs). If False, it
    will conglomerate all the taxas into a single category called 'Unclassified'
highlight : list(float), None
    These are a list of tuples (subjectname, timepoint) we want to highlight (circle). 
    Each element must be a time in <code>subj.times</code>. If nothing is specified then we do not
    circle anything
marker : str
    Type of marker to have on the plot
markersize : numeric
    How big to make the marker
shade_perturbations : bool
    If True, shade in the perturbations
legend : bool
    If True, add a legend
cmap : str
    This is the colormap to use. It uses <code>seaborn.color_palette</code> to generate the 
    colormap and <code>camp</code> is which colormap to use. Default (None) is <code>DEFAULT_SNS_CMAP</code>.
alpha : float
    How dark to make the line. Default is 1.0
linestyle : str
    Linestyle for matplotlib. The type is not checked with this because it is checked 
    within matplotlib
kwargs : dict
    xlabel, ylabel, title : str
        Default 'title' is the type of alpha diversity and the level
    ax : matplotlib.pyplot.Axes, None
        This is the axis to plot on. If nothing is specified then we will create a 
        new figure with this as the only axis.
    figsize : 2-tuple
        Size of the figure
    legend : bool
        If True, add a legend</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.alpha_diversity_over_time', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.alpha_diversity_over_time" class="source">
    <pre><code>def alpha_diversity_over_time(subjs, metric, taxlevel=None, drop_nan_taxa=False, 
    highlight=None, marker='o', markersize=4, shade_perturbations=True, 
    legend=True, cmap=None, alpha=1.0, linestyle='-', ax=None, grid=False, **kwargs):
    '''Plots the alpha diversity over time for the subject

    Parameters
    ----------
    subjs : pylab.base.Subject, list(pylab.base.Subject)
        This is the subject that we are getting the data from, or a list of subjects
        we are doing together
    metric : callable
        This is the function we want to calculate the alpha diversity with.
        This function usually comes from `diversity.alpha`
    taxlevel : str, None
        This is the taxa level to aggregate the data at. If 'default' is specified
        then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
    drop_nan_taxa : bool
        If True, it will not plot taxas that are not specified (NaNs). If False, it
        will conglomerate all the taxas into a single category called 'Unclassified'
    highlight : list(float), None
        These are a list of tuples (subjectname, timepoint) we want to highlight (circle). 
        Each element must be a time in `subj.times`. If nothing is specified then we do not
        circle anything
    marker : str
        Type of marker to have on the plot
    markersize : numeric
        How big to make the marker
    shade_perturbations : bool
        If True, shade in the perturbations
    legend : bool
        If True, add a legend
    cmap : str
        This is the colormap to use. It uses `seaborn.color_palette` to generate the 
        colormap and `camp` is which colormap to use. Default (None) is `DEFAULT_SNS_CMAP`.
    alpha : float
        How dark to make the line. Default is 1.0
    linestyle : str
        Linestyle for matplotlib. The type is not checked with this because it is checked 
        within matplotlib
    kwargs : dict
        xlabel, ylabel, title : str
            Default 'title' is the type of alpha diversity and the level
        ax : matplotlib.pyplot.Axes, None
            This is the axis to plot on. If nothing is specified then we will create a 
            new figure with this as the only axis.
        figsize : 2-tuple
            Size of the figure
        legend : bool
            If True, add a legend
    
    Returns
    -------
    matplotlib.pyplot.Axes
    '''
    # Type checking
    if not util.isbool(grid):
        raise TypeError('`grid` ({}) must be a bool'.format(type(grid)))
    if issubject(subjs):
        subjs = [subjs]
    if not util.isarray(subjs):
        raise ValueError('`subjs` ({}) must be a pylab.base.Subject or an array'.format(type(subjs)))
    if not callable(metric):
        raise ValueError('`metric` ({}) must be callable'.format(type(metric)))
    if not util.isbool(drop_nan_taxa):
        raise ValueError('`drop_nan_taxa` ({}) must be a bool'.format(
            type(drop_nan_taxa)))
    if not util.isbool(shade_perturbations):
        raise ValueError('`shade_perturbations` ({}) must be a bool'.format(
            type(shade_perturbations)))
    if not util.isbool(legend):
        raise ValueError('If `legend` ({}) is specified, it must be a bool'.format(
            type(legend)))
    if cmap is None:
        cmap = DEFAULT_SNS_CMAP
    elif not util.isstr(cmap):
        raise TypeError('`cmap` ({}) must either be None or a str'.format(type(cmap)))

    if 'title' not in kwargs:
        kwargs['title'] = '{} over time, {} level'.format( 
            metric.__name__.capitalize(), taxlevel)
    if 'xlabel' not in kwargs:
        kwargs['xlabel'] = 'Day'
    ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
    taxlevel = _set_taxlevel(taxlevel)

    colors = sns.color_palette(cmap, n_colors=len(subjs))
    for sidx, subj in enumerate(subjs):
        df = subj.cluster_by_taxlevel(dtype='raw', drop_nan_taxa=drop_nan_taxa,
            taxlevel=taxlevel)

        # Calculate the alpha diversity over time and plot
        vals = np.zeros(len(df.columns))
        for i in range(len(vals)):
            vals[i] = metric(df.values[:,i])
        ax.plot(subj.times, vals, label=subj.name, marker=marker, markersize=markersize,
            color=colors[sidx], alpha=alpha, linestyle=linestyle)

    # Check if there are any points to highlight
    if highlight is not None:
        for a in highlight:
            if type(a) != tuple:
                raise ValueError('Each element in highlight must be a tuple ({})'.format(
                    type(a)))
            if len(a) != 2:
                raise ValueError('The tuple must be length 2 ({})'.format(len(a)))
            
            subjname, timepoint = a
            subj = None
            for b in subjs:
                if b.name == subjname:
                    subj = b
            if subj is None:
                raise ValueError('`subjname` ({}) not a valid subject name'.format(subjname))
            if not util.isnumeric(timepoint):
                raise ValueError('invalid timepoint ({}) in `highlight`. ' \
                    'It must be a numeric'.format(type(timepoint)))
            if timepoint not in subj.times:
                raise ValueError('timepoint ({}) not found in times ({})'.format(
                    timepoint, subj.times))
            tidx = np.searchsorted(subj.times, timepoint)
            ax.scatter( 
                [timepoint],
                [vals[tidx]],
                s=140,
                facecolor='None',
                edgecolors='black',
                zorder=100)

    ax = _set_xticks(ax)
    if shade_perturbations:
        ax = shade_in_perturbations(ax, subjs[0].parent.perturbations)
    if legend:
        ax.legend(bbox_to_anchor=(1,1))
    if grid:
        ax.grid()
    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.render_acceptance_rate_trace">
    <p>def <span class="ident">render_acceptance_rate_trace</span>(</p><p>var, prev=&#39;default&#39;, ax=None, include_burnin=True, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Visualize the acceptance rate over time for a
metropolis._BaseKernel object.</p>
<h2>Parameters</h2>
<p>var : array, subclass pylab.metropolis._BaseKernel
    - Array to do the trace on
    - If it is not a metropolis kernel then we automatically set
      <code>include_burnin</code> to False
prev : int, str, None, Optional
    - For each iteration, calculate the acceptance rate based on the previous <code>prev</code>
      iterations. If None, does it over the entire trace. If it is a str, the options
      are:
        'default': sets it to the default 
        'all': Same as None
ax : matplotlib.pyplot.Axes, Optional
    - Axes to plot on
    - If nothing is provided, a new figure with a single subplot
      will be created and returned
inlcude_burnin : bool, Optional
    - If True, it will plot the burnin trace as negative numbers
      in the trace as well
kwargs : dict, Optional
    - Optional arguments:
        - 'color' : str
            - Default color is 'blue'
        - 'alpha' : float
            - Default alpha is 0.5 for the trace
        - 'title' : str
            - Nothing
        - 'xlabel' : str
            - Default is 'Iteration'
        - 'ylabel' : str
            - Default is 'Acceptance Rate</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes
    - Axis object that contains the rendering of the acceptance rate</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.render_acceptance_rate_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.render_acceptance_rate_trace" class="source">
    <pre><code>def render_acceptance_rate_trace(var, prev='default', ax=None, include_burnin=True, **kwargs):
    '''Visualize the acceptance rate over time for a
    metropolis._BaseKernel object.

    Parameters
    ----------
    var : array, subclass pylab.metropolis._BaseKernel
        - Array to do the trace on
        - If it is not a metropolis kernel then we automatically set
          `include_burnin` to False
    prev : int, str, None, Optional
        - For each iteration, calculate the acceptance rate based on the previous `prev`
          iterations. If None, does it over the entire trace. If it is a str, the options
          are:
            'default': sets it to the default 
            'all': Same as None
    ax : matplotlib.pyplot.Axes, Optional
        - Axes to plot on
        - If nothing is provided, a new figure with a single subplot
          will be created and returned
    inlcude_burnin : bool, Optional
        - If True, it will plot the burnin trace as negative numbers
          in the trace as well
    kwargs : dict, Optional
        - Optional arguments:
            - 'color' : str
                - Default color is 'blue'
            - 'alpha' : float
                - Default alpha is 0.5 for the trace
            - 'title' : str
                - Nothing
            - 'xlabel' : str
                - Default is 'Iteration'
            - 'ylabel' : str
                - Default is 'Acceptance Rate

    Returns
    -------
    matplotlib.pyplot.Axes
        - Axis object that contains the rendering of the acceptance rate
    '''
    if util.isstr(prev):
        if prev == 'all':
            prev = float('inf')
        elif prev == 'default':
            prev = DEFAULT_ACCEPTANCE_RATE_PREV
        else:
            raise ValueError('str `default` ({}) not recognized'.format(prev))
    elif prev is None:
        prev = float('inf')
    elif not util.isint(prev):
        raise ValueError('`prev` ({}) must either be None or an int'.format(type(prev)))
    if not util.isbool(include_burnin):
        raise ValueError('`include_burnin` ({}) must be a bool'.format(type(include_burnin)))

    if util.isarray(var):
        logging.info('Overriding `include_burning` to False')
        trace = np.asarray(var)
        points = np.arange(len(trace))

    elif isVariable(var):
        trace = var.get_trace_from_disk()
        if include_burnin:
            burnin_trace = var.trace_from_disk(section='burnin')
            points = np.append(
                np.arange(-len(burnin_trace),0,1),
                np.arange(len(trace)))
            trace = np.append(burnin_trace, trace)
        else:
            points = np.arange(len(trace))
    else:
        raise ValueError('`var` ({}) must either an array or a metropolis Kernel'.format(
            type(var)))

    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111)
    # extract labels
    if 'xlabel' not in kwargs:
        kwargs['xlabel'] = 'Iteration'
    if 'ylabel' not in kwargs:
        kwargs['ylabel'] = 'Acceptance Rate'
    ax, kwargs = _set_plt_labels(kwargs, ax)

    # Calculate the acceptance rate overtime
    value = np.zeros(len(trace), dtype=float)
    for i in range(len(value)):
        if i <= prev:
            start = 0
        else:
            start = i - prev
        value[i] = acceptance_rate(var, start, i)

    if 'alpha' not in kwargs:
        kwargs['alpha'] = 0.5
    try:
        ax.plot(points, np.squeeze(value), **kwargs)
    except:
        logging.info('`ax.plot` failed. No points to plot')
    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.render_bayes_factors">
    <p>def <span class="ident">render_bayes_factors</span>(</p><p>bayes_factors, otus, clustering=None, ax=None, n_colors=None, max_value=None, xticklabels=None, yticklabels=None, include_tick_marks=None, linewidths=None, linecolor=None, cmap=None, include_colorbar=None, title=&#39;Microbe Interaction Bayes Factors&#39;, figure_size=None, order=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Renders the bayes factors for each of the interactions. Self interactions
are automatically set to np.nan.</p>
<h2>Parameters</h2>
<p>bayes_factors : 2-dim np.ndarray
    - Square matrix indicating the bayes factors of the interaction
otus (pylab.data.OTUSet)
    - This is the object that contains all of the OTU metadata
clustering : pylab.cluster.ClusteringBase, Optional
    - Clustering object if you want the OTUs in the same cluster to be grouped
      together
ax : matplotlib.pyplot.Axes, Optional
    - The axes to plot on. If nothing is provided a new figure will be created
n_colors : int, Optional
    - The number of colors to generate for the colormap.
max_value : float, int, Optional
    - Clips all of the values above this limit
    - If None, then there is no clipping
xticklabels, yticklabels : str, list, None, Optional
    - These are the labels for the x and y axis, respectively.
    - If it is a list then it must have <code>otus.n_otus</code> elements.
    - If it is a string, it is the formatter for each of the rows/columns.
    - If it is None, then do not make any ticklabels
include_tick_marks : bool, Optional
    - If True, include tick marks. If False get rid of them
linewidths : float, Optional
    - The width of the lines separating the squares
linecolor : str, Optional
    - The color of the lines separating the squares
cmap : colormap object, Optional
    - Overrides the default colormap. If specified, we ignore <code>n_colors</code>
include_colorbar : bool, Optional
    - If True, it will render the colorbar, if not then it wont.
title : str, None, Optional
    - Title of the figure
    - If None then do not put any title
figure_size : 2-tuple, Optional
    - This is the size of the figure (in inches)
    - If nothing is specified it will default to adding 10 inches in each
      dimension for every 50 OTUs</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes
    Axes object that has the image rendering on it</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.render_bayes_factors', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.render_bayes_factors" class="source">
    <pre><code>def render_bayes_factors(bayes_factors, otus, clustering=None, ax=None,
    n_colors=None, max_value=None, xticklabels=None, yticklabels=None,
    include_tick_marks=None, linewidths=None, linecolor=None,cmap=None,
    include_colorbar=None, title='Microbe Interaction Bayes Factors', figure_size=None,
    order=None):
    '''Renders the bayes factors for each of the interactions. Self interactions
    are automatically set to np.nan.

    Parameters
    ----------
    bayes_factors : 2-dim np.ndarray
        - Square matrix indicating the bayes factors of the interaction
    otus (pylab.data.OTUSet)
        - This is the object that contains all of the OTU metadata
    clustering : pylab.cluster.ClusteringBase, Optional
        - Clustering object if you want the OTUs in the same cluster to be grouped
          together
    ax : matplotlib.pyplot.Axes, Optional
        - The axes to plot on. If nothing is provided a new figure will be created
    n_colors : int, Optional
        - The number of colors to generate for the colormap.
    max_value : float, int, Optional
        - Clips all of the values above this limit
        - If None, then there is no clipping
    xticklabels, yticklabels : str, list, None, Optional
        - These are the labels for the x and y axis, respectively.
        - If it is a list then it must have `otus.n_otus` elements.
        - If it is a string, it is the formatter for each of the rows/columns.
        - If it is None, then do not make any ticklabels
    include_tick_marks : bool, Optional
        - If True, include tick marks. If False get rid of them
    linewidths : float, Optional
        - The width of the lines separating the squares
    linecolor : str, Optional
        - The color of the lines separating the squares
    cmap : colormap object, Optional
        - Overrides the default colormap. If specified, we ignore `n_colors`
    include_colorbar : bool, Optional
        - If True, it will render the colorbar, if not then it wont.
    title : str, None, Optional
        - Title of the figure
        - If None then do not put any title
    figure_size : 2-tuple, Optional
        - This is the size of the figure (in inches)
        - If nothing is specified it will default to adding 10 inches in each
          dimension for every 50 OTUs
    
    Returns
    -------
    matplotlib.pyplot.Axes
        Axes object that has the image rendering on it
    '''
    if max_value is None:
        max_value = DEFAULT_MAX_BAYES_FACTOR
    # Set default parameters
    d = _set_heatmap_default_args(linewidths=linewidths, linecolor=linecolor, 
        n_colors=n_colors, xticklabels=xticklabels, yticklabels=yticklabels, 
        include_colorbar=include_colorbar, include_tick_marks=include_tick_marks)
    linewidths = d['linewidths']
    linecolor = d['linecolor']
    n_colors = d['n_colors']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    include_colorbar = d['include_colorbar']
    include_tick_marks = d['include_tick_marks']

    # Type checking and initialization
    d = _init_parameters_heatmap(matrix=bayes_factors,
        otus=otus, clustering=clustering, xticklabels=xticklabels,
        yticklabels=yticklabels, ax=ax, figure_size=figure_size,
        linewidths=linewidths, order=order)
    ax = d['ax']
    bayes_factors = d['matrix']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    cbar_kws = d['cbar_kws']
    linewidths = d['linewidths']

    if np.any(bayes_factors < 0):
        raise ValueError('There should be no negative values in `bayes_factors`')
    for i in range(otus.n_otus):
        bayes_factors[i,i] = np.nan
    if cmap is None:
        cmap = sns.color_palette('Blues', n_colors=n_colors)
    if max_value is not None:
        bayes_factors[bayes_factors > max_value] = max_value

    ax = sns.heatmap(
        data=bayes_factors,
        square=True,
        linewidths=linewidths,
        linecolor=linecolor,
        cmap=cmap,
        cbar=include_colorbar,
        robust=True,
        cbar_kws=cbar_kws,
        xticklabels=xticklabels,
        yticklabels=yticklabels)

    if not include_tick_marks:
        ax.tick_params(bottom=False, left=False)
    if title is not None:
        ax.set_title(title)
    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.render_cocluster_proportions">
    <p>def <span class="ident">render_cocluster_proportions</span>(</p><p>coclusters, otus, clustering=None, ax=None, n_colors=None, xticklabels=None, yticklabels=None, include_tick_marks=None, linewidths=None, linecolor=None, cmap=None, include_colorbar=None, title=&#39;Microbe Co-cluster Proportions&#39;, figure_size=None, order=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Render the cocluster proportions. Values in coclusters should be [0,1].</p>
<h2>Parameters</h2>
<p>coclusters : 2-dim np.ndarray
    - Square matrix indicating the cocluster proportions
otus : pylab.base.OTUSet
    - This is the object that contains all of the OTU metadata
clustering : pylab.cluster.ClusteringBase, Optional
    - Clustering object if you want the OTUs in the same cluster to be grouped
      together
ax : matplotlib.pyplot.Axes, Optional
    - The axes to plot on. If nothing is provided a new figure will be created
n_colors : int, Optional
    - The number of colors to generate for the colormap.
xticklabels, yticklabels : str, list, None, Optional
    - These are the labels for the x and y axis, respectively.
    - If it is a list then it must have <code>otus.n_otus</code> elements.
    - If it is a string, it is the formatter for each of the rows/columns.
    - If it is None, then do not make any ticklabels
include_tick_marks : bool, Optional
    - If True, include tick marks. If False get rid of them
linewidths : float, Optional
    - The width of the lines separating the squares
linecolor : str, Optional
    - The color of the lines separating the squares
cmap : colormap object, Optional
    - Overrides the default colormap. If specified, we ignore <code>n_colors</code>
include_colorbar : bool, Optional
    - If True, it will render the colorbar, if not then it wont.
title : str, None, Optional
    - Title of the figure
    - If None then do not put any title
figure_size : 2-tuple, Optional
    - This is the size of the figure (in inches)
    - If nothing is specified it will default to adding 10 inches in each
      dimension for every 50 OTUs</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes
    Axes object that has the image rendering on it</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.render_cocluster_proportions', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.render_cocluster_proportions" class="source">
    <pre><code>def render_cocluster_proportions(coclusters, otus, clustering=None, ax=None,
    n_colors=None, xticklabels=None, yticklabels=None,
    include_tick_marks=None, linewidths=None, linecolor=None, cmap=None,
    include_colorbar=None, title='Microbe Co-cluster Proportions', figure_size=None,
    order=None):
    '''Render the cocluster proportions. Values in coclusters should be [0,1].

    Parameters
    ----------
    coclusters : 2-dim np.ndarray
        - Square matrix indicating the cocluster proportions
    otus : pylab.base.OTUSet
        - This is the object that contains all of the OTU metadata
    clustering : pylab.cluster.ClusteringBase, Optional
        - Clustering object if you want the OTUs in the same cluster to be grouped
          together
    ax : matplotlib.pyplot.Axes, Optional
        - The axes to plot on. If nothing is provided a new figure will be created
    n_colors : int, Optional
        - The number of colors to generate for the colormap.
    xticklabels, yticklabels : str, list, None, Optional
        - These are the labels for the x and y axis, respectively.
        - If it is a list then it must have `otus.n_otus` elements.
        - If it is a string, it is the formatter for each of the rows/columns.
        - If it is None, then do not make any ticklabels
    include_tick_marks : bool, Optional
        - If True, include tick marks. If False get rid of them
    linewidths : float, Optional
        - The width of the lines separating the squares
    linecolor : str, Optional
        - The color of the lines separating the squares
    cmap : colormap object, Optional
        - Overrides the default colormap. If specified, we ignore `n_colors`
    include_colorbar : bool, Optional
        - If True, it will render the colorbar, if not then it wont.
    title : str, None, Optional
        - Title of the figure
        - If None then do not put any title
    figure_size : 2-tuple, Optional
        - This is the size of the figure (in inches)
        - If nothing is specified it will default to adding 10 inches in each
          dimension for every 50 OTUs

    Returns
    -------
    matplotlib.pyplot.Axes
        Axes object that has the image rendering on it
    '''
    # Set default parameters
    d = _set_heatmap_default_args(linewidths=linewidths, linecolor=linecolor, 
        n_colors=n_colors, xticklabels=xticklabels, yticklabels=yticklabels, 
        include_colorbar=include_colorbar, include_tick_marks=include_tick_marks)
    linewidths = d['linewidths']
    linecolor = d['linecolor']
    n_colors = d['n_colors']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    include_colorbar = d['include_colorbar']
    include_tick_marks = d['include_tick_marks']

    # Type checking and initialization
    d = _init_parameters_heatmap(matrix=coclusters,
        otus=otus, clustering=clustering, xticklabels=xticklabels,
        yticklabels=yticklabels, ax=ax, figure_size=figure_size,
        linewidths=linewidths, order=order)
    ax = d['ax']
    coclusters = d['matrix']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    cbar_kws = d['cbar_kws']
    linewidths = d['linewidths']

    if cmap is None:
        cmap = sns.color_palette('Blues', n_colors=n_colors)
    if np.any(coclusters < 0) or np.any(coclusters > 1):
        raise ValueError('All values of coclusters should be in [0,1]')

    ax = sns.heatmap(
        data=coclusters,
        square=True,
        linewidths=linewidths,
        linecolor=linecolor,
        cmap=cmap,
        cbar_kws=cbar_kws,
        cbar=include_colorbar,
        xticklabels=xticklabels,
        robust=True,
        yticklabels=yticklabels)

    if not include_tick_marks:
        ax.tick_params(bottom=False, left=False)
    if title is not None:
        ax.set_title(title)
    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.render_growth_vector">
    <p>def <span class="ident">render_growth_vector</span>(</p><p>growth, difference=False, ax=None, light_palette=&#39;Navy&#39;, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Renders the growth terms of the regression coefficients as an image. Pass
in the raw regression coefficients and</p>
<h2>Parameters</h2>
<p>growth : np.ndarray
    - growth terms from the interaction matrix
ax : matplotlib.pyplot.Axes, Optional
    - Axis to plot on.
    - If nothing is provided, a new figure is created with a subplot
      that takes up the entire figure.
difference : bool, Optional
    - If True, Resets the colormap so that a 0 difference is white and
      it is diverging.
light_palette : str, Optional
    - Palette to use for the colormap
kwargs : dict
    - optional arguments for plt.imshow
    - Default values:
        'vmin' = - max(abs(max(raw_regress_coeff)), abs(min(raw_regress_coeff)))
        'vmin' = + max(abs(max(raw_regress_coeff)), abs(min(raw_regress_coeff)))</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes
    - Axis object that has the rendering of the growth values</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.render_growth_vector', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.render_growth_vector" class="source">
    <pre><code>def render_growth_vector(growth, difference=False, ax=None, light_palette='Navy', **kwargs):
    '''Renders the growth terms of the regression coefficients as an image. Pass
    in the raw regression coefficients and

    Parameters
    ----------
    growth : np.ndarray
        - growth terms from the interaction matrix
    ax : matplotlib.pyplot.Axes, Optional
        - Axis to plot on.
        - If nothing is provided, a new figure is created with a subplot
          that takes up the entire figure.
    difference : bool, Optional
        - If True, Resets the colormap so that a 0 difference is white and
          it is diverging.
    light_palette : str, Optional
        - Palette to use for the colormap
    kwargs : dict
        - optional arguments for plt.imshow
        - Default values:
            'vmin' = - max(abs(max(raw_regress_coeff)), abs(min(raw_regress_coeff)))
            'vmin' = + max(abs(max(raw_regress_coeff)), abs(min(raw_regress_coeff)))

    Returns
    -------
    matplotlib.pyplot.Axes
        - Axis object that has the rendering of the growth values
    '''

    growth = growth.reshape(-1,1)
    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111)

    # Set labels if necessary
    ax, kwargs = _set_plt_labels(kwargs, ax)

    # Set default values if necessary
    if difference:
        kwargs['cmap'] = sns.diverging_palette(240,10,n=DEFAULT_N_COLORS, as_cmap=True)
    else:
        kwargs['cmap'] = sns.light_palette(light_palette, as_cmap=True)

    _max = np.max(np.absolute(growth))
    if 'vmin' not in kwargs and difference:
        kwargs['vmin'] = -_max
    if 'vmax' not in kwargs and difference:
        kwargs['vmax'] = _max

    im = ax.imshow(growth, **kwargs)

    # Set ticks so that you can discern between pixels
    ax.set_yticks(np.arange(-.5, growth.shape[0], 1), minor = False)
    ax.set_yticks(np.arange(0, growth.shape[0], 1), minor = True)

    ax.set_xticklabels([])
    ax.set_yticklabels(labels = np.arange(0, growth.shape[0], dtype=int), minor = True)
    ax.tick_params(which = 'major',labelbottom = False, labelleft = False,
        labelright = False, labeltop = False)
    ax.tick_params(which = 'minor',labelbottom = False, labelleft = True,
        labelright = False, labeltop = False)
    ax.grid(color='black', linewidth = 1.5, which='major', axis='y')
    return im
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.render_interaction_strength">
    <p>def <span class="ident">render_interaction_strength</span>(</p><p>interaction_matrix, log_scale, otus, clustering=None, ax=None, center_colors=False, n_colors=None, xticklabels=None, vmax=None, vmin=None, yticklabels=None, include_tick_marks=None, linewidths=None, linecolor=None, cmap=None, include_colorbar=None, title=&#39;Microbe Interaction Strength&#39;, figure_size=None, order=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Render the interaction strength matrix. If you want the values in log scale,
it will annotate the box with the sign of the interaction and plot the absolute
value of the interaction. If you want the OTUs in the same clusters to be grouped
together, specify the clustering object in <code>cluster</code>.</p>
<h2>Parameters</h2>
<p>interaction_matrix : 2-dim np.ndarray
    - Square matrix indicating the interaction strengths
log_scale : bool
    - If True, plots with log scale. If False it plots with regular
      scale
otus : pylab.base.OTUSet
    - This is the object that contains all of the OTU metadata
clustering : pylab.cluster.ClusteringBase, Optional
    - Clustering object if you want the OTUs in the same cluster to be grouped
      together
ax : matplotlib.pyplot.Axes, Optional
    - The axes to plot on. If nothing is provided a new figure will be created
center_colors : bool, Optional
    - If True, it will center the colors for the colormap
    - This is overriden if <code>log_scale</code> is True
n_colors : int, Optional
    - The number of colors to generate for the colormap.
vmax, vmin : float
    - Lower and upper values to plot. If nothing is provided then it is
      infered from the data
xticklabels, yticklabels : str, list, None, Optional
    - These are the labels for the x and y axis, respectively.
    - For details on the format, look at <code>pylab.util.otuname_formatter</code>
    - If it is a list then it must have <code>otus.n_otus</code> elements.
    - If it is a string, it is the formatter for each of the rows/columns.
    - If it is None, then do not make any ticklabels
include_tick_marks : bool, Optional
    - If True, include tick marks. If False get rid of them
linewidths : float, Optional
    - The width of the lines separating the squares
linecolor : str, Optional
    - The color of the lines separating the squares
cmap : colormap object, Optional
    - Overrides the default colormap. If specified, we ignore <code>n_colors</code>
include_colorbar : bool, Optional
    - If True, it will render the colorbar, if not then it wont.
title : str, None, Optional
    - Title of the figure
    - If None then do not put any title
figure_size : 2-tuple, Optional
    - This is the size of the figure (in inches)
    - If nothing is specified it will default to adding 10 inches in each
      dimension for every 50 OTUs</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes
    Axes object that has the image rendering on it</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.render_interaction_strength', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.render_interaction_strength" class="source">
    <pre><code>def render_interaction_strength(interaction_matrix, log_scale, otus, clustering=None,
    ax=None, center_colors=False, n_colors=None, xticklabels=None, vmax=None, vmin=None,
    yticklabels=None, include_tick_marks=None, linewidths=None, linecolor=None,
    cmap=None, include_colorbar=None, title='Microbe Interaction Strength',
    figure_size=None, order=None):
    '''Render the interaction strength matrix. If you want the values in log scale,
    it will annotate the box with the sign of the interaction and plot the absolute
    value of the interaction. If you want the OTUs in the same clusters to be grouped
    together, specify the clustering object in `cluster`.

    Parameters
    ----------
    interaction_matrix : 2-dim np.ndarray
        - Square matrix indicating the interaction strengths
    log_scale : bool
        - If True, plots with log scale. If False it plots with regular
          scale
    otus : pylab.base.OTUSet
        - This is the object that contains all of the OTU metadata
    clustering : pylab.cluster.ClusteringBase, Optional
        - Clustering object if you want the OTUs in the same cluster to be grouped
          together
    ax : matplotlib.pyplot.Axes, Optional
        - The axes to plot on. If nothing is provided a new figure will be created
    center_colors : bool, Optional
        - If True, it will center the colors for the colormap
        - This is overriden if `log_scale` is True
    n_colors : int, Optional
        - The number of colors to generate for the colormap.
    vmax, vmin : float
        - Lower and upper values to plot. If nothing is provided then it is
          infered from the data
    xticklabels, yticklabels : str, list, None, Optional
        - These are the labels for the x and y axis, respectively.
        - For details on the format, look at `pylab.util.otuname_formatter`
        - If it is a list then it must have `otus.n_otus` elements.
        - If it is a string, it is the formatter for each of the rows/columns.
        - If it is None, then do not make any ticklabels
    include_tick_marks : bool, Optional
        - If True, include tick marks. If False get rid of them
    linewidths : float, Optional
        - The width of the lines separating the squares
    linecolor : str, Optional
        - The color of the lines separating the squares
    cmap : colormap object, Optional
        - Overrides the default colormap. If specified, we ignore `n_colors`
    include_colorbar : bool, Optional
        - If True, it will render the colorbar, if not then it wont.
    title : str, None, Optional
        - Title of the figure
        - If None then do not put any title
    figure_size : 2-tuple, Optional
        - This is the size of the figure (in inches)
        - If nothing is specified it will default to adding 10 inches in each
          dimension for every 50 OTUs
    
    Returns
    -------
    matplotlib.pyplot.Axes
        Axes object that has the image rendering on it
    '''
    # Set default parameters
    d = _set_heatmap_default_args(linewidths=linewidths, linecolor=linecolor, 
        n_colors=n_colors, xticklabels=xticklabels, yticklabels=yticklabels, 
        include_colorbar=include_colorbar, include_tick_marks=include_tick_marks)
    linewidths = d['linewidths']
    linecolor = d['linecolor']
    n_colors = d['n_colors']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    include_colorbar = d['include_colorbar']
    include_tick_marks = d['include_tick_marks']

    # Type checking and initialization
    d = _init_parameters_heatmap(matrix=interaction_matrix,
        otus=otus, clustering=clustering, xticklabels=xticklabels,
        yticklabels=yticklabels, ax=ax, figure_size=figure_size,
        linewidths=linewidths, order=order)
    ax = d['ax']
    interaction_matrix = d['matrix']
    xticklabels = d['xticklabels']
    yticklabels = d['yticklabels']
    cbar_kws = d['cbar_kws']
    linewidths = d['linewidths']

    if cmap is None:
        cmap = sns.cubehelix_palette(n_colors)
    if center_colors and not log_scale:
        cmap = sns.color_palette("RdBu_r", n_colors)
        center_colors=0 # center at 0
        if vmin is not None and vmax is not None:
            absmax = np.max(np.absolute([vmin,vmax]))
            vmin = -absmax
            vmax = absmax

    log_scale = bool(log_scale)
    center_colors = bool(center_colors)
    include_tick_marks = bool(include_tick_marks)
    linewidths = float(linewidths)
    linecolor = str(linecolor)
    include_colorbar = bool(include_colorbar)
    n_colors = int(n_colors)

    # Add annotation and override parameters if we are doing log scale
    if log_scale:
        ann = []
        for i in range(interaction_matrix.shape[0]):
            ann.append([])
            for j in range(interaction_matrix.shape[1]):
                b = '+'
                if interaction_matrix[i,j] < 0:
                    b = '\u2212' # uicode minus sign
                ann[-1].append(b)
        annot = np.asarray(ann)
        interaction_matrix = np.log10(np.absolute(interaction_matrix))
        interaction_matrix[~np.isfinite(interaction_matrix)] = np.nan
        interaction_matrix[interaction_matrix == 0] = np.nan

        center_colors = None
        # if vmax is not None:
        #     vmax=np.absolute(vmax)
        # if vmin is not None:
        #     vmin=np.absolute(vmin)
    else:
        annot = None

    try:
        ax = sns.heatmap(
            data=interaction_matrix,
            annot=annot,
            fmt='',
            center=center_colors,
            square=True,
            # vmin=vmin,
            # vmax=vmax,
            robust=True,
            linewidths=linewidths,
            linecolor=linecolor,
            cmap=cmap,
            cbar=include_colorbar,
            cbar_kws=cbar_kws,
            xticklabels=xticklabels,
            yticklabels=yticklabels)
        if not include_tick_marks:
            ax.tick_params(bottom=False, left=False)
        if title is not None:
            ax.set_title(title)
        if log_scale:
            ax.collections[0].colorbar.ax.set_title("$\\log_{10}$")
    except Exception as e:
        logging.critical('Could not plot heatmap because of error message: "{}".' \
            ' This is likely because `interaction_matrix` has either only NaNs ' \
            'or 0s ({}). We are clearing the current axis and are going to skip' \
            'plotting this axis.'.format(str(e), _is_just_zero_or_nan(interaction_matrix)))
    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.render_trace">
    <p>def <span class="ident">render_trace</span>(</p><p>var, idx=None, ax=None, plt_type=None, include_burnin=True, scatter=True, log_scale=False, n_burnin=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Visualizes the Trace of a random variable.
Produces a historgram of the values and a plot of the sample
values over the iterations.</p>
<h2>Parameters</h2>
<p>var : array, pylab.variables.Variable
    - Array to do the trace on.
    - If it is not a pylab variable object, then we need to pass in how many 
      burnin iterations there are with the parameter <code>n_burnin</code> orelse we 
      automatically set <code>include_burnin</code> to False
idx : int, tuple, Optional
    - If the variable is not a scalar, this indexes the index that you want to trace on
ax : matplotlib.pyplot.Axes, Optional
    - Axes to plot on
    - If nothing is provided, a new figure with a single subplot
      will be created and returned
plt_type : str, Optional
    - The type of plot that will make
    - Options:
        - 'hist'
            - Histogram of the values. This is the posterior
        - 'trace' (Default)
            - The value of the random variable for each iteration
        - 'both' (Default)
            - Makes a new figure and plots 'hist' on the left
              and 'trace' on the right.
            - If specified, <code>ax</code> is ignored.
inlcude_burnin : bool, Optional
    - If True, it will plot the burnin trace as negative numbers
      in the trace as well
    - If <code>plt_type</code> == 'hist', <code>include_burnin</code> is automatically set to False
scatter : bool
    - Only applies to plt_type=='trace'
    - If True, it will plot the points as a scatter plot
    - Else it will plot the points as a line
log_scale : bool
    If True, plots the points in log-scale. If any of the points are negative, then we 
    take the absolute value of the values that we are plotting
n_burnin : int
    Only required if <code>var</code> is an array, not a pylab.variables.Variable.
    Tells how big the burnin array is.
kwargs : Optional values for the figure
    - Optional arguments:
        - 'color' : str
            - Default color is 'blue'
        - 'alpha' : float
            - Default alpha is 0.5 for the trace
        - 'title' : str
            - Nothing
        - 'xlabel' : str
            - Label of the horizontal axis
            - Default is 'Iteration' if the <code>plt_type</code> is 'trace'.
            - Default is 'Value' if the <code>plt_type</code> is 'hist'
        - 'ylabel' : str
            - Label of the vertical axis
            - Default is 'Value' if the <code>plt_type</code> is 'trace'.
            - Default is 'Count' if the <code>plt_type</code> is 'hist'</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes, 2-tuple
    - This is the Axis that contains the rendered figure
    - If <code>plt_type</code> == 'both' then it will return both Axes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.render_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.render_trace" class="source">
    <pre><code>def render_trace(var, idx=None, ax=None, plt_type=None, include_burnin=True, 
    scatter=True, log_scale=False, n_burnin=None, **kwargs):
    '''
    Visualizes the Trace of a random variable.
    Produces a historgram of the values and a plot of the sample
    values over the iterations.

    Parameters
    ----------
    var : array, pylab.variables.Variable
        - Array to do the trace on.
        - If it is not a pylab variable object, then we need to pass in how many 
          burnin iterations there are with the parameter `n_burnin` orelse we 
          automatically set `include_burnin` to False
    idx : int, tuple, Optional
        - If the variable is not a scalar, this indexes the index that you want to trace on
    ax : matplotlib.pyplot.Axes, Optional
        - Axes to plot on
        - If nothing is provided, a new figure with a single subplot
          will be created and returned
    plt_type : str, Optional
        - The type of plot that will make
        - Options:
            - 'hist'
                - Histogram of the values. This is the posterior
            - 'trace' (Default)
                - The value of the random variable for each iteration
            - 'both' (Default)
                - Makes a new figure and plots 'hist' on the left
                  and 'trace' on the right.
                - If specified, `ax` is ignored.
    inlcude_burnin : bool, Optional
        - If True, it will plot the burnin trace as negative numbers
          in the trace as well
        - If `plt_type` == 'hist', `include_burnin` is automatically set to False
    scatter : bool
        - Only applies to plt_type=='trace'
        - If True, it will plot the points as a scatter plot
        - Else it will plot the points as a line
    log_scale : bool
        If True, plots the points in log-scale. If any of the points are negative, then we 
        take the absolute value of the values that we are plotting
    n_burnin : int
        Only required if `var` is an array, not a pylab.variables.Variable.
        Tells how big the burnin array is.
    kwargs : Optional values for the figure
        - Optional arguments:
            - 'color' : str
                - Default color is 'blue'
            - 'alpha' : float
                - Default alpha is 0.5 for the trace
            - 'title' : str
                - Nothing
            - 'xlabel' : str
                - Label of the horizontal axis
                - Default is 'Iteration' if the `plt_type` is 'trace'.
                - Default is 'Value' if the `plt_type` is 'hist'
            - 'ylabel' : str
                - Label of the vertical axis
                - Default is 'Value' if the `plt_type` is 'trace'.
                - Default is 'Count' if the `plt_type` is 'hist'
        
    Returns
    -------
    matplotlib.pyplot.Axes, 2-tuple
        - This is the Axis that contains the rendered figure
        - If `plt_type` == 'both' then it will return both Axes
    '''
    _valid_kwargs = ['color', 'alpha', 'xlabel', 'ylabel', 'label', 'title']

    # Set defaults
    if plt_type is None:
        plt_type = DEFAULT_PLT_TYPE
    if 'color' not in kwargs:
        kwargs['color'] = DEFAULT_TRACE_COLOR
    if not util.isbool(scatter):
        raise TypeError('`scatter` ({}) must be a bool'.format(type(scatter)))
    if not util.isbool(log_scale):
        raise TypeError('`log_scale` ({}) must be a bool'.format(type(log_scale)))
    
    # check the kwargs
    for k in kwargs:
        if k not in _valid_kwargs:
            raise TypeError('`render_trace` got unexpected keyword argument "{}"'.format(k))

    if plt_type == 'both':
        fig = plt.figure()
        ax1 = render_trace(
            var=var, ax=fig.add_subplot(1,2,1), plt_type='hist',
            idx=idx, log_scale=log_scale,  **kwargs)
        ax2 = render_trace(
            var=var, ax=fig.add_subplot(1,2,2), plt_type='trace',
            scatter=scatter, log_scale=log_scale, idx=idx, **kwargs)
        fig.tight_layout()
        fig.subplots_adjust(top=0.85)
        return ax1, ax2
    elif plt_type == 'hist':
        include_burnin = False

    if idx is not None:
        # Then it is multidimensional
        if type(idx) == int:
            idxs = (..., idx)
        elif type(idx) == tuple:
            idxs = (..., ) + idx
        else:
            raise ValueError('`idx` ({}) must either be an int or a tuple'.format(
                type(idx)))
    else:
        idxs = ()

    if not isVariable(var):
        trace = np.asarray(var)
        if util.isint(n_burnin):
            if n_burnin < 0:
                raise ValueError('`n_burnin` ({}) must be >= 0'.format(n_burnin))
            points = np.append(
                np.arange(-n_burnin, 0, 1),
                np.arange(len(trace) - n_burnin))
        else:
            points = np.arange(trace.shape[0])
        trace = trace[idxs]
        include_burnin = False
        
    else:
        trace = var.get_trace_from_disk()[idxs]
        if include_burnin:
            burnin_trace = var.get_trace_from_disk(section='burnin')
            burnin_trace = burnin_trace[idxs]
            points = np.append(
                np.arange(-len(burnin_trace),0,1),
                np.arange(len(trace)))
            trace = np.append(burnin_trace, trace)
        else:
            points = np.arange(len(trace))

    if trace[idxs].ndim > 1:
        raise ValueError('`render_trace` only supports vectors ({})'.format(trace.shape))

    if ax is None:
        fig = plt.figure()
        ax = fig.add_subplot(111)
    # extract labels
    if 'xlabel' not in kwargs:
        if plt_type == 'hist':
            kwargs['xlabel'] = 'Value'
        else:
            kwargs['xlabel'] = 'Iteration'
    if 'ylabel' not in kwargs:
        if plt_type == 'hist':
            kwargs['ylabel'] = 'Probability'
        else:
            kwargs['ylabel'] = 'Value'
    if 'title' not in kwargs:
        if plt_type == 'hist':
            kwargs['title'] = 'Posterior'
        else:
            kwargs['title'] = 'Trace'
    ax, kwargs = _set_plt_labels(kwargs, ax)

    if plt_type == 'trace':
        if 'alpha' not in kwargs:
            kwargs['alpha'] = 0.5
        try:
            if log_scale:
                if np.any(trace < 0):
                    logging.warning('Some values in trace are negative, take absolute value of vector')
                    trace = np.absolute(trace)
                ax.set_yscale('log')
            if scatter:
                ax.scatter(points, np.squeeze(trace), s=1.5, **kwargs)
            else:
                ax.plot(points, np.squeeze(trace), **kwargs)
        except:
            logging.info('`ax.plot` failed. No points to plot')
        if log_scale:
            ax.set_yscale('log')
    elif plt_type == 'hist':
        if 'alpha' not in kwargs:
            kwargs['alpha'] = 0.25
        try:
            if log_scale:
                if np.any(trace < 0):
                    logging.warning('Some values in trace are negative, take absolute value of vector')
                    trace = np.absolute(trace)
                hist, bins = np.histogram(trace, bins=30)
                logbins = np.logspace(np.log10(bins[0]),np.log10(bins[-1]),len(bins))
                ax.hist(x=trace, bins=logbins, density=True, **kwargs)
                ax.set_xscale('log')
            else:
                ax.hist(x=trace, density=True, bins=20, **kwargs)
            # ax.axvline(x=np.mean(trace), color = 'red')
            # ax.axvline(x=np.median(trace), color = 'blue')

        except Exception as e:
            logging.info('`ax.hist` failed: {}'.format(e))
            return None
    else:
        raise ValueError('plt_type ({}) not recognized'.format(plt_type))
    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.set_default_tax_level">
    <p>def <span class="ident">set_default_tax_level</span>(</p><p>level)</p>
    </div>
    

    
  
    <div class="desc"><p>This sets the default taxa level to plot at.</p>
<h2>Parameters</h2>
<p>level : str
    This is the level to set it at. It must be either:
        'kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'OTU'</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.set_default_tax_level', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.set_default_tax_level" class="source">
    <pre><code>def set_default_tax_level(level):
    '''This sets the default taxa level to plot at.
    
    Parameters
    ----------
    level : str
        This is the level to set it at. It must be either:
            'kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'OTU'
    '''
    global DEFAULT_TAX_LEVEL
    if not util.isstr(level):
        raise ValueError('`level` ({}) must be a str'.format(type(level)))
    if level not in ['kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'otu']:
        raise ValueError('`level` ({}) not valid'.format(level))
    DEFAULT_TAX_LEVEL = level
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.set_default_trace_color">
    <p>def <span class="ident">set_default_trace_color</span>(</p><p>color)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets defalt color of the trace. Must be matplotlib compatible.</p>
<h2>Parameters</h2>
<p>color : any
    This is the color to set it to.</p>
<h2>See Also</h2>
<p>https://matplotlib.org/2.0.2/api/colors_api.html</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.set_default_trace_color', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.set_default_trace_color" class="source">
    <pre><code>def set_default_trace_color(color):
    '''Sets defalt color of the trace. Must be matplotlib compatible.

    Parameters
    ----------
    color : any
        This is the color to set it to.

    See Also
    --------
    https://matplotlib.org/2.0.2/api/colors_api.html
    '''
    global DEFAULT_TRACE_COLOR
    DEFAULT_TRACE_COLOR = color
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.set_perturbation_color">
    <p>def <span class="ident">set_perturbation_color</span>(</p><p>color)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the color for the perturbation shading. Must be matplotlib compatible.</p>
<h2>Parameters</h2>
<p>color : any
    This is the color to set it to.</p>
<h2>See Also</h2>
<p>https://matplotlib.org/2.0.2/api/colors_api.html</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.set_perturbation_color', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.set_perturbation_color" class="source">
    <pre><code>def set_perturbation_color(color):
    '''Set the color for the perturbation shading. Must be matplotlib compatible.

    Parameters
    ----------
    color : any
        This is the color to set it to.

    See Also
    --------
    https://matplotlib.org/2.0.2/api/colors_api.html
    '''
    global PERTURBATION_COLOR
    PERTURBATION_COLOR = color
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.set_xtick_frequency">
    <p>def <span class="ident">set_xtick_frequency</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the xtick frequency (how often a label on the x axis should occur)</p>
<h2>Parameters</h2>
<p>x : numeric
    How often it should occur (in days)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.set_xtick_frequency', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.set_xtick_frequency" class="source">
    <pre><code>def set_xtick_frequency(x):
    '''Sets the xtick frequency (how often a label on the x axis should occur)

    Parameters
    ----------
    x : numeric
        How often it should occur (in days)
    '''
    global XTICK_FREQUENCY
    if not util.isnumeric(x):
        raise ValueError('x ({}) must be a numeric'.format(type(x)))
    if x <= 0:
        raise ValueError('x ({}) must be >= 0'.format(x))
    XTICK_FREQUENCY = x
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.shade_in_perturbations">
    <p>def <span class="ident">shade_in_perturbations</span>(</p><p>ax, perturbations, textcolor=&#39;black&#39;, textsize=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Shade in the axis where there are perturbations and adds the label of
the perturbation above it.</p>
<h2>Parameters</h2>
<p>ax : matplotlib.pyplot.Axes
    Axis we are plotting on
subjset : pylab.base.SubjectSet
    Subject set to plot on</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.shade_in_perturbations', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.shade_in_perturbations" class="source">
    <pre><code>def shade_in_perturbations(ax, perturbations, textcolor='black', textsize=None):
    '''Shade in the axis where there are perturbations and adds the label of
    the perturbation above it.

    Parameters
    ----------
    ax : matplotlib.pyplot.Axes
        Axis we are plotting on
    subjset : pylab.base.SubjectSet
        Subject set to plot on

    Returns
    -------
    matplotlib.pyplot.Axes
    '''
    if perturbations is None:
        return ax

    pert_locs = []
    pert_names = []
    for pidx, perturbation in enumerate(perturbations):
        ax.axvspan(
            xmin=perturbation.start,
            xmax=perturbation.end, 
            facecolor=PERTURBATION_COLOR, 
            alpha=0.25)
        pert_locs.append((perturbation.end + perturbation.start) / 2)
        name = perturbation.name
        if name is None:
            name = 'pert{}'.format(pidx)
        pert_names.append(name)

    # Set the names on the top x-axis
    ax2 = ax.twiny()
    ax2.set_xlim(ax.get_xlim())
    ax2.set_xticks(pert_locs)
    ax2.set_xticklabels(pert_names)
    ax2.tick_params('x', which='both', length=0, colors=textcolor, 
        labelsize=textsize)

    return ax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.visualization.taxonomic_distribution_over_time">
    <p>def <span class="ident">taxonomic_distribution_over_time</span>(</p><p>subj, taxlevel=None, drop_nan_taxa=False, legend=True, ax=None, plot_abundant=None, label_formatter=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Produces a taxonomic bar graph for each datapoint</p>
<h2>Aggregating by taxanomic level</h2>
<p>If the taxonomy of the OTUs are specified, you can aggregate OTUs into specific 
taxonomic levels and plot them using the parameter <code>taxlevel</code>.
Example: if <code>taxlevel='phylum'</code> then we add all of the reads of the OTUs
that are in the same Phylum. If <code>taxlevel=None</code> then we do no aggregation. If you 
set <code>taxlevel='default'</code> then it aggregates at the default taxonomic level, which 
can be set using the function <code>plotting.set_default_tax_level(level)</code>.</p>
<p>The <code>label_formatter</code> (str) tells the function how to set the index of the dataframe
it returns using <code>pylab.util.otuname_formatter</code>. If nothing is specified then it 
will return the entire taxonomy as a label for the taxa. NOTE, you cannot specifiy
a taxonomy <em>below</em> that youre clustering at. For example, you cannot cluster at the 
'class' level and then specify <code>'%(genus)s'</code> in <code>label_formatter</code>.</p>
<p>plot_abundant : int
If you want to only plot the x most abundant OTUs, specify that number 
with <code>plot_abundant</code> (<code>int</code>) as a positive number. Example: <code>plot_abundant = 15</code> will
only plot the 15 most abundant. If <code>plot_abundant</code> is a negative number, it will
plot the least abundant. Example: <code>plot_abundant = -15</code> will only plot the 15 least 
abundant. The abundances are calculated using the reads.</p>
<h2>Parameters</h2>
<p>subj : pylab.base.Subject
    Subject we are getting the data from
taxlevel : str, None
    This is the taxa level to aggregate the data at. If 'default' is specified
    then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
drop_nan_taxa : bool
    If True, it will not plot taxas that are not specified (NaNs). If False, it
    will conglomerate all the taxas into a single category called 'Unclassified'
plot_abundant: int, None
    If specified, only plots the top or bottom <code>plot_abundant</code> elements.
    If None then nothing happens
label_formatter : str, None
    If specified, it will tell how to make the legend using the otuname_formatter.
    This can only be used if the <code>taxlevel</code> is not specified.
kwargs : dict
    xlabel, ylabel, title : str
        Default 'title' is the type of alpha diversity and the level
    ax : matplotlib.pyplot.Axes, None
        This is the axis to plot on. If nothing is specified then we will create a 
        new figure with this as the only axis.
    figsize : 2-tuple
        Size of the figure
    legend : bool
        If True, add a legend</p>
<h2>Returns</h2>
<p>matplotlib.pyplot.Axes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.visualization.taxonomic_distribution_over_time', this);">Show source &equiv;</a></p>
  <div id="source-pylab.visualization.taxonomic_distribution_over_time" class="source">
    <pre><code>def taxonomic_distribution_over_time(subj, taxlevel=None, drop_nan_taxa=False, 
    legend=True, ax=None, plot_abundant=None, label_formatter=None, **kwargs):
    '''Produces a taxonomic bar graph for each datapoint

    Aggregating by taxanomic level
    ------------------------------
    If the taxonomy of the OTUs are specified, you can aggregate OTUs into specific 
    taxonomic levels and plot them using the parameter `taxlevel`.
    Example: if `taxlevel='phylum'` then we add all of the reads of the OTUs
    that are in the same Phylum. If `taxlevel=None` then we do no aggregation. If you 
    set `taxlevel='default'` then it aggregates at the default taxonomic level, which 
    can be set using the function `plotting.set_default_tax_level(level)`.

    The `label_formatter` (str) tells the function how to set the index of the dataframe
    it returns using `pylab.util.otuname_formatter`. If nothing is specified then it 
    will return the entire taxonomy as a label for the taxa. NOTE, you cannot specifiy
    a taxonomy *below* that youre clustering at. For example, you cannot cluster at the 
    'class' level and then specify `'%(genus)s'` in `label_formatter`.

    plot_abundant : int
    If you want to only plot the x most abundant OTUs, specify that number 
    with `plot_abundant` (`int`) as a positive number. Example: `plot_abundant = 15` will
    only plot the 15 most abundant. If `plot_abundant` is a negative number, it will
    plot the least abundant. Example: `plot_abundant = -15` will only plot the 15 least 
    abundant. The abundances are calculated using the reads.

    Parameters
    ----------
    subj : pylab.base.Subject
        Subject we are getting the data from
    taxlevel : str, None
        This is the taxa level to aggregate the data at. If 'default' is specified
        then it defaults the DEFAULT_TAX_LEVEL. If None then there will be no aggregation.
    drop_nan_taxa : bool
        If True, it will not plot taxas that are not specified (NaNs). If False, it
        will conglomerate all the taxas into a single category called 'Unclassified'
    plot_abundant: int, None
        If specified, only plots the top or bottom `plot_abundant` elements.
        If None then nothing happens
    label_formatter : str, None
        If specified, it will tell how to make the legend using the otuname_formatter.
        This can only be used if the `taxlevel` is not specified.
    kwargs : dict
        xlabel, ylabel, title : str
            Default 'title' is the type of alpha diversity and the level
        ax : matplotlib.pyplot.Axes, None
            This is the axis to plot on. If nothing is specified then we will create a 
            new figure with this as the only axis.
        figsize : 2-tuple
            Size of the figure
        legend : bool
            If True, add a legend
    
    Returns
    -------
    matplotlib.pyplot.Axes
    ''' 
    # Type checking
    if not issubject(subj):
        raise ValueError('`subj` ({}) must be a pylab.base.Subject'.format(type(subj)))
    if not util.isbool(drop_nan_taxa):
        raise ValueError('`drop_nan_taxa` ({}) must be a bool'.format(
            type(drop_nan_taxa)))
    if not util.isbool(legend):
        raise ValueError('`legend` ({}) must be a bool'.format(type(legend)))
    taxlevel = _set_taxlevel(taxlevel)

    if plot_abundant is not None:
        if not util.isint(plot_abundant):
            raise TypeError('`plot_abundant` ({}) must be an int'.format(
                type(plot_abundant)))
        if plot_abundant == 0:
            raise ValueError('`plot_abundant` cannot be zero')

    if 'title' not in kwargs:
        kwargs['title'] = 'Taxonomic Distribution, {} level'.format(taxlevel.capitalize())
    if 'xlabel' not in kwargs:
        kwargs['xlabel'] = 'Days'
    if 'ylabel' not in kwargs:
        kwargs['ylabel'] = 'Relative Abundance'

    ax, kwargs = _set_plt_labels(d=kwargs, ax=ax)
    if len(kwargs) != 0:
        raise ValueError('Arguemnts {} not recognized'.format(list(kwargs.keys())))
    df = subj.cluster_by_taxlevel(dtype='rel', drop_nan_taxa=drop_nan_taxa, taxlevel=taxlevel, 
        index_formatter=label_formatter)

    if plot_abundant is not None:
        matrix = df.values
        abnds = np.sum(matrix, axis=1)
        if plot_abundant < 0:
            plot_abundant *= -1
            idxs = np.argsort(abnds)[:plot_abundant]
        else:
            idxs = np.argsort(abnds)[-plot_abundant:]
        df = df.iloc[idxs, :]

        # Add everything else as 'Everything else'
        vals = []
        for col in df.columns:
            vals.append(1 - df[col].sum())
        df2 = pandas.DataFrame([vals], columns=df.columns, index=['Other'])
        df = df.append(df2)
        
        

    ax = df.T.plot(ax=ax, kind='bar', stacked=True)

    if legend:
        # handles, labels = ax.get_legend_handles_labels()
        # Reverse the inferit order of the legend so it matches the graph
        # ax.legend(handles[::-1], labels[::-1], bbox_to_anchor=(1,1))
        ax.legend(bbox_to_anchor=(1,1))

    # ax = _set_xticks(ax)
    return ax
</code></pre>
  </div>
</div>

  </div>
  


  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
