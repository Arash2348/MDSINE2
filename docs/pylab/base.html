<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>pylab.base API documentation</title>
    <meta name="description" content="These are base classes that are used throughout the rest of Pylab

Difference between Saveable and T..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.base.DEFAULT_TAXA_NAME">DEFAULT_TAXA_NAME</a></li>
    <li class="mono"><a href="#pylab.base.SEQUENCE_COLUMN_LABEL">SEQUENCE_COLUMN_LABEL</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#pylab.base.isotu">isotu</a></li>
    <li class="mono"><a href="#pylab.base.isotuset">isotuset</a></li>
    <li class="mono"><a href="#pylab.base.isperturbation">isperturbation</a></li>
    <li class="mono"><a href="#pylab.base.isqpcrdata">isqpcrdata</a></li>
    <li class="mono"><a href="#pylab.base.issavable">issavable</a></li>
    <li class="mono"><a href="#pylab.base.issubject">issubject</a></li>
    <li class="mono"><a href="#pylab.base.issubjectset">issubjectset</a></li>
    <li class="mono"><a href="#pylab.base.istraceable">istraceable</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.BasePerturbation">BasePerturbation</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.BasePerturbation.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.base.BasePerturbation.isactive">isactive</a></li>
    <li class="mono"><a href="#pylab.base.BasePerturbation.timetuple">timetuple</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.CustomOrderedDict">CustomOrderedDict</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.CustomOrderedDict.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.base.CustomOrderedDict.update_order">update_order</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.OTU">OTU</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.OTU.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.base.OTU.get_lineage">get_lineage</a></li>
    <li class="mono"><a href="#pylab.base.OTU.set_taxonomy">set_taxonomy</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.OTUSet">OTUSet</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.OTUSet.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.base.OTUSet.add_otu">add_otu</a></li>
    <li class="mono"><a href="#pylab.base.OTUSet.del_otu">del_otu</a></li>
    <li class="mono"><a href="#pylab.base.OTUSet.save">save</a></li>
    <li class="mono"><a href="#pylab.base.OTUSet.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.base.OTUSet.taxonomic_similarity">taxonomic_similarity</a></li>
    <li class="mono"><a href="#pylab.base.OTUSet.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.Saveable">Saveable</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.Saveable.save">save</a></li>
    <li class="mono"><a href="#pylab.base.Saveable.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.base.Saveable.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.Subject">Subject</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.Subject.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.base.Subject.cluster_by_taxlevel">cluster_by_taxlevel</a></li>
    <li class="mono"><a href="#pylab.base.Subject.df">df</a></li>
    <li class="mono"><a href="#pylab.base.Subject.matrix">matrix</a></li>
    <li class="mono"><a href="#pylab.base.Subject.read_depth">read_depth</a></li>
    <li class="mono"><a href="#pylab.base.Subject.save">save</a></li>
    <li class="mono"><a href="#pylab.base.Subject.set_from_tables">set_from_tables</a></li>
    <li class="mono"><a href="#pylab.base.Subject.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.base.Subject.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.SubjectSet">SubjectSet</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.SubjectSet.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.add">add</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.add_from_table">add_from_table</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.add_perturbation">add_perturbation</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.denormalize_qpcr">denormalize_qpcr</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.iloc">iloc</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.normalize_qpcr">normalize_qpcr</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.pop_otus">pop_otus</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.pop_subject">pop_subject</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.pop_times">pop_times</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.save">save</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.set_save_location">set_save_location</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.split_on_perturbations">split_on_perturbations</a></li>
    <li class="mono"><a href="#pylab.base.SubjectSet.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.Traceable">Traceable</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.Traceable.add_init_value">add_init_value</a></li>
    <li class="mono"><a href="#pylab.base.Traceable.add_trace">add_trace</a></li>
    <li class="mono"><a href="#pylab.base.Traceable.get_iter">get_iter</a></li>
    <li class="mono"><a href="#pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></li>
    <li class="mono"><a href="#pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></li>
    <li class="mono"><a href="#pylab.base.Traceable.set_trace">set_trace</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#pylab.base.qPCRdata">qPCRdata</a></span>
        
          
  <ul>
    <li class="mono"><a href="#pylab.base.qPCRdata.__init__">__init__</a></li>
    <li class="mono"><a href="#pylab.base.qPCRdata.add">add</a></li>
    <li class="mono"><a href="#pylab.base.qPCRdata.set_scaling_factor">set_scaling_factor</a></li>
    <li class="mono"><a href="#pylab.base.qPCRdata.set_to_nan">set_to_nan</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">pylab.base</span> module</h1>
  <p>These are base classes that are used throughout the rest of Pylab</p>
<h2>Difference between Saveable and Traceable</h2>
<p><code>Saveable</code> defines functions (<code>save</code> and <code>load</code>) to save the class object in 
memory as a Pickle. Traceable defines functions and attributes that allows the
trace of the object during inference to be saved on disk DURING inference. An 
object can both be <code>Saveable</code> and <code>Traceable</code>.</p>
<h2>How perturbations are switched on and off</h2>
<p>'The time ahead prediction must be included in the perturbation' - Travis</p>
<p>Example: Pertubtion period (2,5) - this is <strong>3</strong> doses</p>
<pre><code>               |--&gt;|--&gt;|--&gt;
</code></pre>
<p>perturbation on    #############
Days           1   2   3   4   5   6</p>
<p><code>d1</code> indicates the perturbation parameter that gets added for the day that it
should be included in.</p>
<p>x2 = x1 + ...
x3 = x2 + ... + d1
x4 = x3 + ... + d1
x5 = x4 + ... + d1
x6 = x5 + ...</p>
<p>The perturbation periods that are given are in the format (start, end).
For the above example our perturbation period would be (2, 5). Thus, we should do
inclusion/exclusion brackets such that:</p>
<p>(start, end]
    - The first day is inclusive
    - Last day is exclusive</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base" class="source">
    <pre><code>'''These are base classes that are used throughout the rest of Pylab

Difference between Saveable and Traceable
-----------------------------------------
`Saveable` defines functions (`save` and `load`) to save the class object in 
memory as a Pickle. Traceable defines functions and attributes that allows the
trace of the object during inference to be saved on disk DURING inference. An 
object can both be `Saveable` and `Traceable`.

How perturbations are switched on and off
-----------------------------------------
'The time ahead prediction must be included in the perturbation' - Travis

Example: Pertubtion period (2,5) - this is **3** doses

                   |-->|-->|-->
perturbation on    #############
Days           1   2   3   4   5   6

`d1` indicates the perturbation parameter that gets added for the day that it
should be included in.

x2 = x1 + ...
x3 = x2 + ... + d1
x4 = x3 + ... + d1
x5 = x4 + ... + d1
x6 = x5 + ...

The perturbation periods that are given are in the format (start, end).
For the above example our perturbation period would be (2, 5). Thus, we should do
inclusion/exclusion brackets such that:

(start, end]
    - The first day is inclusive
    - Last day is exclusive
'''

import numpy as np
import collections
import pickle
import scipy.spatial.distance
import pandas as pd
import logging

from .util import isint, isnumeric, isarray, isstr, isbool, otuname_formatter
from .errors import NeedToImplementError

# Constants
DEFAULT_TAXA_NAME = 'NA'
SEQUENCE_COLUMN_LABEL = 'sequence'


def isqpcrdata(x):
    '''Checks whether the input is a subclass of qPCRData

    Parameters
    ----------
    x : any
        Input instance to check the type of qPCRData
    
    Returns
    -------
    bool
        True if `x` is of type qPCRData, else False
    '''
    return x is not None and issubclass(x.__class__, qPCRdata)

def isotuset(x):
    '''Checks whether the input is a subclass of OTUSet

    Parameters
    ----------
    x : any
        Input instance to check the type of OTUSet
    
    Returns
    -------
    bool
        True if `x` is of type OTUSet, else False
    '''
    return x is not None and issubclass(x.__class__, OTUSet)

def issavable(x):
    '''Checks whether the input is a subclass of Savable

    Parameters
    ----------
    x : any
        Input instance to check the type of Savable
    
    Returns
    -------
    bool
        True if `x` is of type Savable, else False
    '''
    return x is not None and issubclass(x.__class__, Saveable)

def istraceable(x):
    '''Checks whether the input is a subclass of Traceable

    Parameters
    ----------
    x : any
        Input instance to check the type of Traceable
    
    Returns
    -------
    bool
        True if `x` is of type Traceable, else False
    '''
    return x is not None and issubclass(x.__class__, Traceable)

def isotu(x):
    '''Checks whether the input is a subclass of OTU

    Parameters
    ----------
    x : any
        Input instance to check the type of OTU
    
    Returns
    -------
    bool
        True if `x` is of type OTU, else False
    '''
    return x is not None and issubclass(x.__class__, OTU)

def issubject(x):
    '''Checks whether the input is a subclass of Subject

    Parameters
    ----------
    x : any
        Input instance to check the type of Subject
    
    Returns
    -------
    bool
        True if `x` is of type Subject, else False
    '''
    return x is not None and issubclass(x.__class__, Subject)

def issubjectset(x):
    '''Checks whether the input is a subclass of SubjectSet

    Parameters
    ----------
    x : any
        Input instance to check the type of SubjectSet
    
    Returns
    -------
    bool
        True if `x` is of type SubjectSet, else False
    '''
    return x is not None and issubclass(x.__class__, SubjectSet)

def isperturbation(x):
    '''Checks whether the input is a subclass of BasePerturbation

    Parameters
    ----------
    x : any
        Input instance to check the type of BasePerturbation
    
    Returns
    -------
    bool
        True if `x` is of type BasePerturbation, else False
    '''
    return x is not None and issubclass(x.__class__, BasePerturbation)


class Saveable:
    '''Implements baseline saving classes with pickle for classes
    '''
    def save(self, filename=None):
        '''Pickle the object

        Paramters
        ---------
        filename : str
            This is the location to store the file. Overrides the location if
            it is set using `pylab.base.Saveable.set_save_location`. If None
            it means that we are using the file location set in 
            set_location. 
        '''
        if filename is None:
            if not hasattr(self, '_save_loc'):
                raise TypeError('`filename` must be specified if you have not ' \
                    'set the save location')
            filename = self._save_loc
        
        with open(filename, 'wb') as output:  # Overwrites any existing file.
            pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls, filename):
        '''Unpickle the object

        Paramters
        ---------
        filename : str
            This is the location of the file to unpickle
        '''
        with open(filename, 'rb') as handle:
            b = pickle.load(handle)
        return b

    def set_save_location(self, filename):
        '''Set the save location for the object
        '''
        if not isstr(filename):
            raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
        self._save_loc = filename


class Traceable:
    '''Defines the functionality for a Node to interact with the Graph tracer object
    '''

    @property
    def initialization_value(self):
        if hasattr(self, '_init_value'):
            return self._init_value
        else:
            return None

    def set_trace(self):
        '''Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        '''
        raise NotImplementedError('User needs to define this function')

    def add_trace(self):
        '''Adds the current value to the trace. If the buffer is full
        it will end it to disk
        '''
        raise NotImplementedError('User needs to define this function')

    def add_init_value(self):
        '''Saves the initialization value
        '''
        raise NotImplementedError('User needs to define this function')

    def get_trace_from_disk(self, *args, **kwargs):
        '''Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
        include the samples in the local buffer trace and could be very large

        Returns
        -------
        np.ndarray
        '''
        return self.G.tracer.get_trace(name=self.name, *args, **kwargs)

    def overwrite_entire_trace_on_disk(self, data, **kwargs):
        '''Overwrites the entire trace of the variable with the given data.

        Parameters
        ----------
        data : np.ndarray
            Data you are overwriting the trace with.
        '''
        self.G.tracer.overwrite_entire_trace_on_disk(
            name=self.name, data=data, dtype=self.dtype, **kwargs)

    def get_iter(self):
        '''Get the number of iterations saved to the hdf5 file of the variable

        Returns
        -------
        int
        '''
        return self.G.tracer.get_iter(name=self.name)


class BasePerturbation:
    '''Base perturbation class.

    We assume that the `start` is when the first perturbation happend (affects the next time point) and 
    `end` is the last time that it gets affected

    Paramters
    ---------
    start : float, int
        This is the start of the perturbation (it will afect the next time point)
    end : float, int
        This is the end of the perturbation (this is the last time point the 
        perturbation will affect)
    name : str, None
        This is the name of the perturabtion. If nothing is given then it will be None
    '''
    def __init__(self, start, end, name=None):
        if not isnumeric(start):
            raise TypeError('`start` ({}) must be a numeric'.format(type(start)))
        if not isnumeric(end):
            raise TypeError('`end` ({}) must be a numeric'.format(type(end)))
        if end < start:
            raise ValueError('`end` ({}) must be >= `start` ({})'.format(end, start))
        if name is not None:
            if not isstr(name):
                raise TypeError('`name` ({}) must be a str'.format(type(name)))
        self.start = start
        self.end = end
        self.name = name

    def isactive(self, time):
        '''Returns a `bool` if the perturbation is on at time `time`.

        Parameters
        ----------
        time : float, int
            Time to check
        '''
        return time > self.start and time <= self.end

    def timetuple(self):
        '''Returns the time tuple of the start and end

        Paramters
        ---------
        None

        Returns
        -------
        2-tuple
            (start,end) as floats
        '''
        return (self.start, self.end)

    def __str__(self):
        return 'Perturbation\n\tstart: {}\n\tend:{}'.format(
            self.start, self.end)


class OTU:
    '''Wrapper class for a single OTU

    Parameters
    ----------
    name : str
        Name given to the OTU 
    sequence : str
        Base Pair sequence
    idx : int
        The index that the otu occurs
    '''
    def __init__(self, name, sequence, idx):
        self.name = name
        self.sequence = sequence
        self.idx = idx
        if sequence is not None:
            self._sequence_as_array = np.array(list(sequence))
        else:
            self._sequence_as_array = None
        # Initialize the taxonomies to nothing
        self.taxonomy = {
            'kingdom': DEFAULT_TAXA_NAME,
            'phylum': DEFAULT_TAXA_NAME,
            'class': DEFAULT_TAXA_NAME,
            'order': DEFAULT_TAXA_NAME,
            'family': DEFAULT_TAXA_NAME,
            'genus': DEFAULT_TAXA_NAME,
            'otu': self.name}
        self.id = id(self)

    def __getitem__(self,key):
        return self.taxonomy[key.lower()]

    def __eq__(self, val):
        '''Compares different OTUs between each other. Checks all of the attributes but the id

        Parameters
        ----------
        val : any
            This is what we are checking if they are equivalent
        '''
        if type(val) != OTU:
            return False
        if self.name != val.name:
            return False
        if self.sequence != val.sequence:
            return False
        for k,v in self.taxonomy.items():
            if v != val.taxonomy[k]:
                return False
        return True

    def __str__(self):
        return 'OTU\n\tid: {}\n\tidx: {}\n\tname: {}\n' \
            '\ttaxonomy:\n\t\tkingdom: {}\n\t\tphylum: {}\n' \
            '\t\tclass: {}\n\t\torder: {}\n\t\tfamily: {}\n' \
            '\t\tgenus: {}'.format(
            self.id, self.idx, self.name,
            self.taxonomy['kingdom'], self.taxonomy['phylum'],
            self.taxonomy['class'], self.taxonomy['order'],
            self.taxonomy['family'], self.taxonomy['genus'])

    def set_taxonomy(self, tax_kingdom=None, tax_phylum=None, tax_class=None,
        tax_order=None, tax_family=None, tax_genus=None):
        '''Sets the taxonomy of the parts that are specified

        Parameters
        ----------
        tax_kingdom, tax_phylum, tax_class, tax_order, tax_family, tax_genus : str
            'kingdom', 'phylum', 'class', 'order', 'family', 'genus'
            Name of the taxa for each respective level
        '''
        if tax_kingdom is not None:
            self.taxonomy['kingdom'] = tax_kingdom
        if tax_phylum is not None:
            self.taxonomy['phylum'] = tax_phylum
        if tax_class is not None:
            self.taxonomy['class'] = tax_class
        if tax_order is not None:
            self.taxonomy['order'] = tax_order
        if tax_family is not None:
            self.taxonomy['family'] = tax_family
        if tax_genus is not None:
            self.taxonomy['genus'] = tax_genus

        return self

    def get_lineage(self, level=None):
        '''Returns a tuple of the lineage in order from Kingdom to the level
        indicated. Default value for level is `otu`

        Parameters
        ----------
        level : str, Optional
            The taxonomic level you want the lineage until
            If nothing is provided, it returns the entire taxonomic lineage
            Example:
                level = 'class'
                returns a tuple of (kingdom, phylum, class)
        '''
        a =  (self.taxonomy['kingdom'], self.taxonomy['phylum'], self.taxonomy['class'],
            self.taxonomy['order'], self.taxonomy['family'], self.taxonomy['genus'],
            self.taxonomy['otu'])

        if level is None:
            return a
        if level == 'otu':
            return a
        elif level == 'genus':
            return a[:-1]
        elif level == 'family':
            return a[:-2]
        elif level == 'order':
            return a[:-3]
        elif level == 'class':
            return a[:-4]
        elif level == 'phylum':
            return a[:-5]
        elif level == 'kingdom':
            return a[:-6]
        else:
            raise ValueError('level `{}` was not recognized'.format(level))


class OTUSet(Saveable):
    '''Wraps a set of `OTU` objects. You can get the OTU object via the
    OTU id, OTU name, or OTU sequence.
    Provides functionality for aggregating and getting subsets for lineages.
    '''

    def __init__(self, df=None):
        '''Load data from a dataframe

        Assumes the frame has the following columns:
            - sequence
            - name
            - taxonomy
                * kingdom, phylum, class, order, family, genus, species, otu

        Parameters
        ----------
        df - pandas.DataFrame, Optional
            DataFrame containing the required information (Taxonomy, sequence).
            If nothing is passed in, it will be an empty set.
        '''
        self.ids = CustomOrderedDict()
        self.seqs = CustomOrderedDict()
        self.names = CustomOrderedDict()
        self.index = []
        self._len = 0

        # Add all of the OTUs from the dataframe if necessary
        if df is not None:
            df = df.rename(str.lower, axis='columns')
            for name in df.index:
                self.add_otu(
                    name=name,
                    sequence=df[SEQUENCE_COLUMN_LABEL][name])
                self.names[name].set_taxonomy(
                    tax_kingdom=df.loc[name]['kingdom'],
                    tax_phylum=df.loc[name]['phylum'],
                    tax_class=df.loc[name]['class'],
                    tax_order=df.loc[name]['order'],
                    tax_family=df.loc[name]['family'],
                    tax_genus=df.loc[name]['genus'])

    def __contains__(self,key):
        try:
            self[key]
            return True
        except:
            return False

    def __getitem__(self,key):
        '''Get an OTU by either its sequence, name, index, or id

        Parameters
        ----------
        key : str, int
            Key to reference the OTU
        '''
        if isotu(key):
            return key
        if key in self.ids:
            return self.ids[key]
        elif isint(key):
            return self.index[key]
        elif key in self.names:
            return self.names[key]
        elif isotu(key):
            return key
        elif key in self.seqs:
            return self.seqs[key]
        else:
            raise IndexError('`{}` ({}) was not found as a name, sequence, index, or id'.format(
                key, type(key)))

    def __iter__(self):
        '''Returns each OTU obejct in order
        '''
        for otu in self.index:
            yield otu

    @property
    def n_otus(self):
        '''Alias for __len__
        '''
        return self._len

    def __len__(self):
        '''Return the number of OTUs in the OTUSet
        '''
        return self._len

    def add_otu(self, name, sequence):
        '''Adds an OTU to the set

        Parameters
        ----------
        name : str
            This is the name of the OTU
        sequence : str
            This is the sequence of the OTU
        '''
        otu = OTU(name=name, sequence=sequence, idx=self._len)
        self.ids[otu.id] = otu
        self.seqs[otu.sequence] = otu
        self.names[otu.name] = otu
        self.index.append(otu)

        # update the order of the OTUs
        self.ids.update_order()
        self.seqs.update_order()
        self.names.update_order()
        self._len += 1

        return self

    def del_otu(self, otu):
        '''Deletes the OTU from the set.

        Parameters
        ----------
        otu : str, int, OTU
            Can either be the name, sequence, or the ID of the OTU
        '''
        # Get the ID
        if type(otu) == OTU:
            pass
        elif otu in self.ids:
            otu = self.ids[otu]
        elif otu in self.seqs:
            otu = self.seqs[otu]
        elif otu in self.names:
            otu = self.names[otu]
        else:
            raise IndexError('otu ({}) was not found as an id, name, or sequence'.format(
                otu))
        oidx = self.ids.index[otu.id]

        # Delete the OTU from everything
        # otu = self[otu]
        self.ids.pop(otu.id, None)
        self.seqs.pop(otu.sequence, None)
        self.names.pop(otu.name, None)
        self.index.pop(oidx)

        # update the order of the OTUs
        self.ids.update_order()
        self.seqs.update_order()
        self.names.update_order()

        # Update the indices of the otus
        # Since everything points to the same object we only need to do it once
        for idx,otu in enumerate(self.ids.values()):
            otu.idx = idx

        self._len -= 1
        return self

    def taxonomic_similarity(self,oid1,oid2):
        '''Calculate the taxonomic similarity between OTU1 and OTU2
        Iterates through most broad to least broad taxonomic level and
        returns the fraction that are the same.

        Example:
            otu1.taxonomy = (A,B,C,D)
            otu2.taxonomy = (A,B,E,F)
            similarity = 0.5

            otu1.taxonomy = (A,B,C,D)
            otu2.taxonomy = (A,B,C,F)
            similarity = 0.75

            otu1.taxonomy = (A,B,C,D)
            otu2.taxonomy = (A,B,C,D)
            similarity = 1.0

            otu1.taxonomy = (X,Y,Z,M)
            otu2.taxonomy = (A,B,E,F)
            similarity = 0.0

        Parameters
        ----------
        oid1, oid2 : str, int
            The name, id, or sequence for the OTU
        '''
        if oid1 == oid2:
            return 1
        otu1 = self[oid1].get_lineage()
        otu2 = self[oid2].get_lineage()
        i = 0
        for a in otu1:
            if a == otu2[i]:
                i += 1
            else:
                break
        return i/7 # including OTU


class qPCRdata:
    '''Single entry of qpcr data.
    Assumes that the dilution factor is constant between the replicate runs

    The normalized data is assumed to be:
        (cfus * dilution_factor / mass) * scaling_factor

    scaling_factor is a scale that we impose on the data so that the numbers don't get
    super large in the numerical calculations and we get errors

    Parameters
    ----------
    cfus : np.ndarray
        These are the raw CFUs - it can be a single CFU measurement or a list of all
        the measurements
    mass : float
        This is the mass of the sample in grams
    dilution_factor : float
        This is the dilution factor of the samples
        Example:
            If the sample was diluted to 1/100 of its original concentration,
            the dilution factor is 100, NOT 1/100.

    '''
    def __init__(self, cfus, mass, dilution_factor):
        self._raw_data = np.asarray(cfus)
        self.mass = mass
        self.dilution_factor = dilution_factor
        self.scaling_factor = 1 # Initialize with no scaling factor
        self.scaled_data = (self._raw_data*self.dilution_factor/self.mass)*self.scaling_factor
        self.mean = np.mean(self.scaled_data)
        self.std = np.std(self.scaled_data)
        self.var = np.var(self.scaled_data)

    def __str__(self):
        return str(self.mean)

    def add(self,raw_data):
        '''Add a single qPCR measurement to add to the set of observations

        Parameters
        ----------
        raw_data : float, array_like
            This is the measurement to add
        '''
        self._raw_data = np.append(self._raw_data,raw_data)
        self.scaled_data = (self._raw_data*self.dilution_factor/self.mass)*self.scaling_factor
        self.mean = np.mean(self.scaled_data)
        self.std = np.std(self.scaled_data)
        self.var = np.var(self.scaled_data)

    def set_to_nan(self):
        '''Set all attributes to `np.nan`
        '''
        self._raw_data *= np.nan
        self.scaled_data *= np.nan
        self.mass = np.nan
        self.dilution_factor = np.nan
        self.mean = np.nan
        self.std = np.nan
        self.var = np.nan
        self.scaling_factor = np.nan

    def set_scaling_factor(self, scaling_factor):
        '''Resets the scaling factor

        Parameters
        ----------
        scaling_factor : float, int
            This is the scaling factor to set everything to
        '''
        if scaling_factor <= 0:
            raise ValueError('The scaling factor must strictly be positive')
        self.scaling_factor = scaling_factor
        self.scaled_data = (self._raw_data*self.dilution_factor/self.mass) * scaling_factor
        self.mean = np.mean(self.scaled_data)
        self.std = np.std(self.scaled_data)
        self.var = np.var(self.scaled_data)


class CustomOrderedDict(dict):
    '''Order is an initialized version of self.keys() -> much more efficient
    index maps the key to the index in order

    order (list)
        - same as a numpy version of the keys in order
    index (dict)
        - Maps the key to the index that it was inserted in
    '''

    def __init__(self, *args, **kwargs):
        '''Extension of the OrderedDict

        Paramters
        ---------
        args, kwargs : Arguments
            These are extra arguments to initialize the baseline OrderedDict
        '''
        dict.__init__(self, *args, **kwargs)
        self.order = None
        self.index = None

    def update_order(self):
        '''This will update the reverse dictionary
        '''
        self.order = np.array(list(self.keys()))
        self.index = {}
        for i, otu in enumerate(self.order):
            self.index[otu] = i


class Subject(Saveable):
    '''Data for a single subject
    The OTUSet order is done with respect to the ordering in the `reads_table`
    Parameters
    ----------
    parent : SubjectSet
        This is the parent class (we have a reverse pointer)
    name : str
        This is the name of the subject
    '''
    def __init__(self, parent, name):
        self.name = name
        self.id = id(self)
        self.parent = parent
        self.otus = self.parent.otus
        self.qpcr = {}
        self.reads = {}
        self.times = np.asarray([])

    def set_from_tables(self, qpcr_table, reads_table):
        '''Set the qpcr and reads from pandas DataFrames

        Parameters
        ----------
        qpcr_table : pandas.DataFrame
            This is the qPCR table that holds all of the information for each of the samples
        reads_table : pandas.DataFrame
            This is the data for the reads table

        TODO add descritpion for how the table should be laid out
        '''
        raise NotImplementedError('This still needs to be tested/clarified if this is ' \
            'the format to have')
        qpcr = qpcr_table.values
        masses = qpcr[:,0].flatten()
        dilution_factor = qpcr[:,1].flatten()
        qpcr = qpcr[:,2:]
        times = np.asarray(qpcr_table.index)
        idxs = np.argsort(times)
        self.times = times[idxs]
        for idx in idxs:
            self.qpcr[times[idx]] = qPCRdata(
                cfus=qpcr[idx,:],
                mass=masses[idx],
                dilution_factor=dilution_factor[idx])

        # Reads - add in time ascending order (using times from qpcr)
        for t in self.times:
            self.reads[t] = np.asarray(reads_table[t])

    @property
    def perturbations(self):
        '''Returns the number of perturbation
        '''
        return len(self.parent.perturbations)

    def matrix(self, min_rel_abund=None):
        '''Make a numpy matrix out of our data - returns the raw reads,
        the relative abundance, and the absolute abundance.

        If there is no qPCR data, then the absolute abundance is set to None.

        Parameters
        ----------
        min_rel_abund : float, int, Optional
            This is the minimum relative abundance to add to the 'rel' matrix.
            If nothing is specified then nothing gets added
        '''
        if np.issubdtype(type(min_rel_abund), np.bool_):
            if not min_rel_abund:
                min_rel_abund = None
            else:
                raise ValueError('Invalid `min_rel_abund` type ({})'.format(
                    type(min_rel_abund)))

        if min_rel_abund is not None:
            if type(min_rel_abund) != float or type(min_rel_abund) != int:
                raise ValueError('if `min_rel_abund` ({}) is specified, it must ' \
                    'be a float or an int'.format(type(min_rel_abund)))

        shape = (len(self.otus), len(self.times))
        raw = np.zeros(shape=shape, dtype=int)
        rel = np.zeros(shape=shape, dtype=float)
        abs = np.zeros(shape=shape, dtype=float)

        if min_rel_abund is not None:
            rel += min_rel_abund

        for i,t in enumerate(self.times):
            raw[:,i] = self.reads[t]
            rel[:,i] = raw[:,i]/np.sum(raw[:,i])
        
        if len(self.qpcr) > 0:
            for i,t in enumerate(self.times):
                abs[:,i] = rel[:,i] * self.qpcr[t].mean
        else:
            abs = None

        return {'raw':raw, 'rel': rel, 'abs':abs}

    def df(self, **kwargs):
        '''Returns a dataframe of the data - same as matrix

        Parameters
        ----------
        These are the parameters for `matrix`
        '''
        d = self.matrix(**kwargs)
        index = self.otus.names.order
        times = self.times
        for key in d:
            d[key] = pd.DataFrame(data=d[key], index=index, columns=times)
        return d

    def read_depth(self, t=None):
        '''Get the read depth at time `t`. If nothing is given then return all
        of them

        Parameters
        ----------
        t : int, float, Optional
            Get the read depth at this time. If nothing is provided, all of the read depths for this 
            subject are returned
        '''
        if t is None:
            return np.sum(self.matrix()['raw'], axis=0)
        if t not in self.reads:
            raise ValueError('`t` ({}) not recognized. Valid times: {}'.format(
                t, self.times))
        return np.sum(self.reads[t])

    def cluster_by_taxlevel(self, dtype, drop_nan_taxa, taxlevel=None, index_formatter=None):
        '''Clusters the OTUs into the taxonomic level indicated in `taxlevel`

        Parameters
        ----------
        subj : pylab.base.Subject
            This is the subject that we are getting the data from
        taxlevel : str, None
            This is the taxa level to aggregate the data at. If it is 
            None then we do not do any collapsing (this is the same as 'otu')
        dtype : str
            This is the type of data to cluster. Options are:
                'raw': These are the counts
                'rel': This is the relative abundances
                'abs': This is the absolute abundance (qPCR * rel)
        drop_nan_taxa : bool
            If True, it will not plot taxas that are not specified (NaNs). If False, it
            will conglomerate all the taxas into a single category called 'Unclassified'
        index_formatter : str
            How to make the index using `pylab.util.otuname_formatter`. Note that you cannot
            specify anything at a lower taxonomic level than what youre clustering at. For 
            example, you cannot cluster at the 'class' level and then specify '%(genus)s' 
            in the index formatter.
            If nothing is specified then the whole taxonomy is returned.
        '''
        # Type checking
        if not isstr(dtype):
            raise TypeError('`dtype` ({}) must be a str'.format(type(dtype)))
        if dtype not in ['raw', 'rel', 'abs']:
            raise ValueError('`dtype` ({}) not recognized'.format(dtype))
        if not isbool(drop_nan_taxa):
            raise TypeError('`drop_nan_taxa` ({}) must be a bool'.format(
                type(drop_nan_taxa)))
        if taxlevel is None:
            taxlevel = 'otu'
        elif not isstr(taxlevel):
            raise TypeError('`taxlevel` ({}) must be a str'.format(type(taxlevel)))
        if taxlevel not in ['kingdom', 'phylum', 'class',  'order', 'family', 
            'genus', 'otu']:
            raise ValueError('`taxlevel` ({}) not recognized'.format(taxlevel))
        if index_formatter is not None:
            if not isstr(index_formatter):
                raise TypeError('`index_formatter` ({}) must be a str'.format(type(index_formatter)))
            
            # Check if it is valid
            vals = {'kingdom': 0, 'phylum': 1, 'class': 2,  'order': 3, 'family': 4, 
                'genus': 5, 'otu': 6}
            
            for tx in vals:
                if tx in index_formatter and vals[tx] > vals[taxlevel]:
                    raise ValueError('You are clustering at the {} level but are specifying' \
                        ' {} in the `index_formatter`. This does not make sense. Either cluster' \
                        'at a lower tax level or specify the `index_formatter` to a higher tax ' \
                        'level'.format(taxlevel, tx))
        else:
            # make it everything up to `taxlevel`
            taxes = ['kingdom', 'phylum', 'class',  'order', 'family', 'genus', 'otu']
            index_formatter = '%(kingdom)s'
            for i in range(1,len(taxes) + 1):
                if taxlevel == taxes[i-1]:
                    break
                index_formatter += ', %(' + taxes[i] + ')s'

        index_formatter = index_formatter.replace('%(otu)s', '%(name)s')

        # Everything is valid, get the data dataframe and the return dataframe
        df = self.df(min_rel_abund=None)[dtype]
        cols = list(df.columns)
        cols.append(taxlevel)
        dfnew = pd.DataFrame(columns = cols).set_index(taxlevel)

        # Get the level in the taxonomy, create a new entry if it is not there already
        taxas = {} # lineage -> label
        for i, otu in enumerate(self.otus):
            row = df.index[i]
            tax = otu.get_lineage(taxlevel)

            # Check if it is nan, drop if necessary
            if type(tax[-1]) == float:
                if drop_nan_taxa:
                    continue
                tax = list(tax)
                tax[-1] = 'Unclassified'
            tax = tuple(tax)
            tax = str(tax).replace("'", '')
            if tax in taxas:
                dfnew.loc[taxas[tax]] += df.loc[row]
            else:
                taxas[tax] = otuname_formatter(format=index_formatter, otu=otu, otus=self.otus)
                toadd = pd.DataFrame(np.array(list(df.loc[row])).reshape(1,-1),
                    index=[taxas[tax]], columns=dfnew.columns)
                dfnew = dfnew.append(toadd)
        
        return dfnew

    def _split_on_perturbations(self):
        '''If there are perturbations, then we take out the data on perturbations
        and we set the data in the different segments to different subjects

        Internal funciton, should not be used by the user
        '''
        if len(self.parent.perturbations) == 0:
            logging.info('No perturbations to split on, do nothing')
            return

        # Get the time intervals for each of the times that we are not on perturbations
        start_tidx = 0
        not_perts = []
        in_pert = False
        for i in range(len(self.times)):
            # check if the time is in a perturbation
            a = False
            for pert in self.parent.perturbations:
                start = pert.start
                end = pert.end
                # check if in the perturbation
                if self.times[i] > start and self.times[i] <= end:
                    a = True
                    break
            if a:
                # If the current time point is in a perturbation and we previously
                # have no been in a perturbation, this means we can add the previous
                # interval into the intervals that we want to keep
                if not in_pert:
                    not_perts.append((start_tidx, i))
                in_pert = True
            else:
                # If we are not currently in a perturbation but we previously were
                # then we restart to `start_tidx`
                if in_pert:
                    start_tidx = i
                    in_pert = False
        # If we have finished and we are out of a perturbation at the end, then
        # we can add the rest of the times at the end to a valid not in perturbation time
        if not in_pert:
            not_perts.append((start_tidx, len(self.times)))

        # For each of the time slices recorded, make a new subject
        if len(in_pert) == 0:
            raise ValueError('THere are perturbations ({}), this must not be zero.' \
                ' Something went wrong'.format(len(self.parent.perturbations)))
        ii = 0
        for start,end in not_perts:
            mid = self.name+'_{}'.format(ii)
            self.parent.add(name=mid)
            for i in range(start,end):
                t = self.times[i]
                self.parent[mid].qpcr[t] = self.qpcr[t]
                self.parent[mid].reads[t] = self.reads[t]
            self.parent[mid].times = self.times[start:end]


class SubjectSet(Saveable):
    '''Holds data for all the subjects

    Paramters
    ---------
    sequences : pd.DataFrame, Optional
        index: OTU names
        column: sequences
        These are the sequences for each one of the OTUs
    taxonomy_table : pd.DataFrame, Optional
        index:
            - OTU names
            - Must be identical to the keys in `sequences` and the
              index in `reads_table`
        columns:
            - Must contain 'kingdom', 'phylum', 'class', 'order',
              'family', 'genus'
        data:
            - These are the names
    otus : OTUSet, Optional
        If you already have an OTUSetobject, you can just use that
    '''
    def __init__(self, sequences=None, taxonomy_table=None, otus=None):
        self.id = id(self)
        self._subjects = {}
        self.perturbations = None
        self.qpcr_normalization_factor = None
        if otus is not None:
            if not isotuset(otus):
                raise ValueError('If `otus` ({}) is specified, it must be an OTUSet' \
                    ' type'.format(type(otus)))
            self.otus = otus
            return

        if type(sequences) != pd.DataFrame:
            raise ValueError('`sequences` ({}) must be a dict'.format(
                type(sequences)))
        if taxonomy_table is not None:
            if type(taxonomy_table) != pd.DataFrame:
                raise ValueError('`taxonomy_table` ({}) must be a pandas.DataFrame object'.format(
                    type(taxonomy_table)))

        valid_cols = ['sequences']
        seq_cols = list(sequences.columns)
        for col in seq_cols:
            if col not in valid_cols:
                raise ValueError('column `{}` not in valid columns: {}'.format(
                    col, valid_cols))
        for col in valid_cols:
            if col not in seq_cols:
                raise ValueError('column `{}` not in sequence columns: {}'.format(
                    col, seq_cols))

        seq_keys = sequences.index
        if taxonomy_table is not None:
            tax_index = taxonomy_table.index
            for key in seq_keys:
                if key not in tax_index:
                    raise ValueError("key '{}' not in taxonomy index ({})".format(
                        key, tax_index))
            for key in tax_index:
                if key not in seq_keys:
                    raise ValueError("key '{}' not in sequence keys ({})".format(
                        key, seq_keys))

        # Check the columns for taxonomy_table if necessary
        # Every column in taxonomy_table has to be in valid_cols
        # NOT every column in valid_cols has to be in taxonomy_table
        if taxonomy_table is not None:
            valid_cols = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus']
            tax_cols = list(taxonomy_table.columns)
            tax_cols = [str(col).lower() for col in tax_cols]
            taxonomy_table.columns = tax_cols
            for col in tax_cols:
                if col not in valid_cols:
                    raise ValueError("col '{}' not in valid columns for taxonomy ({})".format(
                        col, valid_cols))

        # Everything is valid, make the otuset
        # OTUs
        self.otus = OTUSet()
        for otu_name in sequences.index:
            self.otus.add_otu(name=otu_name, sequence=sequences[otu_name])
            if taxonomy_table is not None:
                kwargs = {}
                for tax in tax_cols:
                    kwargs[tax] = taxonomy_table[tax][otu_name]
                self.otus[otu_name].set_taxonomy(**kwargs)

    def __getitem__(self, key):
        return self._subjects[key]

    def __len__(self):
        return len(self._subjects)

    def __iter__(self):
        for v in self._subjects.values():
            yield v

    def __contains__(self, key):
        return key in self._subjects

    def iloc(self, idx):
        '''Get the subject as an index

        Parameters
        ----------
        idx : int
            Index of the subject

        Returns
        -------
        pl.base.Subject
        '''
        for i,sid in enumerate(self._subjects):
            if i == idx:
                return self._subjects[sid]
        raise IndexError('Index ({}) not found'.format(idx))

    def add(self, name):
        '''Create a subject with the name `name`

        Parameters
        ----------
        name : str
            This is the name of the new subject
        '''
        if name not in self._subjects:
            self._subjects[name] = Subject(name=name, parent=self)
        return self

    def add_from_table(self, name, reads_table, qpcr_table):
        '''Adds a subject to the subject set

        Parameters
        ----------
        name : str
            This is the name of the subject
        qpcr_table, reads_table : pandas.DataFrame
            These specify the qpcr measurements
            index:
                - ['1.0','1.3', '2.2', ...] these are the time points in string
                  format
            columns:
                - ['mass', 'dilution factor', '1', '2', '3'] (for each of the 3 measurements)
            data:
                - these are the triplicate qpcr measurements
        reads_table : pandas.DataFrame
            index:
                - OTU names
                - Must be identical to the keys in `sequences` and the
                  index in `taxonomy_table`
            columns:
                - These are the time points in string format
                - These must be identical to the index in `qpcr_table`
            data:
                - Each one of the reads for each one of the OTUs
        '''
        # Type check
        if type(name) != str:
            raise ValueError('`name` ({}) must be a str'.format(type(name)))
        if type(qpcr_table) != pd.DataFrame:
            raise ValueError('`qpcr_table` ({}) must be a pandas.DataFrame object'.format(
                type(qpcr_table)))
        if type(reads_table) != pd.DataFrame:
            raise ValueError('`reads_table` ({}) must be a pandas.DataFrame object'.format(
                type(reads_table)))

        # Check OTU names are consistent
        read_index = reads_table.index
        for key in self.otus.names:
            if key not in read_index:
                raise ValueError("key '{}' not in reads index ({})".format(
                    key, read_index))
        for key in read_index:
            if key not in self.otus.names:
                raise ValueError("key '{}' not in sequence keys ({})".format(
                    key, self.otus.names))


        # Check time labels are consistent
        # First convert both to strs of floats where necessary
        reads_table.columns = [float(t) for t in reads_table.columns]
        qpcr_table.index = [float(t) for t in qpcr_table.index]

        qpcr_times = qpcr_table.index
        reads_times = reads_table.columns
        for key in qpcr_times:
            if key not in reads_times:
                raise ValueError("key '{}' not in times for reads ({})".format(
                    key, reads_times))
        for key in reads_times:
            if key not in qpcr_times:
                raise ValueError("key '{}' not in times for qpcr ({})".format(
                    key, qpcr_table))

        # Check the columns for qpcr_table
        valid_cols = ['dilution factor', 'mass', '1', '2', '3']
        qpcr_cols = list(qpcr_table.columns)
        qpcr_cols = [str(col).lower() for col in qpcr_cols]
        for col in qpcr_cols:
            if col not in valid_cols:
                raise ValueError("col '{}' not in valid columns for qpcr ({})".format(
                    col, valid_cols))
        for col in valid_cols:
            if col not in qpcr_cols:
                raise ValueError("col '{}' not in qpcr columns ({})".format(
                    col, qpcr_cols))

        # Check ordering of reads index is consistent with the otuset order
        if len(reads_table.index) != len(self.otus):
            raise ValueError('length of reads ({}) does not equal the right number ' \
                'of OTUs ({})'.format(len(reads_table.index), len(self.otus)))
        for i,name in enumerate(self.otus.names.order):
            if name != reads_table.index[i]:
                raise ValueError('The `{}`th row of the reads ({}) does not ' \
                    'correspond to the `{}`th OTU in OTUSet ({})'.format(
                        i,reads_table.index[i],i,name))
        self.add(name=name)
        self._subjects[name].set_from_tables(reads_table=reads_table,
            qpcr_table=qpcr_table)
        return self

    def pop_subject(self, sid):
        '''Remove the indicated subject id

        Parameters
        ----------
        sid : list(str), str, int
            This is the subject name/s or the index/es to pop out.
            Return a new SubjectSet with the specified subjects removed.
        '''
        if not isarray(sid):
            sids = [sid]
        else:
            sids = sid

        for i in range(len(sids)):
            if isint(sids[i]):
                sids[i] = list(self._subjects.keys())[sids[i]]
            elif not isstr(sids[i]):
                raise ValueError('`sid` ({}) must be a str'.format(type(sids[i])))
        ret = SubjectSet(otus=self.otus)
        ret.perturbations = self.perturbations
        ret.qpcr_normalization_factor = self.qpcr_normalization_factor

        for s in sids:
            if s in self._subjects:
                ret._subjects[s] =  self._subjects.pop(s, None)
            else:
                raise ValueError('`sid` ({}) not found'.format(sid))
        return ret

    def pop_otus(self, oids):
        '''Delete the OTUs indicated in oidxs. Updates the reads table and
        the internal OTUSet

        Parameters
        ----------
        oids : str, int, list(str/int)
            These are the identifiers for each of the OTU/s to delete
        '''
        if isint(oids):
            oids = [oids]
        if not isarray(oids):
            raise ValueError('`oids` ({}) must be an array'.format(type(oids)))

        # get indices
        oidxs = []
        for oid in oids:
            oidxs.append(self.otus[oid].idx)

        # Get the IDs
        ids = []
        for oid in oids:
            ids.append(self.otus[oid].id)

        # Delete the OTUs from otuset
        for oid in ids:
            if oid not in self.otus:
                logging.warning('otu `{}` not contained in otuset. skipping'.format(oid))
            otu = self.otus[oid]
            self.otus.del_otu(otu.id)

        # Delete the reads
        for subj in self:
            for t in subj.reads:
                subj.reads[t] = np.delete(subj.reads[t], oidxs)
        return self

    def pop_times(self, times, sids='all'):
        '''Discard the times in `times` for the subjects listed in `sids`.
        If a timepoint is not found in a subject, no error is thrown.

        Parameters
        ----------
        times : numeric, list(numeric)
            Time/s to delete
        sids : str, int, list(int)
            The Subject ID or a list of subject IDs that you want to delete the timepoints
            from. If it is a str:
                'all' - delete from all subjects
        '''
        if isstr(sids):
            if sids == 'all':
                sids = list(self._subjects.keys())
            else:
                raise ValueError('`sids` ({}) not recognized'.format(sids))
        elif isint(sids):
            if sids not in self._subjects:
                raise IndexError('`sid` ({}) not found in subjects'.format(
                    list(self._subjects.keys())))
            sids = [sids]
        elif isarray(sids):
            for sid in sids:
                if not isint(sid):
                    raise TypeError('Each sid ({}) must be an int'.format(type(sid)))
                if sid not in self._subjects:
                    raise IndexError('Subject {} not found in subjects ({})'.format(
                        sid, list(self._subjects.keys())))
        else:
            raise TypeError('`sids` ({}) type not recognized'.format(type(sids)))
        if isnumeric(times):
            times = [times]
        elif isarray(times):
            for t in times:
                if not isnumeric(t):
                    raise TypeError('Each time ({}) must be a numeric'.format(type(t)))
        else:
            raise TypeError('`times` ({}) type not recognized'.format(type(times)))

        for t in times:
            for sid in sids:
                subj = self._subjects[sid]
                if t in subj.times:
                    subj.qpcr.pop(t, None)
                    subj.reads.pop(t,None)
                    subj.times = np.sort(list(subj.reads.keys()))

    def normalize_qpcr(self, max_value):
        '''Normalize the qPCR values such that the largest value is the max value
        over all the subjects

        Parameters
        ----------
        max_value : float, int
            This is the maximum qPCR value to
        '''
        if type(max_value) not in [int, float]:
            raise ValueError('max_value ({}) must either be an int or a float'.format(
                type(max_value)))

        if self.qpcr_normalization_factor is not None:
            logging.warning('qPCR is already rescaled. unscaling and rescaling')
            self.denormalize_qpcr()

        temp_max = -1
        for subj in self:
            for key in subj.qpcr:
                temp_max = np.max([temp_max, subj.qpcr[key].mean])

        self.qpcr_normalization_factor = max_value/temp_max
        logging.info('max_value found: {}, scaling_factor: {}'.format(
            temp_max, self.qpcr_normalization_factor))

        for subj in self:
            for key in subj.qpcr:
                subj.qpcr[key].set_scaling_factor(scaling_factor=
                    self.qpcr_normalization_factor)
        return self

    def denormalize_qpcr(self):
        '''Denormalizes the qpcr values if necessary
        '''
        if self.qpcr_normalization_factor is None:
            logging.warning('qPCR is not normalized. Doing nothing')
            return
        for subj in self:
            for key in subj.qpcr:
                subj.qpcr[key].set_scaling_factor(scaling_factor=1)
        self.qpcr_normalization_factor = None
        return self

    def add_perturbation(self, a, end=None, name=None):
        '''Add a perturbation. 
        
        We can either do this by passing a perturbation object 
        (if we do this then we do not need to specify `end`) or we can 
        specify the start and stop times (if we do this them we need to
        specify `end`).

        Parameters
        ----------
        a : numeric, BasePerturbation
            If this is a numeric, then this corresponds to the start
            time of the perturbation. If this is a Pertubration object
            then we just add this.
        end : numeric
            Only necessary if `a` is a numeric
        name : str, None
            Only necessary if `a` is a numeric. Name of the perturbation
        '''
        if self.perturbations is None:
            self.perturbations = []
        if isnumeric(a):
            if not isnumeric(end):
                raise ValueError('If `a` is a numeric, then `end` ({}) ' \
                    'needs to be a numeric'.format(type(end)))
            self.perturbations.append(BasePerturbation(start=a, end=end, name=name))
        elif isperturbation(a):
            self.perturbations.append(a)
        else:
            raise ValueError('`a` ({}) must be a subclass of ' \
                'pl.base.BasePerturbation or a numeric'.format(type(a)))
        return self
        
    def split_on_perturbations(self):
        '''Make new subjects for the time points that are divided by perturbations. 
        Throw out all of the data  where the perturbations are active.
        '''
        for subj in self:
            subj._split_on_perturbations()
        return self
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="pylab.base.DEFAULT_TAXA_NAME" class="name">var <span class="ident">DEFAULT_TAXA_NAME</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="pylab.base.SEQUENCE_COLUMN_LABEL" class="name">var <span class="ident">SEQUENCE_COLUMN_LABEL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="pylab.base.isotu">
    <p>def <span class="ident">isotu</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of OTU</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of OTU</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type OTU, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.isotu', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.isotu" class="source">
    <pre><code>def isotu(x):
    '''Checks whether the input is a subclass of OTU

    Parameters
    ----------
    x : any
        Input instance to check the type of OTU
    
    Returns
    -------
    bool
        True if `x` is of type OTU, else False
    '''
    return x is not None and issubclass(x.__class__, OTU)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.base.isotuset">
    <p>def <span class="ident">isotuset</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of OTUSet</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of OTUSet</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type OTUSet, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.isotuset', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.isotuset" class="source">
    <pre><code>def isotuset(x):
    '''Checks whether the input is a subclass of OTUSet

    Parameters
    ----------
    x : any
        Input instance to check the type of OTUSet
    
    Returns
    -------
    bool
        True if `x` is of type OTUSet, else False
    '''
    return x is not None and issubclass(x.__class__, OTUSet)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.base.isperturbation">
    <p>def <span class="ident">isperturbation</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of BasePerturbation</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of BasePerturbation</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type BasePerturbation, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.isperturbation', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.isperturbation" class="source">
    <pre><code>def isperturbation(x):
    '''Checks whether the input is a subclass of BasePerturbation

    Parameters
    ----------
    x : any
        Input instance to check the type of BasePerturbation
    
    Returns
    -------
    bool
        True if `x` is of type BasePerturbation, else False
    '''
    return x is not None and issubclass(x.__class__, BasePerturbation)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.base.isqpcrdata">
    <p>def <span class="ident">isqpcrdata</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of qPCRData</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of qPCRData</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type qPCRData, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.isqpcrdata', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.isqpcrdata" class="source">
    <pre><code>def isqpcrdata(x):
    '''Checks whether the input is a subclass of qPCRData

    Parameters
    ----------
    x : any
        Input instance to check the type of qPCRData
    
    Returns
    -------
    bool
        True if `x` is of type qPCRData, else False
    '''
    return x is not None and issubclass(x.__class__, qPCRdata)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.base.issavable">
    <p>def <span class="ident">issavable</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of Savable</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of Savable</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type Savable, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.issavable', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.issavable" class="source">
    <pre><code>def issavable(x):
    '''Checks whether the input is a subclass of Savable

    Parameters
    ----------
    x : any
        Input instance to check the type of Savable
    
    Returns
    -------
    bool
        True if `x` is of type Savable, else False
    '''
    return x is not None and issubclass(x.__class__, Saveable)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.base.issubject">
    <p>def <span class="ident">issubject</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of Subject</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of Subject</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type Subject, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.issubject', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.issubject" class="source">
    <pre><code>def issubject(x):
    '''Checks whether the input is a subclass of Subject

    Parameters
    ----------
    x : any
        Input instance to check the type of Subject
    
    Returns
    -------
    bool
        True if `x` is of type Subject, else False
    '''
    return x is not None and issubclass(x.__class__, Subject)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.base.issubjectset">
    <p>def <span class="ident">issubjectset</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of SubjectSet</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of SubjectSet</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type SubjectSet, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.issubjectset', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.issubjectset" class="source">
    <pre><code>def issubjectset(x):
    '''Checks whether the input is a subclass of SubjectSet

    Parameters
    ----------
    x : any
        Input instance to check the type of SubjectSet
    
    Returns
    -------
    bool
        True if `x` is of type SubjectSet, else False
    '''
    return x is not None and issubclass(x.__class__, SubjectSet)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="pylab.base.istraceable">
    <p>def <span class="ident">istraceable</span>(</p><p>x)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks whether the input is a subclass of Traceable</p>
<h2>Parameters</h2>
<p>x : any
    Input instance to check the type of Traceable</p>
<h2>Returns</h2>
<p>bool
    True if <code>x</code> is of type Traceable, else False</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.istraceable', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.istraceable" class="source">
    <pre><code>def istraceable(x):
    '''Checks whether the input is a subclass of Traceable

    Parameters
    ----------
    x : any
        Input instance to check the type of Traceable
    
    Returns
    -------
    bool
        True if `x` is of type Traceable, else False
    '''
    return x is not None and issubclass(x.__class__, Traceable)
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="pylab.base.BasePerturbation" class="name">class <span class="ident">BasePerturbation</span></p>
      
  
    <div class="desc"><p>Base perturbation class.</p>
<p>We assume that the <code>start</code> is when the first perturbation happend (affects the next time point) and 
<code>end</code> is the last time that it gets affected</p>
<h2>Paramters</h2>
<p>start : float, int
    This is the start of the perturbation (it will afect the next time point)
end : float, int
    This is the end of the perturbation (this is the last time point the 
    perturbation will affect)
name : str, None
    This is the name of the perturabtion. If nothing is given then it will be None</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.BasePerturbation', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.BasePerturbation" class="source">
    <pre><code>class BasePerturbation:
    '''Base perturbation class.

    We assume that the `start` is when the first perturbation happend (affects the next time point) and 
    `end` is the last time that it gets affected

    Paramters
    ---------
    start : float, int
        This is the start of the perturbation (it will afect the next time point)
    end : float, int
        This is the end of the perturbation (this is the last time point the 
        perturbation will affect)
    name : str, None
        This is the name of the perturabtion. If nothing is given then it will be None
    '''
    def __init__(self, start, end, name=None):
        if not isnumeric(start):
            raise TypeError('`start` ({}) must be a numeric'.format(type(start)))
        if not isnumeric(end):
            raise TypeError('`end` ({}) must be a numeric'.format(type(end)))
        if end < start:
            raise ValueError('`end` ({}) must be >= `start` ({})'.format(end, start))
        if name is not None:
            if not isstr(name):
                raise TypeError('`name` ({}) must be a str'.format(type(name)))
        self.start = start
        self.end = end
        self.name = name

    def isactive(self, time):
        '''Returns a `bool` if the perturbation is on at time `time`.

        Parameters
        ----------
        time : float, int
            Time to check
        '''
        return time > self.start and time <= self.end

    def timetuple(self):
        '''Returns the time tuple of the start and end

        Paramters
        ---------
        None

        Returns
        -------
        2-tuple
            (start,end) as floats
        '''
        return (self.start, self.end)

    def __str__(self):
        return 'Perturbation\n\tstart: {}\n\tend:{}'.format(
            self.start, self.end)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.BasePerturbation">BasePerturbation</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.BasePerturbation.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, start, end, name=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.BasePerturbation.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.BasePerturbation.__init__" class="source">
    <pre><code>def __init__(self, start, end, name=None):
    if not isnumeric(start):
        raise TypeError('`start` ({}) must be a numeric'.format(type(start)))
    if not isnumeric(end):
        raise TypeError('`end` ({}) must be a numeric'.format(type(end)))
    if end < start:
        raise ValueError('`end` ({}) must be >= `start` ({})'.format(end, start))
    if name is not None:
        if not isstr(name):
            raise TypeError('`name` ({}) must be a str'.format(type(name)))
    self.start = start
    self.end = end
    self.name = name
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.BasePerturbation.isactive">
    <p>def <span class="ident">isactive</span>(</p><p>self, time)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a <code>bool</code> if the perturbation is on at time <code>time</code>.</p>
<h2>Parameters</h2>
<p>time : float, int
    Time to check</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.BasePerturbation.isactive', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.BasePerturbation.isactive" class="source">
    <pre><code>def isactive(self, time):
    '''Returns a `bool` if the perturbation is on at time `time`.
    Parameters
    ----------
    time : float, int
        Time to check
    '''
    return time > self.start and time <= self.end
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.BasePerturbation.timetuple">
    <p>def <span class="ident">timetuple</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the time tuple of the start and end</p>
<h2>Paramters</h2>
<p>None</p>
<h2>Returns</h2>
<p>2-tuple
    (start,end) as floats</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.BasePerturbation.timetuple', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.BasePerturbation.timetuple" class="source">
    <pre><code>def timetuple(self):
    '''Returns the time tuple of the start and end
    Paramters
    ---------
    None
    Returns
    -------
    2-tuple
        (start,end) as floats
    '''
    return (self.start, self.end)
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.BasePerturbation.end" class="name">var <span class="ident">end</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.BasePerturbation.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.BasePerturbation.start" class="name">var <span class="ident">start</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.CustomOrderedDict" class="name">class <span class="ident">CustomOrderedDict</span></p>
      
  
    <div class="desc"><p>Order is an initialized version of self.keys() -&gt; much more efficient
index maps the key to the index in order</p>
<p>order (list)
    - same as a numpy version of the keys in order
index (dict)
    - Maps the key to the index that it was inserted in</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.CustomOrderedDict', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.CustomOrderedDict" class="source">
    <pre><code>class CustomOrderedDict(dict):
    '''Order is an initialized version of self.keys() -> much more efficient
    index maps the key to the index in order

    order (list)
        - same as a numpy version of the keys in order
    index (dict)
        - Maps the key to the index that it was inserted in
    '''

    def __init__(self, *args, **kwargs):
        '''Extension of the OrderedDict

        Paramters
        ---------
        args, kwargs : Arguments
            These are extra arguments to initialize the baseline OrderedDict
        '''
        dict.__init__(self, *args, **kwargs)
        self.order = None
        self.index = None

    def update_order(self):
        '''This will update the reverse dictionary
        '''
        self.order = np.array(list(self.keys()))
        self.index = {}
        for i, otu in enumerate(self.order):
            self.index[otu] = i
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.CustomOrderedDict">CustomOrderedDict</a></li>
          <li>builtins.dict</li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.CustomOrderedDict.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Extension of the OrderedDict</p>
<h2>Paramters</h2>
<p>args, kwargs : Arguments
    These are extra arguments to initialize the baseline OrderedDict</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.CustomOrderedDict.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.CustomOrderedDict.__init__" class="source">
    <pre><code>def __init__(self, *args, **kwargs):
    '''Extension of the OrderedDict
    Paramters
    ---------
    args, kwargs : Arguments
        These are extra arguments to initialize the baseline OrderedDict
    '''
    dict.__init__(self, *args, **kwargs)
    self.order = None
    self.index = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.CustomOrderedDict.update_order">
    <p>def <span class="ident">update_order</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This will update the reverse dictionary</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.CustomOrderedDict.update_order', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.CustomOrderedDict.update_order" class="source">
    <pre><code>def update_order(self):
    '''This will update the reverse dictionary
    '''
    self.order = np.array(list(self.keys()))
    self.index = {}
    for i, otu in enumerate(self.order):
        self.index[otu] = i
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.CustomOrderedDict.index" class="name">var <span class="ident">index</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.CustomOrderedDict.order" class="name">var <span class="ident">order</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.OTU" class="name">class <span class="ident">OTU</span></p>
      
  
    <div class="desc"><p>Wrapper class for a single OTU</p>
<h2>Parameters</h2>
<p>name : str
    Name given to the OTU 
sequence : str
    Base Pair sequence
idx : int
    The index that the otu occurs</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTU', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTU" class="source">
    <pre><code>class OTU:
    '''Wrapper class for a single OTU

    Parameters
    ----------
    name : str
        Name given to the OTU 
    sequence : str
        Base Pair sequence
    idx : int
        The index that the otu occurs
    '''
    def __init__(self, name, sequence, idx):
        self.name = name
        self.sequence = sequence
        self.idx = idx
        if sequence is not None:
            self._sequence_as_array = np.array(list(sequence))
        else:
            self._sequence_as_array = None
        # Initialize the taxonomies to nothing
        self.taxonomy = {
            'kingdom': DEFAULT_TAXA_NAME,
            'phylum': DEFAULT_TAXA_NAME,
            'class': DEFAULT_TAXA_NAME,
            'order': DEFAULT_TAXA_NAME,
            'family': DEFAULT_TAXA_NAME,
            'genus': DEFAULT_TAXA_NAME,
            'otu': self.name}
        self.id = id(self)

    def __getitem__(self,key):
        return self.taxonomy[key.lower()]

    def __eq__(self, val):
        '''Compares different OTUs between each other. Checks all of the attributes but the id

        Parameters
        ----------
        val : any
            This is what we are checking if they are equivalent
        '''
        if type(val) != OTU:
            return False
        if self.name != val.name:
            return False
        if self.sequence != val.sequence:
            return False
        for k,v in self.taxonomy.items():
            if v != val.taxonomy[k]:
                return False
        return True

    def __str__(self):
        return 'OTU\n\tid: {}\n\tidx: {}\n\tname: {}\n' \
            '\ttaxonomy:\n\t\tkingdom: {}\n\t\tphylum: {}\n' \
            '\t\tclass: {}\n\t\torder: {}\n\t\tfamily: {}\n' \
            '\t\tgenus: {}'.format(
            self.id, self.idx, self.name,
            self.taxonomy['kingdom'], self.taxonomy['phylum'],
            self.taxonomy['class'], self.taxonomy['order'],
            self.taxonomy['family'], self.taxonomy['genus'])

    def set_taxonomy(self, tax_kingdom=None, tax_phylum=None, tax_class=None,
        tax_order=None, tax_family=None, tax_genus=None):
        '''Sets the taxonomy of the parts that are specified

        Parameters
        ----------
        tax_kingdom, tax_phylum, tax_class, tax_order, tax_family, tax_genus : str
            'kingdom', 'phylum', 'class', 'order', 'family', 'genus'
            Name of the taxa for each respective level
        '''
        if tax_kingdom is not None:
            self.taxonomy['kingdom'] = tax_kingdom
        if tax_phylum is not None:
            self.taxonomy['phylum'] = tax_phylum
        if tax_class is not None:
            self.taxonomy['class'] = tax_class
        if tax_order is not None:
            self.taxonomy['order'] = tax_order
        if tax_family is not None:
            self.taxonomy['family'] = tax_family
        if tax_genus is not None:
            self.taxonomy['genus'] = tax_genus

        return self

    def get_lineage(self, level=None):
        '''Returns a tuple of the lineage in order from Kingdom to the level
        indicated. Default value for level is `otu`

        Parameters
        ----------
        level : str, Optional
            The taxonomic level you want the lineage until
            If nothing is provided, it returns the entire taxonomic lineage
            Example:
                level = 'class'
                returns a tuple of (kingdom, phylum, class)
        '''
        a =  (self.taxonomy['kingdom'], self.taxonomy['phylum'], self.taxonomy['class'],
            self.taxonomy['order'], self.taxonomy['family'], self.taxonomy['genus'],
            self.taxonomy['otu'])

        if level is None:
            return a
        if level == 'otu':
            return a
        elif level == 'genus':
            return a[:-1]
        elif level == 'family':
            return a[:-2]
        elif level == 'order':
            return a[:-3]
        elif level == 'class':
            return a[:-4]
        elif level == 'phylum':
            return a[:-5]
        elif level == 'kingdom':
            return a[:-6]
        else:
            raise ValueError('level `{}` was not recognized'.format(level))
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.OTU">OTU</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.OTU.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, sequence, idx)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTU.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTU.__init__" class="source">
    <pre><code>def __init__(self, name, sequence, idx):
    self.name = name
    self.sequence = sequence
    self.idx = idx
    if sequence is not None:
        self._sequence_as_array = np.array(list(sequence))
    else:
        self._sequence_as_array = None
    # Initialize the taxonomies to nothing
    self.taxonomy = {
        'kingdom': DEFAULT_TAXA_NAME,
        'phylum': DEFAULT_TAXA_NAME,
        'class': DEFAULT_TAXA_NAME,
        'order': DEFAULT_TAXA_NAME,
        'family': DEFAULT_TAXA_NAME,
        'genus': DEFAULT_TAXA_NAME,
        'otu': self.name}
    self.id = id(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.OTU.get_lineage">
    <p>def <span class="ident">get_lineage</span>(</p><p>self, level=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a tuple of the lineage in order from Kingdom to the level
indicated. Default value for level is <code>otu</code></p>
<h2>Parameters</h2>
<p>level : str, Optional
    The taxonomic level you want the lineage until
    If nothing is provided, it returns the entire taxonomic lineage
    Example:
        level = 'class'
        returns a tuple of (kingdom, phylum, class)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTU.get_lineage', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTU.get_lineage" class="source">
    <pre><code>def get_lineage(self, level=None):
    '''Returns a tuple of the lineage in order from Kingdom to the level
    indicated. Default value for level is `otu`
    Parameters
    ----------
    level : str, Optional
        The taxonomic level you want the lineage until
        If nothing is provided, it returns the entire taxonomic lineage
        Example:
            level = 'class'
            returns a tuple of (kingdom, phylum, class)
    '''
    a =  (self.taxonomy['kingdom'], self.taxonomy['phylum'], self.taxonomy['class'],
        self.taxonomy['order'], self.taxonomy['family'], self.taxonomy['genus'],
        self.taxonomy['otu'])
    if level is None:
        return a
    if level == 'otu':
        return a
    elif level == 'genus':
        return a[:-1]
    elif level == 'family':
        return a[:-2]
    elif level == 'order':
        return a[:-3]
    elif level == 'class':
        return a[:-4]
    elif level == 'phylum':
        return a[:-5]
    elif level == 'kingdom':
        return a[:-6]
    else:
        raise ValueError('level `{}` was not recognized'.format(level))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.OTU.set_taxonomy">
    <p>def <span class="ident">set_taxonomy</span>(</p><p>self, tax_kingdom=None, tax_phylum=None, tax_class=None, tax_order=None, tax_family=None, tax_genus=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the taxonomy of the parts that are specified</p>
<h2>Parameters</h2>
<p>tax_kingdom, tax_phylum, tax_class, tax_order, tax_family, tax_genus : str
    'kingdom', 'phylum', 'class', 'order', 'family', 'genus'
    Name of the taxa for each respective level</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTU.set_taxonomy', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTU.set_taxonomy" class="source">
    <pre><code>def set_taxonomy(self, tax_kingdom=None, tax_phylum=None, tax_class=None,
    tax_order=None, tax_family=None, tax_genus=None):
    '''Sets the taxonomy of the parts that are specified
    Parameters
    ----------
    tax_kingdom, tax_phylum, tax_class, tax_order, tax_family, tax_genus : str
        'kingdom', 'phylum', 'class', 'order', 'family', 'genus'
        Name of the taxa for each respective level
    '''
    if tax_kingdom is not None:
        self.taxonomy['kingdom'] = tax_kingdom
    if tax_phylum is not None:
        self.taxonomy['phylum'] = tax_phylum
    if tax_class is not None:
        self.taxonomy['class'] = tax_class
    if tax_order is not None:
        self.taxonomy['order'] = tax_order
    if tax_family is not None:
        self.taxonomy['family'] = tax_family
    if tax_genus is not None:
        self.taxonomy['genus'] = tax_genus
    return self
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.OTU.id" class="name">var <span class="ident">id</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTU.idx" class="name">var <span class="ident">idx</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTU.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTU.sequence" class="name">var <span class="ident">sequence</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTU.taxonomy" class="name">var <span class="ident">taxonomy</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.OTUSet" class="name">class <span class="ident">OTUSet</span></p>
      
  
    <div class="desc"><p>Wraps a set of <code>OTU</code> objects. You can get the OTU object via the
OTU id, OTU name, or OTU sequence.
Provides functionality for aggregating and getting subsets for lineages.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet" class="source">
    <pre><code>class OTUSet(Saveable):
    '''Wraps a set of `OTU` objects. You can get the OTU object via the
    OTU id, OTU name, or OTU sequence.
    Provides functionality for aggregating and getting subsets for lineages.
    '''

    def __init__(self, df=None):
        '''Load data from a dataframe

        Assumes the frame has the following columns:
            - sequence
            - name
            - taxonomy
                * kingdom, phylum, class, order, family, genus, species, otu

        Parameters
        ----------
        df - pandas.DataFrame, Optional
            DataFrame containing the required information (Taxonomy, sequence).
            If nothing is passed in, it will be an empty set.
        '''
        self.ids = CustomOrderedDict()
        self.seqs = CustomOrderedDict()
        self.names = CustomOrderedDict()
        self.index = []
        self._len = 0

        # Add all of the OTUs from the dataframe if necessary
        if df is not None:
            df = df.rename(str.lower, axis='columns')
            for name in df.index:
                self.add_otu(
                    name=name,
                    sequence=df[SEQUENCE_COLUMN_LABEL][name])
                self.names[name].set_taxonomy(
                    tax_kingdom=df.loc[name]['kingdom'],
                    tax_phylum=df.loc[name]['phylum'],
                    tax_class=df.loc[name]['class'],
                    tax_order=df.loc[name]['order'],
                    tax_family=df.loc[name]['family'],
                    tax_genus=df.loc[name]['genus'])

    def __contains__(self,key):
        try:
            self[key]
            return True
        except:
            return False

    def __getitem__(self,key):
        '''Get an OTU by either its sequence, name, index, or id

        Parameters
        ----------
        key : str, int
            Key to reference the OTU
        '''
        if isotu(key):
            return key
        if key in self.ids:
            return self.ids[key]
        elif isint(key):
            return self.index[key]
        elif key in self.names:
            return self.names[key]
        elif isotu(key):
            return key
        elif key in self.seqs:
            return self.seqs[key]
        else:
            raise IndexError('`{}` ({}) was not found as a name, sequence, index, or id'.format(
                key, type(key)))

    def __iter__(self):
        '''Returns each OTU obejct in order
        '''
        for otu in self.index:
            yield otu

    @property
    def n_otus(self):
        '''Alias for __len__
        '''
        return self._len

    def __len__(self):
        '''Return the number of OTUs in the OTUSet
        '''
        return self._len

    def add_otu(self, name, sequence):
        '''Adds an OTU to the set

        Parameters
        ----------
        name : str
            This is the name of the OTU
        sequence : str
            This is the sequence of the OTU
        '''
        otu = OTU(name=name, sequence=sequence, idx=self._len)
        self.ids[otu.id] = otu
        self.seqs[otu.sequence] = otu
        self.names[otu.name] = otu
        self.index.append(otu)

        # update the order of the OTUs
        self.ids.update_order()
        self.seqs.update_order()
        self.names.update_order()
        self._len += 1

        return self

    def del_otu(self, otu):
        '''Deletes the OTU from the set.

        Parameters
        ----------
        otu : str, int, OTU
            Can either be the name, sequence, or the ID of the OTU
        '''
        # Get the ID
        if type(otu) == OTU:
            pass
        elif otu in self.ids:
            otu = self.ids[otu]
        elif otu in self.seqs:
            otu = self.seqs[otu]
        elif otu in self.names:
            otu = self.names[otu]
        else:
            raise IndexError('otu ({}) was not found as an id, name, or sequence'.format(
                otu))
        oidx = self.ids.index[otu.id]

        # Delete the OTU from everything
        # otu = self[otu]
        self.ids.pop(otu.id, None)
        self.seqs.pop(otu.sequence, None)
        self.names.pop(otu.name, None)
        self.index.pop(oidx)

        # update the order of the OTUs
        self.ids.update_order()
        self.seqs.update_order()
        self.names.update_order()

        # Update the indices of the otus
        # Since everything points to the same object we only need to do it once
        for idx,otu in enumerate(self.ids.values()):
            otu.idx = idx

        self._len -= 1
        return self

    def taxonomic_similarity(self,oid1,oid2):
        '''Calculate the taxonomic similarity between OTU1 and OTU2
        Iterates through most broad to least broad taxonomic level and
        returns the fraction that are the same.

        Example:
            otu1.taxonomy = (A,B,C,D)
            otu2.taxonomy = (A,B,E,F)
            similarity = 0.5

            otu1.taxonomy = (A,B,C,D)
            otu2.taxonomy = (A,B,C,F)
            similarity = 0.75

            otu1.taxonomy = (A,B,C,D)
            otu2.taxonomy = (A,B,C,D)
            similarity = 1.0

            otu1.taxonomy = (X,Y,Z,M)
            otu2.taxonomy = (A,B,E,F)
            similarity = 0.0

        Parameters
        ----------
        oid1, oid2 : str, int
            The name, id, or sequence for the OTU
        '''
        if oid1 == oid2:
            return 1
        otu1 = self[oid1].get_lineage()
        otu2 = self[oid2].get_lineage()
        i = 0
        for a in otu1:
            if a == otu2[i]:
                i += 1
            else:
                break
        return i/7 # including OTU
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.OTUSet">OTUSet</a></li>
          <li><a href="#pylab.base.Saveable">Saveable</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.OTUSet.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, df=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Load data from a dataframe</p>
<p>Assumes the frame has the following columns:
    - sequence
    - name
    - taxonomy
        * kingdom, phylum, class, order, family, genus, species, otu</p>
<h2>Parameters</h2>
<p>df - pandas.DataFrame, Optional
    DataFrame containing the required information (Taxonomy, sequence).
    If nothing is passed in, it will be an empty set.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet.__init__" class="source">
    <pre><code>def __init__(self, df=None):
    '''Load data from a dataframe
    Assumes the frame has the following columns:
        - sequence
        - name
        - taxonomy
            * kingdom, phylum, class, order, family, genus, species, otu
    Parameters
    ----------
    df - pandas.DataFrame, Optional
        DataFrame containing the required information (Taxonomy, sequence).
        If nothing is passed in, it will be an empty set.
    '''
    self.ids = CustomOrderedDict()
    self.seqs = CustomOrderedDict()
    self.names = CustomOrderedDict()
    self.index = []
    self._len = 0
    # Add all of the OTUs from the dataframe if necessary
    if df is not None:
        df = df.rename(str.lower, axis='columns')
        for name in df.index:
            self.add_otu(
                name=name,
                sequence=df[SEQUENCE_COLUMN_LABEL][name])
            self.names[name].set_taxonomy(
                tax_kingdom=df.loc[name]['kingdom'],
                tax_phylum=df.loc[name]['phylum'],
                tax_class=df.loc[name]['class'],
                tax_order=df.loc[name]['order'],
                tax_family=df.loc[name]['family'],
                tax_genus=df.loc[name]['genus'])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.OTUSet.add_otu">
    <p>def <span class="ident">add_otu</span>(</p><p>self, name, sequence)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds an OTU to the set</p>
<h2>Parameters</h2>
<p>name : str
    This is the name of the OTU
sequence : str
    This is the sequence of the OTU</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet.add_otu', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet.add_otu" class="source">
    <pre><code>def add_otu(self, name, sequence):
    '''Adds an OTU to the set
    Parameters
    ----------
    name : str
        This is the name of the OTU
    sequence : str
        This is the sequence of the OTU
    '''
    otu = OTU(name=name, sequence=sequence, idx=self._len)
    self.ids[otu.id] = otu
    self.seqs[otu.sequence] = otu
    self.names[otu.name] = otu
    self.index.append(otu)
    # update the order of the OTUs
    self.ids.update_order()
    self.seqs.update_order()
    self.names.update_order()
    self._len += 1
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.OTUSet.del_otu">
    <p>def <span class="ident">del_otu</span>(</p><p>self, otu)</p>
    </div>
    

    
  
    <div class="desc"><p>Deletes the OTU from the set.</p>
<h2>Parameters</h2>
<p>otu : str, int, OTU
    Can either be the name, sequence, or the ID of the OTU</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet.del_otu', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet.del_otu" class="source">
    <pre><code>def del_otu(self, otu):
    '''Deletes the OTU from the set.
    Parameters
    ----------
    otu : str, int, OTU
        Can either be the name, sequence, or the ID of the OTU
    '''
    # Get the ID
    if type(otu) == OTU:
        pass
    elif otu in self.ids:
        otu = self.ids[otu]
    elif otu in self.seqs:
        otu = self.seqs[otu]
    elif otu in self.names:
        otu = self.names[otu]
    else:
        raise IndexError('otu ({}) was not found as an id, name, or sequence'.format(
            otu))
    oidx = self.ids.index[otu.id]
    # Delete the OTU from everything
    # otu = self[otu]
    self.ids.pop(otu.id, None)
    self.seqs.pop(otu.sequence, None)
    self.names.pop(otu.name, None)
    self.index.pop(oidx)
    # update the order of the OTUs
    self.ids.update_order()
    self.seqs.update_order()
    self.names.update_order()
    # Update the indices of the otus
    # Since everything points to the same object we only need to do it once
    for idx,otu in enumerate(self.ids.values()):
        otu.idx = idx
    self._len -= 1
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.OTUSet.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <a href="#pylab.base.Saveable.set_save_location"><code>set_save_location</code></a>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.OTUSet.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.OTUSet.taxonomic_similarity">
    <p>def <span class="ident">taxonomic_similarity</span>(</p><p>self, oid1, oid2)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate the taxonomic similarity between OTU1 and OTU2
Iterates through most broad to least broad taxonomic level and
returns the fraction that are the same.</p>
<p>Example:
    otu1.taxonomy = (A,B,C,D)
    otu2.taxonomy = (A,B,E,F)
    similarity = 0.5</p>
<pre><code>otu1.taxonomy = (A,B,C,D)
otu2.taxonomy = (A,B,C,F)
similarity = 0.75

otu1.taxonomy = (A,B,C,D)
otu2.taxonomy = (A,B,C,D)
similarity = 1.0

otu1.taxonomy = (X,Y,Z,M)
otu2.taxonomy = (A,B,E,F)
similarity = 0.0
</code></pre>
<h2>Parameters</h2>
<p>oid1, oid2 : str, int
    The name, id, or sequence for the OTU</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet.taxonomic_similarity', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet.taxonomic_similarity" class="source">
    <pre><code>def taxonomic_similarity(self,oid1,oid2):
    '''Calculate the taxonomic similarity between OTU1 and OTU2
    Iterates through most broad to least broad taxonomic level and
    returns the fraction that are the same.
    Example:
        otu1.taxonomy = (A,B,C,D)
        otu2.taxonomy = (A,B,E,F)
        similarity = 0.5
        otu1.taxonomy = (A,B,C,D)
        otu2.taxonomy = (A,B,C,F)
        similarity = 0.75
        otu1.taxonomy = (A,B,C,D)
        otu2.taxonomy = (A,B,C,D)
        similarity = 1.0
        otu1.taxonomy = (X,Y,Z,M)
        otu2.taxonomy = (A,B,E,F)
        similarity = 0.0
    Parameters
    ----------
    oid1, oid2 : str, int
        The name, id, or sequence for the OTU
    '''
    if oid1 == oid2:
        return 1
    otu1 = self[oid1].get_lineage()
    otu2 = self[oid2].get_lineage()
    i = 0
    for a in otu1:
        if a == otu2[i]:
            i += 1
        else:
            break
    return i/7 # including OTU
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.OTUSet.ids" class="name">var <span class="ident">ids</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTUSet.index" class="name">var <span class="ident">index</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTUSet.n_otus" class="name">var <span class="ident">n_otus</span></p>
            

            
  
    <div class="desc"><p>Alias for <strong>len</strong></p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTUSet.names" class="name">var <span class="ident">names</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.OTUSet.seqs" class="name">var <span class="ident">seqs</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.OTUSet.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.OTUSet.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.OTUSet.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.Saveable" class="name">class <span class="ident">Saveable</span></p>
      
  
    <div class="desc"><p>Implements baseline saving classes with pickle for classes</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Saveable', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Saveable" class="source">
    <pre><code>class Saveable:
    '''Implements baseline saving classes with pickle for classes
    '''
    def save(self, filename=None):
        '''Pickle the object

        Paramters
        ---------
        filename : str
            This is the location to store the file. Overrides the location if
            it is set using `pylab.base.Saveable.set_save_location`. If None
            it means that we are using the file location set in 
            set_location. 
        '''
        if filename is None:
            if not hasattr(self, '_save_loc'):
                raise TypeError('`filename` must be specified if you have not ' \
                    'set the save location')
            filename = self._save_loc
        
        with open(filename, 'wb') as output:  # Overwrites any existing file.
            pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls, filename):
        '''Unpickle the object

        Paramters
        ---------
        filename : str
            This is the location of the file to unpickle
        '''
        with open(filename, 'rb') as handle:
            b = pickle.load(handle)
        return b

    def set_save_location(self, filename):
        '''Set the save location for the object
        '''
        if not isstr(filename):
            raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
        self._save_loc = filename
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.Saveable">Saveable</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.Saveable.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <a href="#pylab.base.Saveable.set_save_location"><code>set_save_location</code></a>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Saveable.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Saveable.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Saveable.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Saveable.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Saveable.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.Saveable.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Saveable.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Saveable.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.Subject" class="name">class <span class="ident">Subject</span></p>
      
  
    <div class="desc"><p>Data for a single subject
The OTUSet order is done with respect to the ordering in the <code>reads_table</code>
Parameters</p>
<hr />
<p>parent : SubjectSet
    This is the parent class (we have a reverse pointer)
name : str
    This is the name of the subject</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject" class="source">
    <pre><code>class Subject(Saveable):
    '''Data for a single subject
    The OTUSet order is done with respect to the ordering in the `reads_table`
    Parameters
    ----------
    parent : SubjectSet
        This is the parent class (we have a reverse pointer)
    name : str
        This is the name of the subject
    '''
    def __init__(self, parent, name):
        self.name = name
        self.id = id(self)
        self.parent = parent
        self.otus = self.parent.otus
        self.qpcr = {}
        self.reads = {}
        self.times = np.asarray([])

    def set_from_tables(self, qpcr_table, reads_table):
        '''Set the qpcr and reads from pandas DataFrames

        Parameters
        ----------
        qpcr_table : pandas.DataFrame
            This is the qPCR table that holds all of the information for each of the samples
        reads_table : pandas.DataFrame
            This is the data for the reads table

        TODO add descritpion for how the table should be laid out
        '''
        raise NotImplementedError('This still needs to be tested/clarified if this is ' \
            'the format to have')
        qpcr = qpcr_table.values
        masses = qpcr[:,0].flatten()
        dilution_factor = qpcr[:,1].flatten()
        qpcr = qpcr[:,2:]
        times = np.asarray(qpcr_table.index)
        idxs = np.argsort(times)
        self.times = times[idxs]
        for idx in idxs:
            self.qpcr[times[idx]] = qPCRdata(
                cfus=qpcr[idx,:],
                mass=masses[idx],
                dilution_factor=dilution_factor[idx])

        # Reads - add in time ascending order (using times from qpcr)
        for t in self.times:
            self.reads[t] = np.asarray(reads_table[t])

    @property
    def perturbations(self):
        '''Returns the number of perturbation
        '''
        return len(self.parent.perturbations)

    def matrix(self, min_rel_abund=None):
        '''Make a numpy matrix out of our data - returns the raw reads,
        the relative abundance, and the absolute abundance.

        If there is no qPCR data, then the absolute abundance is set to None.

        Parameters
        ----------
        min_rel_abund : float, int, Optional
            This is the minimum relative abundance to add to the 'rel' matrix.
            If nothing is specified then nothing gets added
        '''
        if np.issubdtype(type(min_rel_abund), np.bool_):
            if not min_rel_abund:
                min_rel_abund = None
            else:
                raise ValueError('Invalid `min_rel_abund` type ({})'.format(
                    type(min_rel_abund)))

        if min_rel_abund is not None:
            if type(min_rel_abund) != float or type(min_rel_abund) != int:
                raise ValueError('if `min_rel_abund` ({}) is specified, it must ' \
                    'be a float or an int'.format(type(min_rel_abund)))

        shape = (len(self.otus), len(self.times))
        raw = np.zeros(shape=shape, dtype=int)
        rel = np.zeros(shape=shape, dtype=float)
        abs = np.zeros(shape=shape, dtype=float)

        if min_rel_abund is not None:
            rel += min_rel_abund

        for i,t in enumerate(self.times):
            raw[:,i] = self.reads[t]
            rel[:,i] = raw[:,i]/np.sum(raw[:,i])
        
        if len(self.qpcr) > 0:
            for i,t in enumerate(self.times):
                abs[:,i] = rel[:,i] * self.qpcr[t].mean
        else:
            abs = None

        return {'raw':raw, 'rel': rel, 'abs':abs}

    def df(self, **kwargs):
        '''Returns a dataframe of the data - same as matrix

        Parameters
        ----------
        These are the parameters for `matrix`
        '''
        d = self.matrix(**kwargs)
        index = self.otus.names.order
        times = self.times
        for key in d:
            d[key] = pd.DataFrame(data=d[key], index=index, columns=times)
        return d

    def read_depth(self, t=None):
        '''Get the read depth at time `t`. If nothing is given then return all
        of them

        Parameters
        ----------
        t : int, float, Optional
            Get the read depth at this time. If nothing is provided, all of the read depths for this 
            subject are returned
        '''
        if t is None:
            return np.sum(self.matrix()['raw'], axis=0)
        if t not in self.reads:
            raise ValueError('`t` ({}) not recognized. Valid times: {}'.format(
                t, self.times))
        return np.sum(self.reads[t])

    def cluster_by_taxlevel(self, dtype, drop_nan_taxa, taxlevel=None, index_formatter=None):
        '''Clusters the OTUs into the taxonomic level indicated in `taxlevel`

        Parameters
        ----------
        subj : pylab.base.Subject
            This is the subject that we are getting the data from
        taxlevel : str, None
            This is the taxa level to aggregate the data at. If it is 
            None then we do not do any collapsing (this is the same as 'otu')
        dtype : str
            This is the type of data to cluster. Options are:
                'raw': These are the counts
                'rel': This is the relative abundances
                'abs': This is the absolute abundance (qPCR * rel)
        drop_nan_taxa : bool
            If True, it will not plot taxas that are not specified (NaNs). If False, it
            will conglomerate all the taxas into a single category called 'Unclassified'
        index_formatter : str
            How to make the index using `pylab.util.otuname_formatter`. Note that you cannot
            specify anything at a lower taxonomic level than what youre clustering at. For 
            example, you cannot cluster at the 'class' level and then specify '%(genus)s' 
            in the index formatter.
            If nothing is specified then the whole taxonomy is returned.
        '''
        # Type checking
        if not isstr(dtype):
            raise TypeError('`dtype` ({}) must be a str'.format(type(dtype)))
        if dtype not in ['raw', 'rel', 'abs']:
            raise ValueError('`dtype` ({}) not recognized'.format(dtype))
        if not isbool(drop_nan_taxa):
            raise TypeError('`drop_nan_taxa` ({}) must be a bool'.format(
                type(drop_nan_taxa)))
        if taxlevel is None:
            taxlevel = 'otu'
        elif not isstr(taxlevel):
            raise TypeError('`taxlevel` ({}) must be a str'.format(type(taxlevel)))
        if taxlevel not in ['kingdom', 'phylum', 'class',  'order', 'family', 
            'genus', 'otu']:
            raise ValueError('`taxlevel` ({}) not recognized'.format(taxlevel))
        if index_formatter is not None:
            if not isstr(index_formatter):
                raise TypeError('`index_formatter` ({}) must be a str'.format(type(index_formatter)))
            
            # Check if it is valid
            vals = {'kingdom': 0, 'phylum': 1, 'class': 2,  'order': 3, 'family': 4, 
                'genus': 5, 'otu': 6}
            
            for tx in vals:
                if tx in index_formatter and vals[tx] > vals[taxlevel]:
                    raise ValueError('You are clustering at the {} level but are specifying' \
                        ' {} in the `index_formatter`. This does not make sense. Either cluster' \
                        'at a lower tax level or specify the `index_formatter` to a higher tax ' \
                        'level'.format(taxlevel, tx))
        else:
            # make it everything up to `taxlevel`
            taxes = ['kingdom', 'phylum', 'class',  'order', 'family', 'genus', 'otu']
            index_formatter = '%(kingdom)s'
            for i in range(1,len(taxes) + 1):
                if taxlevel == taxes[i-1]:
                    break
                index_formatter += ', %(' + taxes[i] + ')s'

        index_formatter = index_formatter.replace('%(otu)s', '%(name)s')

        # Everything is valid, get the data dataframe and the return dataframe
        df = self.df(min_rel_abund=None)[dtype]
        cols = list(df.columns)
        cols.append(taxlevel)
        dfnew = pd.DataFrame(columns = cols).set_index(taxlevel)

        # Get the level in the taxonomy, create a new entry if it is not there already
        taxas = {} # lineage -> label
        for i, otu in enumerate(self.otus):
            row = df.index[i]
            tax = otu.get_lineage(taxlevel)

            # Check if it is nan, drop if necessary
            if type(tax[-1]) == float:
                if drop_nan_taxa:
                    continue
                tax = list(tax)
                tax[-1] = 'Unclassified'
            tax = tuple(tax)
            tax = str(tax).replace("'", '')
            if tax in taxas:
                dfnew.loc[taxas[tax]] += df.loc[row]
            else:
                taxas[tax] = otuname_formatter(format=index_formatter, otu=otu, otus=self.otus)
                toadd = pd.DataFrame(np.array(list(df.loc[row])).reshape(1,-1),
                    index=[taxas[tax]], columns=dfnew.columns)
                dfnew = dfnew.append(toadd)
        
        return dfnew

    def _split_on_perturbations(self):
        '''If there are perturbations, then we take out the data on perturbations
        and we set the data in the different segments to different subjects

        Internal funciton, should not be used by the user
        '''
        if len(self.parent.perturbations) == 0:
            logging.info('No perturbations to split on, do nothing')
            return

        # Get the time intervals for each of the times that we are not on perturbations
        start_tidx = 0
        not_perts = []
        in_pert = False
        for i in range(len(self.times)):
            # check if the time is in a perturbation
            a = False
            for pert in self.parent.perturbations:
                start = pert.start
                end = pert.end
                # check if in the perturbation
                if self.times[i] > start and self.times[i] <= end:
                    a = True
                    break
            if a:
                # If the current time point is in a perturbation and we previously
                # have no been in a perturbation, this means we can add the previous
                # interval into the intervals that we want to keep
                if not in_pert:
                    not_perts.append((start_tidx, i))
                in_pert = True
            else:
                # If we are not currently in a perturbation but we previously were
                # then we restart to `start_tidx`
                if in_pert:
                    start_tidx = i
                    in_pert = False
        # If we have finished and we are out of a perturbation at the end, then
        # we can add the rest of the times at the end to a valid not in perturbation time
        if not in_pert:
            not_perts.append((start_tidx, len(self.times)))

        # For each of the time slices recorded, make a new subject
        if len(in_pert) == 0:
            raise ValueError('THere are perturbations ({}), this must not be zero.' \
                ' Something went wrong'.format(len(self.parent.perturbations)))
        ii = 0
        for start,end in not_perts:
            mid = self.name+'_{}'.format(ii)
            self.parent.add(name=mid)
            for i in range(start,end):
                t = self.times[i]
                self.parent[mid].qpcr[t] = self.qpcr[t]
                self.parent[mid].reads[t] = self.reads[t]
            self.parent[mid].times = self.times[start:end]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.Subject">Subject</a></li>
          <li><a href="#pylab.base.Saveable">Saveable</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, parent, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.__init__" class="source">
    <pre><code>def __init__(self, parent, name):
    self.name = name
    self.id = id(self)
    self.parent = parent
    self.otus = self.parent.otus
    self.qpcr = {}
    self.reads = {}
    self.times = np.asarray([])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.cluster_by_taxlevel">
    <p>def <span class="ident">cluster_by_taxlevel</span>(</p><p>self, dtype, drop_nan_taxa, taxlevel=None, index_formatter=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Clusters the OTUs into the taxonomic level indicated in <code>taxlevel</code></p>
<h2>Parameters</h2>
<p>subj : pylab.base.Subject
    This is the subject that we are getting the data from
taxlevel : str, None
    This is the taxa level to aggregate the data at. If it is 
    None then we do not do any collapsing (this is the same as 'otu')
dtype : str
    This is the type of data to cluster. Options are:
        'raw': These are the counts
        'rel': This is the relative abundances
        'abs': This is the absolute abundance (qPCR * rel)
drop_nan_taxa : bool
    If True, it will not plot taxas that are not specified (NaNs). If False, it
    will conglomerate all the taxas into a single category called 'Unclassified'
index_formatter : str
    How to make the index using <code>pylab.util.otuname_formatter</code>. Note that you cannot
    specify anything at a lower taxonomic level than what youre clustering at. For 
    example, you cannot cluster at the 'class' level and then specify '%(genus)s' 
    in the index formatter.
    If nothing is specified then the whole taxonomy is returned.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.cluster_by_taxlevel', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.cluster_by_taxlevel" class="source">
    <pre><code>def cluster_by_taxlevel(self, dtype, drop_nan_taxa, taxlevel=None, index_formatter=None):
    '''Clusters the OTUs into the taxonomic level indicated in `taxlevel`
    Parameters
    ----------
    subj : pylab.base.Subject
        This is the subject that we are getting the data from
    taxlevel : str, None
        This is the taxa level to aggregate the data at. If it is 
        None then we do not do any collapsing (this is the same as 'otu')
    dtype : str
        This is the type of data to cluster. Options are:
            'raw': These are the counts
            'rel': This is the relative abundances
            'abs': This is the absolute abundance (qPCR * rel)
    drop_nan_taxa : bool
        If True, it will not plot taxas that are not specified (NaNs). If False, it
        will conglomerate all the taxas into a single category called 'Unclassified'
    index_formatter : str
        How to make the index using `pylab.util.otuname_formatter`. Note that you cannot
        specify anything at a lower taxonomic level than what youre clustering at. For 
        example, you cannot cluster at the 'class' level and then specify '%(genus)s' 
        in the index formatter.
        If nothing is specified then the whole taxonomy is returned.
    '''
    # Type checking
    if not isstr(dtype):
        raise TypeError('`dtype` ({}) must be a str'.format(type(dtype)))
    if dtype not in ['raw', 'rel', 'abs']:
        raise ValueError('`dtype` ({}) not recognized'.format(dtype))
    if not isbool(drop_nan_taxa):
        raise TypeError('`drop_nan_taxa` ({}) must be a bool'.format(
            type(drop_nan_taxa)))
    if taxlevel is None:
        taxlevel = 'otu'
    elif not isstr(taxlevel):
        raise TypeError('`taxlevel` ({}) must be a str'.format(type(taxlevel)))
    if taxlevel not in ['kingdom', 'phylum', 'class',  'order', 'family', 
        'genus', 'otu']:
        raise ValueError('`taxlevel` ({}) not recognized'.format(taxlevel))
    if index_formatter is not None:
        if not isstr(index_formatter):
            raise TypeError('`index_formatter` ({}) must be a str'.format(type(index_formatter)))
        
        # Check if it is valid
        vals = {'kingdom': 0, 'phylum': 1, 'class': 2,  'order': 3, 'family': 4, 
            'genus': 5, 'otu': 6}
        
        for tx in vals:
            if tx in index_formatter and vals[tx] > vals[taxlevel]:
                raise ValueError('You are clustering at the {} level but are specifying' \
                    ' {} in the `index_formatter`. This does not make sense. Either cluster' \
                    'at a lower tax level or specify the `index_formatter` to a higher tax ' \
                    'level'.format(taxlevel, tx))
    else:
        # make it everything up to `taxlevel`
        taxes = ['kingdom', 'phylum', 'class',  'order', 'family', 'genus', 'otu']
        index_formatter = '%(kingdom)s'
        for i in range(1,len(taxes) + 1):
            if taxlevel == taxes[i-1]:
                break
            index_formatter += ', %(' + taxes[i] + ')s'
    index_formatter = index_formatter.replace('%(otu)s', '%(name)s')
    # Everything is valid, get the data dataframe and the return dataframe
    df = self.df(min_rel_abund=None)[dtype]
    cols = list(df.columns)
    cols.append(taxlevel)
    dfnew = pd.DataFrame(columns = cols).set_index(taxlevel)
    # Get the level in the taxonomy, create a new entry if it is not there already
    taxas = {} # lineage -> label
    for i, otu in enumerate(self.otus):
        row = df.index[i]
        tax = otu.get_lineage(taxlevel)
        # Check if it is nan, drop if necessary
        if type(tax[-1]) == float:
            if drop_nan_taxa:
                continue
            tax = list(tax)
            tax[-1] = 'Unclassified'
        tax = tuple(tax)
        tax = str(tax).replace("'", '')
        if tax in taxas:
            dfnew.loc[taxas[tax]] += df.loc[row]
        else:
            taxas[tax] = otuname_formatter(format=index_formatter, otu=otu, otus=self.otus)
            toadd = pd.DataFrame(np.array(list(df.loc[row])).reshape(1,-1),
                index=[taxas[tax]], columns=dfnew.columns)
            dfnew = dfnew.append(toadd)
    
    return dfnew
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.df">
    <p>def <span class="ident">df</span>(</p><p>self, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a dataframe of the data - same as matrix</p>
<h2>Parameters</h2>
<p>These are the parameters for <code>matrix</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.df', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.df" class="source">
    <pre><code>def df(self, **kwargs):
    '''Returns a dataframe of the data - same as matrix
    Parameters
    ----------
    These are the parameters for `matrix`
    '''
    d = self.matrix(**kwargs)
    index = self.otus.names.order
    times = self.times
    for key in d:
        d[key] = pd.DataFrame(data=d[key], index=index, columns=times)
    return d
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.matrix">
    <p>def <span class="ident">matrix</span>(</p><p>self, min_rel_abund=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Make a numpy matrix out of our data - returns the raw reads,
the relative abundance, and the absolute abundance.</p>
<p>If there is no qPCR data, then the absolute abundance is set to None.</p>
<h2>Parameters</h2>
<p>min_rel_abund : float, int, Optional
    This is the minimum relative abundance to add to the 'rel' matrix.
    If nothing is specified then nothing gets added</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.matrix', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.matrix" class="source">
    <pre><code>def matrix(self, min_rel_abund=None):
    '''Make a numpy matrix out of our data - returns the raw reads,
    the relative abundance, and the absolute abundance.
    If there is no qPCR data, then the absolute abundance is set to None.
    Parameters
    ----------
    min_rel_abund : float, int, Optional
        This is the minimum relative abundance to add to the 'rel' matrix.
        If nothing is specified then nothing gets added
    '''
    if np.issubdtype(type(min_rel_abund), np.bool_):
        if not min_rel_abund:
            min_rel_abund = None
        else:
            raise ValueError('Invalid `min_rel_abund` type ({})'.format(
                type(min_rel_abund)))
    if min_rel_abund is not None:
        if type(min_rel_abund) != float or type(min_rel_abund) != int:
            raise ValueError('if `min_rel_abund` ({}) is specified, it must ' \
                'be a float or an int'.format(type(min_rel_abund)))
    shape = (len(self.otus), len(self.times))
    raw = np.zeros(shape=shape, dtype=int)
    rel = np.zeros(shape=shape, dtype=float)
    abs = np.zeros(shape=shape, dtype=float)
    if min_rel_abund is not None:
        rel += min_rel_abund
    for i,t in enumerate(self.times):
        raw[:,i] = self.reads[t]
        rel[:,i] = raw[:,i]/np.sum(raw[:,i])
    
    if len(self.qpcr) > 0:
        for i,t in enumerate(self.times):
            abs[:,i] = rel[:,i] * self.qpcr[t].mean
    else:
        abs = None
    return {'raw':raw, 'rel': rel, 'abs':abs}
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.read_depth">
    <p>def <span class="ident">read_depth</span>(</p><p>self, t=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the read depth at time <code>t</code>. If nothing is given then return all
of them</p>
<h2>Parameters</h2>
<p>t : int, float, Optional
    Get the read depth at this time. If nothing is provided, all of the read depths for this 
    subject are returned</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.read_depth', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.read_depth" class="source">
    <pre><code>def read_depth(self, t=None):
    '''Get the read depth at time `t`. If nothing is given then return all
    of them
    Parameters
    ----------
    t : int, float, Optional
        Get the read depth at this time. If nothing is provided, all of the read depths for this 
        subject are returned
    '''
    if t is None:
        return np.sum(self.matrix()['raw'], axis=0)
    if t not in self.reads:
        raise ValueError('`t` ({}) not recognized. Valid times: {}'.format(
            t, self.times))
    return np.sum(self.reads[t])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <a href="#pylab.base.Saveable.set_save_location"><code>set_save_location</code></a>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.set_from_tables">
    <p>def <span class="ident">set_from_tables</span>(</p><p>self, qpcr_table, reads_table)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the qpcr and reads from pandas DataFrames</p>
<h2>Parameters</h2>
<p>qpcr_table : pandas.DataFrame
    This is the qPCR table that holds all of the information for each of the samples
reads_table : pandas.DataFrame
    This is the data for the reads table</p>
<p>TODO add descritpion for how the table should be laid out</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.set_from_tables', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.set_from_tables" class="source">
    <pre><code>def set_from_tables(self, qpcr_table, reads_table):
    '''Set the qpcr and reads from pandas DataFrames
    Parameters
    ----------
    qpcr_table : pandas.DataFrame
        This is the qPCR table that holds all of the information for each of the samples
    reads_table : pandas.DataFrame
        This is the data for the reads table
    TODO add descritpion for how the table should be laid out
    '''
    raise NotImplementedError('This still needs to be tested/clarified if this is ' \
        'the format to have')
    qpcr = qpcr_table.values
    masses = qpcr[:,0].flatten()
    dilution_factor = qpcr[:,1].flatten()
    qpcr = qpcr[:,2:]
    times = np.asarray(qpcr_table.index)
    idxs = np.argsort(times)
    self.times = times[idxs]
    for idx in idxs:
        self.qpcr[times[idx]] = qPCRdata(
            cfus=qpcr[idx,:],
            mass=masses[idx],
            dilution_factor=dilution_factor[idx])
    # Reads - add in time ascending order (using times from qpcr)
    for t in self.times:
        self.reads[t] = np.asarray(reads_table[t])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.Subject.id" class="name">var <span class="ident">id</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.Subject.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.Subject.otus" class="name">var <span class="ident">otus</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.Subject.parent" class="name">var <span class="ident">parent</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.Subject.perturbations" class="name">var <span class="ident">perturbations</span></p>
            

            
  
    <div class="desc"><p>Returns the number of perturbation</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.Subject.qpcr" class="name">var <span class="ident">qpcr</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.Subject.reads" class="name">var <span class="ident">reads</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.Subject.times" class="name">var <span class="ident">times</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.Subject.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Subject.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Subject.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.SubjectSet" class="name">class <span class="ident">SubjectSet</span></p>
      
  
    <div class="desc"><p>Holds data for all the subjects</p>
<h2>Paramters</h2>
<p>sequences : pd.DataFrame, Optional
    index: OTU names
    column: sequences
    These are the sequences for each one of the OTUs
taxonomy_table : pd.DataFrame, Optional
    index:
        - OTU names
        - Must be identical to the keys in <code>sequences</code> and the
          index in <code>reads_table</code>
    columns:
        - Must contain 'kingdom', 'phylum', 'class', 'order',
          'family', 'genus'
    data:
        - These are the names
otus : OTUSet, Optional
    If you already have an OTUSetobject, you can just use that</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet" class="source">
    <pre><code>class SubjectSet(Saveable):
    '''Holds data for all the subjects

    Paramters
    ---------
    sequences : pd.DataFrame, Optional
        index: OTU names
        column: sequences
        These are the sequences for each one of the OTUs
    taxonomy_table : pd.DataFrame, Optional
        index:
            - OTU names
            - Must be identical to the keys in `sequences` and the
              index in `reads_table`
        columns:
            - Must contain 'kingdom', 'phylum', 'class', 'order',
              'family', 'genus'
        data:
            - These are the names
    otus : OTUSet, Optional
        If you already have an OTUSetobject, you can just use that
    '''
    def __init__(self, sequences=None, taxonomy_table=None, otus=None):
        self.id = id(self)
        self._subjects = {}
        self.perturbations = None
        self.qpcr_normalization_factor = None
        if otus is not None:
            if not isotuset(otus):
                raise ValueError('If `otus` ({}) is specified, it must be an OTUSet' \
                    ' type'.format(type(otus)))
            self.otus = otus
            return

        if type(sequences) != pd.DataFrame:
            raise ValueError('`sequences` ({}) must be a dict'.format(
                type(sequences)))
        if taxonomy_table is not None:
            if type(taxonomy_table) != pd.DataFrame:
                raise ValueError('`taxonomy_table` ({}) must be a pandas.DataFrame object'.format(
                    type(taxonomy_table)))

        valid_cols = ['sequences']
        seq_cols = list(sequences.columns)
        for col in seq_cols:
            if col not in valid_cols:
                raise ValueError('column `{}` not in valid columns: {}'.format(
                    col, valid_cols))
        for col in valid_cols:
            if col not in seq_cols:
                raise ValueError('column `{}` not in sequence columns: {}'.format(
                    col, seq_cols))

        seq_keys = sequences.index
        if taxonomy_table is not None:
            tax_index = taxonomy_table.index
            for key in seq_keys:
                if key not in tax_index:
                    raise ValueError("key '{}' not in taxonomy index ({})".format(
                        key, tax_index))
            for key in tax_index:
                if key not in seq_keys:
                    raise ValueError("key '{}' not in sequence keys ({})".format(
                        key, seq_keys))

        # Check the columns for taxonomy_table if necessary
        # Every column in taxonomy_table has to be in valid_cols
        # NOT every column in valid_cols has to be in taxonomy_table
        if taxonomy_table is not None:
            valid_cols = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus']
            tax_cols = list(taxonomy_table.columns)
            tax_cols = [str(col).lower() for col in tax_cols]
            taxonomy_table.columns = tax_cols
            for col in tax_cols:
                if col not in valid_cols:
                    raise ValueError("col '{}' not in valid columns for taxonomy ({})".format(
                        col, valid_cols))

        # Everything is valid, make the otuset
        # OTUs
        self.otus = OTUSet()
        for otu_name in sequences.index:
            self.otus.add_otu(name=otu_name, sequence=sequences[otu_name])
            if taxonomy_table is not None:
                kwargs = {}
                for tax in tax_cols:
                    kwargs[tax] = taxonomy_table[tax][otu_name]
                self.otus[otu_name].set_taxonomy(**kwargs)

    def __getitem__(self, key):
        return self._subjects[key]

    def __len__(self):
        return len(self._subjects)

    def __iter__(self):
        for v in self._subjects.values():
            yield v

    def __contains__(self, key):
        return key in self._subjects

    def iloc(self, idx):
        '''Get the subject as an index

        Parameters
        ----------
        idx : int
            Index of the subject

        Returns
        -------
        pl.base.Subject
        '''
        for i,sid in enumerate(self._subjects):
            if i == idx:
                return self._subjects[sid]
        raise IndexError('Index ({}) not found'.format(idx))

    def add(self, name):
        '''Create a subject with the name `name`

        Parameters
        ----------
        name : str
            This is the name of the new subject
        '''
        if name not in self._subjects:
            self._subjects[name] = Subject(name=name, parent=self)
        return self

    def add_from_table(self, name, reads_table, qpcr_table):
        '''Adds a subject to the subject set

        Parameters
        ----------
        name : str
            This is the name of the subject
        qpcr_table, reads_table : pandas.DataFrame
            These specify the qpcr measurements
            index:
                - ['1.0','1.3', '2.2', ...] these are the time points in string
                  format
            columns:
                - ['mass', 'dilution factor', '1', '2', '3'] (for each of the 3 measurements)
            data:
                - these are the triplicate qpcr measurements
        reads_table : pandas.DataFrame
            index:
                - OTU names
                - Must be identical to the keys in `sequences` and the
                  index in `taxonomy_table`
            columns:
                - These are the time points in string format
                - These must be identical to the index in `qpcr_table`
            data:
                - Each one of the reads for each one of the OTUs
        '''
        # Type check
        if type(name) != str:
            raise ValueError('`name` ({}) must be a str'.format(type(name)))
        if type(qpcr_table) != pd.DataFrame:
            raise ValueError('`qpcr_table` ({}) must be a pandas.DataFrame object'.format(
                type(qpcr_table)))
        if type(reads_table) != pd.DataFrame:
            raise ValueError('`reads_table` ({}) must be a pandas.DataFrame object'.format(
                type(reads_table)))

        # Check OTU names are consistent
        read_index = reads_table.index
        for key in self.otus.names:
            if key not in read_index:
                raise ValueError("key '{}' not in reads index ({})".format(
                    key, read_index))
        for key in read_index:
            if key not in self.otus.names:
                raise ValueError("key '{}' not in sequence keys ({})".format(
                    key, self.otus.names))


        # Check time labels are consistent
        # First convert both to strs of floats where necessary
        reads_table.columns = [float(t) for t in reads_table.columns]
        qpcr_table.index = [float(t) for t in qpcr_table.index]

        qpcr_times = qpcr_table.index
        reads_times = reads_table.columns
        for key in qpcr_times:
            if key not in reads_times:
                raise ValueError("key '{}' not in times for reads ({})".format(
                    key, reads_times))
        for key in reads_times:
            if key not in qpcr_times:
                raise ValueError("key '{}' not in times for qpcr ({})".format(
                    key, qpcr_table))

        # Check the columns for qpcr_table
        valid_cols = ['dilution factor', 'mass', '1', '2', '3']
        qpcr_cols = list(qpcr_table.columns)
        qpcr_cols = [str(col).lower() for col in qpcr_cols]
        for col in qpcr_cols:
            if col not in valid_cols:
                raise ValueError("col '{}' not in valid columns for qpcr ({})".format(
                    col, valid_cols))
        for col in valid_cols:
            if col not in qpcr_cols:
                raise ValueError("col '{}' not in qpcr columns ({})".format(
                    col, qpcr_cols))

        # Check ordering of reads index is consistent with the otuset order
        if len(reads_table.index) != len(self.otus):
            raise ValueError('length of reads ({}) does not equal the right number ' \
                'of OTUs ({})'.format(len(reads_table.index), len(self.otus)))
        for i,name in enumerate(self.otus.names.order):
            if name != reads_table.index[i]:
                raise ValueError('The `{}`th row of the reads ({}) does not ' \
                    'correspond to the `{}`th OTU in OTUSet ({})'.format(
                        i,reads_table.index[i],i,name))
        self.add(name=name)
        self._subjects[name].set_from_tables(reads_table=reads_table,
            qpcr_table=qpcr_table)
        return self

    def pop_subject(self, sid):
        '''Remove the indicated subject id

        Parameters
        ----------
        sid : list(str), str, int
            This is the subject name/s or the index/es to pop out.
            Return a new SubjectSet with the specified subjects removed.
        '''
        if not isarray(sid):
            sids = [sid]
        else:
            sids = sid

        for i in range(len(sids)):
            if isint(sids[i]):
                sids[i] = list(self._subjects.keys())[sids[i]]
            elif not isstr(sids[i]):
                raise ValueError('`sid` ({}) must be a str'.format(type(sids[i])))
        ret = SubjectSet(otus=self.otus)
        ret.perturbations = self.perturbations
        ret.qpcr_normalization_factor = self.qpcr_normalization_factor

        for s in sids:
            if s in self._subjects:
                ret._subjects[s] =  self._subjects.pop(s, None)
            else:
                raise ValueError('`sid` ({}) not found'.format(sid))
        return ret

    def pop_otus(self, oids):
        '''Delete the OTUs indicated in oidxs. Updates the reads table and
        the internal OTUSet

        Parameters
        ----------
        oids : str, int, list(str/int)
            These are the identifiers for each of the OTU/s to delete
        '''
        if isint(oids):
            oids = [oids]
        if not isarray(oids):
            raise ValueError('`oids` ({}) must be an array'.format(type(oids)))

        # get indices
        oidxs = []
        for oid in oids:
            oidxs.append(self.otus[oid].idx)

        # Get the IDs
        ids = []
        for oid in oids:
            ids.append(self.otus[oid].id)

        # Delete the OTUs from otuset
        for oid in ids:
            if oid not in self.otus:
                logging.warning('otu `{}` not contained in otuset. skipping'.format(oid))
            otu = self.otus[oid]
            self.otus.del_otu(otu.id)

        # Delete the reads
        for subj in self:
            for t in subj.reads:
                subj.reads[t] = np.delete(subj.reads[t], oidxs)
        return self

    def pop_times(self, times, sids='all'):
        '''Discard the times in `times` for the subjects listed in `sids`.
        If a timepoint is not found in a subject, no error is thrown.

        Parameters
        ----------
        times : numeric, list(numeric)
            Time/s to delete
        sids : str, int, list(int)
            The Subject ID or a list of subject IDs that you want to delete the timepoints
            from. If it is a str:
                'all' - delete from all subjects
        '''
        if isstr(sids):
            if sids == 'all':
                sids = list(self._subjects.keys())
            else:
                raise ValueError('`sids` ({}) not recognized'.format(sids))
        elif isint(sids):
            if sids not in self._subjects:
                raise IndexError('`sid` ({}) not found in subjects'.format(
                    list(self._subjects.keys())))
            sids = [sids]
        elif isarray(sids):
            for sid in sids:
                if not isint(sid):
                    raise TypeError('Each sid ({}) must be an int'.format(type(sid)))
                if sid not in self._subjects:
                    raise IndexError('Subject {} not found in subjects ({})'.format(
                        sid, list(self._subjects.keys())))
        else:
            raise TypeError('`sids` ({}) type not recognized'.format(type(sids)))
        if isnumeric(times):
            times = [times]
        elif isarray(times):
            for t in times:
                if not isnumeric(t):
                    raise TypeError('Each time ({}) must be a numeric'.format(type(t)))
        else:
            raise TypeError('`times` ({}) type not recognized'.format(type(times)))

        for t in times:
            for sid in sids:
                subj = self._subjects[sid]
                if t in subj.times:
                    subj.qpcr.pop(t, None)
                    subj.reads.pop(t,None)
                    subj.times = np.sort(list(subj.reads.keys()))

    def normalize_qpcr(self, max_value):
        '''Normalize the qPCR values such that the largest value is the max value
        over all the subjects

        Parameters
        ----------
        max_value : float, int
            This is the maximum qPCR value to
        '''
        if type(max_value) not in [int, float]:
            raise ValueError('max_value ({}) must either be an int or a float'.format(
                type(max_value)))

        if self.qpcr_normalization_factor is not None:
            logging.warning('qPCR is already rescaled. unscaling and rescaling')
            self.denormalize_qpcr()

        temp_max = -1
        for subj in self:
            for key in subj.qpcr:
                temp_max = np.max([temp_max, subj.qpcr[key].mean])

        self.qpcr_normalization_factor = max_value/temp_max
        logging.info('max_value found: {}, scaling_factor: {}'.format(
            temp_max, self.qpcr_normalization_factor))

        for subj in self:
            for key in subj.qpcr:
                subj.qpcr[key].set_scaling_factor(scaling_factor=
                    self.qpcr_normalization_factor)
        return self

    def denormalize_qpcr(self):
        '''Denormalizes the qpcr values if necessary
        '''
        if self.qpcr_normalization_factor is None:
            logging.warning('qPCR is not normalized. Doing nothing')
            return
        for subj in self:
            for key in subj.qpcr:
                subj.qpcr[key].set_scaling_factor(scaling_factor=1)
        self.qpcr_normalization_factor = None
        return self

    def add_perturbation(self, a, end=None, name=None):
        '''Add a perturbation. 
        
        We can either do this by passing a perturbation object 
        (if we do this then we do not need to specify `end`) or we can 
        specify the start and stop times (if we do this them we need to
        specify `end`).

        Parameters
        ----------
        a : numeric, BasePerturbation
            If this is a numeric, then this corresponds to the start
            time of the perturbation. If this is a Pertubration object
            then we just add this.
        end : numeric
            Only necessary if `a` is a numeric
        name : str, None
            Only necessary if `a` is a numeric. Name of the perturbation
        '''
        if self.perturbations is None:
            self.perturbations = []
        if isnumeric(a):
            if not isnumeric(end):
                raise ValueError('If `a` is a numeric, then `end` ({}) ' \
                    'needs to be a numeric'.format(type(end)))
            self.perturbations.append(BasePerturbation(start=a, end=end, name=name))
        elif isperturbation(a):
            self.perturbations.append(a)
        else:
            raise ValueError('`a` ({}) must be a subclass of ' \
                'pl.base.BasePerturbation or a numeric'.format(type(a)))
        return self
        
    def split_on_perturbations(self):
        '''Make new subjects for the time points that are divided by perturbations. 
        Throw out all of the data  where the perturbations are active.
        '''
        for subj in self:
            subj._split_on_perturbations()
        return self
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.SubjectSet">SubjectSet</a></li>
          <li><a href="#pylab.base.Saveable">Saveable</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, sequences=None, taxonomy_table=None, otus=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.__init__" class="source">
    <pre><code>def __init__(self, sequences=None, taxonomy_table=None, otus=None):
    self.id = id(self)
    self._subjects = {}
    self.perturbations = None
    self.qpcr_normalization_factor = None
    if otus is not None:
        if not isotuset(otus):
            raise ValueError('If `otus` ({}) is specified, it must be an OTUSet' \
                ' type'.format(type(otus)))
        self.otus = otus
        return
    if type(sequences) != pd.DataFrame:
        raise ValueError('`sequences` ({}) must be a dict'.format(
            type(sequences)))
    if taxonomy_table is not None:
        if type(taxonomy_table) != pd.DataFrame:
            raise ValueError('`taxonomy_table` ({}) must be a pandas.DataFrame object'.format(
                type(taxonomy_table)))
    valid_cols = ['sequences']
    seq_cols = list(sequences.columns)
    for col in seq_cols:
        if col not in valid_cols:
            raise ValueError('column `{}` not in valid columns: {}'.format(
                col, valid_cols))
    for col in valid_cols:
        if col not in seq_cols:
            raise ValueError('column `{}` not in sequence columns: {}'.format(
                col, seq_cols))
    seq_keys = sequences.index
    if taxonomy_table is not None:
        tax_index = taxonomy_table.index
        for key in seq_keys:
            if key not in tax_index:
                raise ValueError("key '{}' not in taxonomy index ({})".format(
                    key, tax_index))
        for key in tax_index:
            if key not in seq_keys:
                raise ValueError("key '{}' not in sequence keys ({})".format(
                    key, seq_keys))
    # Check the columns for taxonomy_table if necessary
    # Every column in taxonomy_table has to be in valid_cols
    # NOT every column in valid_cols has to be in taxonomy_table
    if taxonomy_table is not None:
        valid_cols = ['kingdom', 'phylum', 'class', 'order', 'family', 'genus']
        tax_cols = list(taxonomy_table.columns)
        tax_cols = [str(col).lower() for col in tax_cols]
        taxonomy_table.columns = tax_cols
        for col in tax_cols:
            if col not in valid_cols:
                raise ValueError("col '{}' not in valid columns for taxonomy ({})".format(
                    col, valid_cols))
    # Everything is valid, make the otuset
    # OTUs
    self.otus = OTUSet()
    for otu_name in sequences.index:
        self.otus.add_otu(name=otu_name, sequence=sequences[otu_name])
        if taxonomy_table is not None:
            kwargs = {}
            for tax in tax_cols:
                kwargs[tax] = taxonomy_table[tax][otu_name]
            self.otus[otu_name].set_taxonomy(**kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.add">
    <p>def <span class="ident">add</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a subject with the name <code>name</code></p>
<h2>Parameters</h2>
<p>name : str
    This is the name of the new subject</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.add', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.add" class="source">
    <pre><code>def add(self, name):
    '''Create a subject with the name `name`
    Parameters
    ----------
    name : str
        This is the name of the new subject
    '''
    if name not in self._subjects:
        self._subjects[name] = Subject(name=name, parent=self)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.add_from_table">
    <p>def <span class="ident">add_from_table</span>(</p><p>self, name, reads_table, qpcr_table)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds a subject to the subject set</p>
<h2>Parameters</h2>
<p>name : str
    This is the name of the subject
qpcr_table, reads_table : pandas.DataFrame
    These specify the qpcr measurements
    index:
        - ['1.0','1.3', '2.2', ...] these are the time points in string
          format
    columns:
        - ['mass', 'dilution factor', '1', '2', '3'] (for each of the 3 measurements)
    data:
        - these are the triplicate qpcr measurements
reads_table : pandas.DataFrame
    index:
        - OTU names
        - Must be identical to the keys in <code>sequences</code> and the
          index in <code>taxonomy_table</code>
    columns:
        - These are the time points in string format
        - These must be identical to the index in <code>qpcr_table</code>
    data:
        - Each one of the reads for each one of the OTUs</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.add_from_table', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.add_from_table" class="source">
    <pre><code>def add_from_table(self, name, reads_table, qpcr_table):
    '''Adds a subject to the subject set
    Parameters
    ----------
    name : str
        This is the name of the subject
    qpcr_table, reads_table : pandas.DataFrame
        These specify the qpcr measurements
        index:
            - ['1.0','1.3', '2.2', ...] these are the time points in string
              format
        columns:
            - ['mass', 'dilution factor', '1', '2', '3'] (for each of the 3 measurements)
        data:
            - these are the triplicate qpcr measurements
    reads_table : pandas.DataFrame
        index:
            - OTU names
            - Must be identical to the keys in `sequences` and the
              index in `taxonomy_table`
        columns:
            - These are the time points in string format
            - These must be identical to the index in `qpcr_table`
        data:
            - Each one of the reads for each one of the OTUs
    '''
    # Type check
    if type(name) != str:
        raise ValueError('`name` ({}) must be a str'.format(type(name)))
    if type(qpcr_table) != pd.DataFrame:
        raise ValueError('`qpcr_table` ({}) must be a pandas.DataFrame object'.format(
            type(qpcr_table)))
    if type(reads_table) != pd.DataFrame:
        raise ValueError('`reads_table` ({}) must be a pandas.DataFrame object'.format(
            type(reads_table)))
    # Check OTU names are consistent
    read_index = reads_table.index
    for key in self.otus.names:
        if key not in read_index:
            raise ValueError("key '{}' not in reads index ({})".format(
                key, read_index))
    for key in read_index:
        if key not in self.otus.names:
            raise ValueError("key '{}' not in sequence keys ({})".format(
                key, self.otus.names))
    # Check time labels are consistent
    # First convert both to strs of floats where necessary
    reads_table.columns = [float(t) for t in reads_table.columns]
    qpcr_table.index = [float(t) for t in qpcr_table.index]
    qpcr_times = qpcr_table.index
    reads_times = reads_table.columns
    for key in qpcr_times:
        if key not in reads_times:
            raise ValueError("key '{}' not in times for reads ({})".format(
                key, reads_times))
    for key in reads_times:
        if key not in qpcr_times:
            raise ValueError("key '{}' not in times for qpcr ({})".format(
                key, qpcr_table))
    # Check the columns for qpcr_table
    valid_cols = ['dilution factor', 'mass', '1', '2', '3']
    qpcr_cols = list(qpcr_table.columns)
    qpcr_cols = [str(col).lower() for col in qpcr_cols]
    for col in qpcr_cols:
        if col not in valid_cols:
            raise ValueError("col '{}' not in valid columns for qpcr ({})".format(
                col, valid_cols))
    for col in valid_cols:
        if col not in qpcr_cols:
            raise ValueError("col '{}' not in qpcr columns ({})".format(
                col, qpcr_cols))
    # Check ordering of reads index is consistent with the otuset order
    if len(reads_table.index) != len(self.otus):
        raise ValueError('length of reads ({}) does not equal the right number ' \
            'of OTUs ({})'.format(len(reads_table.index), len(self.otus)))
    for i,name in enumerate(self.otus.names.order):
        if name != reads_table.index[i]:
            raise ValueError('The `{}`th row of the reads ({}) does not ' \
                'correspond to the `{}`th OTU in OTUSet ({})'.format(
                    i,reads_table.index[i],i,name))
    self.add(name=name)
    self._subjects[name].set_from_tables(reads_table=reads_table,
        qpcr_table=qpcr_table)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.add_perturbation">
    <p>def <span class="ident">add_perturbation</span>(</p><p>self, a, end=None, name=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a perturbation. </p>
<p>We can either do this by passing a perturbation object 
(if we do this then we do not need to specify <code>end</code>) or we can 
specify the start and stop times (if we do this them we need to
specify <code>end</code>).</p>
<h2>Parameters</h2>
<p>a : numeric, BasePerturbation
    If this is a numeric, then this corresponds to the start
    time of the perturbation. If this is a Pertubration object
    then we just add this.
end : numeric
    Only necessary if <code>a</code> is a numeric
name : str, None
    Only necessary if <code>a</code> is a numeric. Name of the perturbation</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.add_perturbation', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.add_perturbation" class="source">
    <pre><code>def add_perturbation(self, a, end=None, name=None):
    '''Add a perturbation. 
    
    We can either do this by passing a perturbation object 
    (if we do this then we do not need to specify `end`) or we can 
    specify the start and stop times (if we do this them we need to
    specify `end`).
    Parameters
    ----------
    a : numeric, BasePerturbation
        If this is a numeric, then this corresponds to the start
        time of the perturbation. If this is a Pertubration object
        then we just add this.
    end : numeric
        Only necessary if `a` is a numeric
    name : str, None
        Only necessary if `a` is a numeric. Name of the perturbation
    '''
    if self.perturbations is None:
        self.perturbations = []
    if isnumeric(a):
        if not isnumeric(end):
            raise ValueError('If `a` is a numeric, then `end` ({}) ' \
                'needs to be a numeric'.format(type(end)))
        self.perturbations.append(BasePerturbation(start=a, end=end, name=name))
    elif isperturbation(a):
        self.perturbations.append(a)
    else:
        raise ValueError('`a` ({}) must be a subclass of ' \
            'pl.base.BasePerturbation or a numeric'.format(type(a)))
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.denormalize_qpcr">
    <p>def <span class="ident">denormalize_qpcr</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Denormalizes the qpcr values if necessary</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.denormalize_qpcr', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.denormalize_qpcr" class="source">
    <pre><code>def denormalize_qpcr(self):
    '''Denormalizes the qpcr values if necessary
    '''
    if self.qpcr_normalization_factor is None:
        logging.warning('qPCR is not normalized. Doing nothing')
        return
    for subj in self:
        for key in subj.qpcr:
            subj.qpcr[key].set_scaling_factor(scaling_factor=1)
    self.qpcr_normalization_factor = None
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.iloc">
    <p>def <span class="ident">iloc</span>(</p><p>self, idx)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the subject as an index</p>
<h2>Parameters</h2>
<p>idx : int
    Index of the subject</p>
<h2>Returns</h2>
<p>pl.base.Subject</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.iloc', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.iloc" class="source">
    <pre><code>def iloc(self, idx):
    '''Get the subject as an index
    Parameters
    ----------
    idx : int
        Index of the subject
    Returns
    -------
    pl.base.Subject
    '''
    for i,sid in enumerate(self._subjects):
        if i == idx:
            return self._subjects[sid]
    raise IndexError('Index ({}) not found'.format(idx))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.normalize_qpcr">
    <p>def <span class="ident">normalize_qpcr</span>(</p><p>self, max_value)</p>
    </div>
    

    
  
    <div class="desc"><p>Normalize the qPCR values such that the largest value is the max value
over all the subjects</p>
<h2>Parameters</h2>
<p>max_value : float, int
    This is the maximum qPCR value to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.normalize_qpcr', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.normalize_qpcr" class="source">
    <pre><code>def normalize_qpcr(self, max_value):
    '''Normalize the qPCR values such that the largest value is the max value
    over all the subjects
    Parameters
    ----------
    max_value : float, int
        This is the maximum qPCR value to
    '''
    if type(max_value) not in [int, float]:
        raise ValueError('max_value ({}) must either be an int or a float'.format(
            type(max_value)))
    if self.qpcr_normalization_factor is not None:
        logging.warning('qPCR is already rescaled. unscaling and rescaling')
        self.denormalize_qpcr()
    temp_max = -1
    for subj in self:
        for key in subj.qpcr:
            temp_max = np.max([temp_max, subj.qpcr[key].mean])
    self.qpcr_normalization_factor = max_value/temp_max
    logging.info('max_value found: {}, scaling_factor: {}'.format(
        temp_max, self.qpcr_normalization_factor))
    for subj in self:
        for key in subj.qpcr:
            subj.qpcr[key].set_scaling_factor(scaling_factor=
                self.qpcr_normalization_factor)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.pop_otus">
    <p>def <span class="ident">pop_otus</span>(</p><p>self, oids)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete the OTUs indicated in oidxs. Updates the reads table and
the internal OTUSet</p>
<h2>Parameters</h2>
<p>oids : str, int, list(str/int)
    These are the identifiers for each of the OTU/s to delete</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.pop_otus', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.pop_otus" class="source">
    <pre><code>def pop_otus(self, oids):
    '''Delete the OTUs indicated in oidxs. Updates the reads table and
    the internal OTUSet
    Parameters
    ----------
    oids : str, int, list(str/int)
        These are the identifiers for each of the OTU/s to delete
    '''
    if isint(oids):
        oids = [oids]
    if not isarray(oids):
        raise ValueError('`oids` ({}) must be an array'.format(type(oids)))
    # get indices
    oidxs = []
    for oid in oids:
        oidxs.append(self.otus[oid].idx)
    # Get the IDs
    ids = []
    for oid in oids:
        ids.append(self.otus[oid].id)
    # Delete the OTUs from otuset
    for oid in ids:
        if oid not in self.otus:
            logging.warning('otu `{}` not contained in otuset. skipping'.format(oid))
        otu = self.otus[oid]
        self.otus.del_otu(otu.id)
    # Delete the reads
    for subj in self:
        for t in subj.reads:
            subj.reads[t] = np.delete(subj.reads[t], oidxs)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.pop_subject">
    <p>def <span class="ident">pop_subject</span>(</p><p>self, sid)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove the indicated subject id</p>
<h2>Parameters</h2>
<p>sid : list(str), str, int
    This is the subject name/s or the index/es to pop out.
    Return a new SubjectSet with the specified subjects removed.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.pop_subject', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.pop_subject" class="source">
    <pre><code>def pop_subject(self, sid):
    '''Remove the indicated subject id
    Parameters
    ----------
    sid : list(str), str, int
        This is the subject name/s or the index/es to pop out.
        Return a new SubjectSet with the specified subjects removed.
    '''
    if not isarray(sid):
        sids = [sid]
    else:
        sids = sid
    for i in range(len(sids)):
        if isint(sids[i]):
            sids[i] = list(self._subjects.keys())[sids[i]]
        elif not isstr(sids[i]):
            raise ValueError('`sid` ({}) must be a str'.format(type(sids[i])))
    ret = SubjectSet(otus=self.otus)
    ret.perturbations = self.perturbations
    ret.qpcr_normalization_factor = self.qpcr_normalization_factor
    for s in sids:
        if s in self._subjects:
            ret._subjects[s] =  self._subjects.pop(s, None)
        else:
            raise ValueError('`sid` ({}) not found'.format(sid))
    return ret
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.pop_times">
    <p>def <span class="ident">pop_times</span>(</p><p>self, times, sids=&#39;all&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Discard the times in <code>times</code> for the subjects listed in <code>sids</code>.
If a timepoint is not found in a subject, no error is thrown.</p>
<h2>Parameters</h2>
<p>times : numeric, list(numeric)
    Time/s to delete
sids : str, int, list(int)
    The Subject ID or a list of subject IDs that you want to delete the timepoints
    from. If it is a str:
        'all' - delete from all subjects</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.pop_times', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.pop_times" class="source">
    <pre><code>def pop_times(self, times, sids='all'):
    '''Discard the times in `times` for the subjects listed in `sids`.
    If a timepoint is not found in a subject, no error is thrown.
    Parameters
    ----------
    times : numeric, list(numeric)
        Time/s to delete
    sids : str, int, list(int)
        The Subject ID or a list of subject IDs that you want to delete the timepoints
        from. If it is a str:
            'all' - delete from all subjects
    '''
    if isstr(sids):
        if sids == 'all':
            sids = list(self._subjects.keys())
        else:
            raise ValueError('`sids` ({}) not recognized'.format(sids))
    elif isint(sids):
        if sids not in self._subjects:
            raise IndexError('`sid` ({}) not found in subjects'.format(
                list(self._subjects.keys())))
        sids = [sids]
    elif isarray(sids):
        for sid in sids:
            if not isint(sid):
                raise TypeError('Each sid ({}) must be an int'.format(type(sid)))
            if sid not in self._subjects:
                raise IndexError('Subject {} not found in subjects ({})'.format(
                    sid, list(self._subjects.keys())))
    else:
        raise TypeError('`sids` ({}) type not recognized'.format(type(sids)))
    if isnumeric(times):
        times = [times]
    elif isarray(times):
        for t in times:
            if not isnumeric(t):
                raise TypeError('Each time ({}) must be a numeric'.format(type(t)))
    else:
        raise TypeError('`times` ({}) type not recognized'.format(type(times)))
    for t in times:
        for sid in sids:
            subj = self._subjects[sid]
            if t in subj.times:
                subj.qpcr.pop(t, None)
                subj.reads.pop(t,None)
                subj.times = np.sort(list(subj.reads.keys()))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.save">
    <p>def <span class="ident">save</span>(</p><p>self, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location to store the file. Overrides the location if
    it is set using <a href="#pylab.base.Saveable.set_save_location"><code>set_save_location</code></a>. If None
    it means that we are using the file location set in 
    set_location.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.save', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.save" class="source">
    <pre><code>def save(self, filename=None):
    '''Pickle the object
    Paramters
    ---------
    filename : str
        This is the location to store the file. Overrides the location if
        it is set using `pylab.base.Saveable.set_save_location`. If None
        it means that we are using the file location set in 
        set_location. 
    '''
    if filename is None:
        if not hasattr(self, '_save_loc'):
            raise TypeError('`filename` must be specified if you have not ' \
                'set the save location')
        filename = self._save_loc
    
    with open(filename, 'wb') as output:  # Overwrites any existing file.
        pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.set_save_location">
    <p>def <span class="ident">set_save_location</span>(</p><p>self, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Set the save location for the object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.set_save_location', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.set_save_location" class="source">
    <pre><code>def set_save_location(self, filename):
    '''Set the save location for the object
    '''
    if not isstr(filename):
        raise TypeError('`filename` ({}) must be a str'.format(type(filename)))
    self._save_loc = filename
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.split_on_perturbations">
    <p>def <span class="ident">split_on_perturbations</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Make new subjects for the time points that are divided by perturbations. 
Throw out all of the data  where the perturbations are active.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.split_on_perturbations', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.split_on_perturbations" class="source">
    <pre><code>def split_on_perturbations(self):
    '''Make new subjects for the time points that are divided by perturbations. 
    Throw out all of the data  where the perturbations are active.
    '''
    for subj in self:
        subj._split_on_perturbations()
    return self
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.SubjectSet.id" class="name">var <span class="ident">id</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.SubjectSet.otus" class="name">var <span class="ident">otus</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.SubjectSet.perturbations" class="name">var <span class="ident">perturbations</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.SubjectSet.qpcr_normalization_factor" class="name">var <span class="ident">qpcr_normalization_factor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.SubjectSet.load">
    <p>def <span class="ident">load</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
    <div class="desc"><p>Unpickle the object</p>
<h2>Paramters</h2>
<p>filename : str
    This is the location of the file to unpickle</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.SubjectSet.load', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.SubjectSet.load" class="source">
    <pre><code>@classmethod
def load(cls, filename):
    '''Unpickle the object
    Paramters
    ---------
    filename : str
        This is the location of the file to unpickle
    '''
    with open(filename, 'rb') as handle:
        b = pickle.load(handle)
    return b
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.Traceable" class="name">class <span class="ident">Traceable</span></p>
      
  
    <div class="desc"><p>Defines the functionality for a Node to interact with the Graph tracer object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Traceable', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Traceable" class="source">
    <pre><code>class Traceable:
    '''Defines the functionality for a Node to interact with the Graph tracer object
    '''

    @property
    def initialization_value(self):
        if hasattr(self, '_init_value'):
            return self._init_value
        else:
            return None

    def set_trace(self):
        '''Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        '''
        raise NotImplementedError('User needs to define this function')

    def add_trace(self):
        '''Adds the current value to the trace. If the buffer is full
        it will end it to disk
        '''
        raise NotImplementedError('User needs to define this function')

    def add_init_value(self):
        '''Saves the initialization value
        '''
        raise NotImplementedError('User needs to define this function')

    def get_trace_from_disk(self, *args, **kwargs):
        '''Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
        include the samples in the local buffer trace and could be very large

        Returns
        -------
        np.ndarray
        '''
        return self.G.tracer.get_trace(name=self.name, *args, **kwargs)

    def overwrite_entire_trace_on_disk(self, data, **kwargs):
        '''Overwrites the entire trace of the variable with the given data.

        Parameters
        ----------
        data : np.ndarray
            Data you are overwriting the trace with.
        '''
        self.G.tracer.overwrite_entire_trace_on_disk(
            name=self.name, data=data, dtype=self.dtype, **kwargs)

    def get_iter(self):
        '''Get the number of iterations saved to the hdf5 file of the variable

        Returns
        -------
        int
        '''
        return self.G.tracer.get_iter(name=self.name)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.Traceable">Traceable</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.Traceable.add_init_value">
    <p>def <span class="ident">add_init_value</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Saves the initialization value</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Traceable.add_init_value', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Traceable.add_init_value" class="source">
    <pre><code>def add_init_value(self):
    '''Saves the initialization value
    '''
    raise NotImplementedError('User needs to define this function')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Traceable.add_trace">
    <p>def <span class="ident">add_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds the current value to the trace. If the buffer is full
it will end it to disk</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Traceable.add_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Traceable.add_trace" class="source">
    <pre><code>def add_trace(self):
    '''Adds the current value to the trace. If the buffer is full
    it will end it to disk
    '''
    raise NotImplementedError('User needs to define this function')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Traceable.get_iter">
    <p>def <span class="ident">get_iter</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the number of iterations saved to the hdf5 file of the variable</p>
<h2>Returns</h2>
<p>int</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Traceable.get_iter', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Traceable.get_iter" class="source">
    <pre><code>def get_iter(self):
    '''Get the number of iterations saved to the hdf5 file of the variable
    Returns
    -------
    int
    '''
    return self.G.tracer.get_iter(name=self.name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Traceable.get_trace_from_disk">
    <p>def <span class="ident">get_trace_from_disk</span>(</p><p>self, *args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
include the samples in the local buffer trace and could be very large</p>
<h2>Returns</h2>
<p>np.ndarray</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Traceable.get_trace_from_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Traceable.get_trace_from_disk" class="source">
    <pre><code>def get_trace_from_disk(self, *args, **kwargs):
    '''Returns the entire trace (after burnin) writen on the disk. NOTE: This may/may not 
    include the samples in the local buffer trace and could be very large
    Returns
    -------
    np.ndarray
    '''
    return self.G.tracer.get_trace(name=self.name, *args, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Traceable.overwrite_entire_trace_on_disk">
    <p>def <span class="ident">overwrite_entire_trace_on_disk</span>(</p><p>self, data, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrites the entire trace of the variable with the given data.</p>
<h2>Parameters</h2>
<p>data : np.ndarray
    Data you are overwriting the trace with.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Traceable.overwrite_entire_trace_on_disk', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Traceable.overwrite_entire_trace_on_disk" class="source">
    <pre><code>def overwrite_entire_trace_on_disk(self, data, **kwargs):
    '''Overwrites the entire trace of the variable with the given data.
    Parameters
    ----------
    data : np.ndarray
        Data you are overwriting the trace with.
    '''
    self.G.tracer.overwrite_entire_trace_on_disk(
        name=self.name, data=data, dtype=self.dtype, **kwargs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.Traceable.set_trace">
    <p>def <span class="ident">set_trace</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the trace arrays for the variable in the Tracer object. </p>
<p>It will initialize a buffer the size of the checkpoint size in Tracer</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.Traceable.set_trace', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.Traceable.set_trace" class="source">
    <pre><code>def set_trace(self):
    '''Initialize the trace arrays for the variable in the Tracer object. 
    It will initialize a buffer the size of the checkpoint size in Tracer
    '''
    raise NotImplementedError('User needs to define this function')
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.Traceable.initialization_value" class="name">var <span class="ident">initialization_value</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="pylab.base.qPCRdata" class="name">class <span class="ident">qPCRdata</span></p>
      
  
    <div class="desc"><p>Single entry of qpcr data.
Assumes that the dilution factor is constant between the replicate runs</p>
<p>The normalized data is assumed to be:
    (cfus * dilution_factor / mass) * scaling_factor</p>
<p>scaling_factor is a scale that we impose on the data so that the numbers don't get
super large in the numerical calculations and we get errors</p>
<h2>Parameters</h2>
<p>cfus : np.ndarray
    These are the raw CFUs - it can be a single CFU measurement or a list of all
    the measurements
mass : float
    This is the mass of the sample in grams
dilution_factor : float
    This is the dilution factor of the samples
    Example:
        If the sample was diluted to 1/100 of its original concentration,
        the dilution factor is 100, NOT 1/100.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.qPCRdata', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.qPCRdata" class="source">
    <pre><code>class qPCRdata:
    '''Single entry of qpcr data.
    Assumes that the dilution factor is constant between the replicate runs

    The normalized data is assumed to be:
        (cfus * dilution_factor / mass) * scaling_factor

    scaling_factor is a scale that we impose on the data so that the numbers don't get
    super large in the numerical calculations and we get errors

    Parameters
    ----------
    cfus : np.ndarray
        These are the raw CFUs - it can be a single CFU measurement or a list of all
        the measurements
    mass : float
        This is the mass of the sample in grams
    dilution_factor : float
        This is the dilution factor of the samples
        Example:
            If the sample was diluted to 1/100 of its original concentration,
            the dilution factor is 100, NOT 1/100.

    '''
    def __init__(self, cfus, mass, dilution_factor):
        self._raw_data = np.asarray(cfus)
        self.mass = mass
        self.dilution_factor = dilution_factor
        self.scaling_factor = 1 # Initialize with no scaling factor
        self.scaled_data = (self._raw_data*self.dilution_factor/self.mass)*self.scaling_factor
        self.mean = np.mean(self.scaled_data)
        self.std = np.std(self.scaled_data)
        self.var = np.var(self.scaled_data)

    def __str__(self):
        return str(self.mean)

    def add(self,raw_data):
        '''Add a single qPCR measurement to add to the set of observations

        Parameters
        ----------
        raw_data : float, array_like
            This is the measurement to add
        '''
        self._raw_data = np.append(self._raw_data,raw_data)
        self.scaled_data = (self._raw_data*self.dilution_factor/self.mass)*self.scaling_factor
        self.mean = np.mean(self.scaled_data)
        self.std = np.std(self.scaled_data)
        self.var = np.var(self.scaled_data)

    def set_to_nan(self):
        '''Set all attributes to `np.nan`
        '''
        self._raw_data *= np.nan
        self.scaled_data *= np.nan
        self.mass = np.nan
        self.dilution_factor = np.nan
        self.mean = np.nan
        self.std = np.nan
        self.var = np.nan
        self.scaling_factor = np.nan

    def set_scaling_factor(self, scaling_factor):
        '''Resets the scaling factor

        Parameters
        ----------
        scaling_factor : float, int
            This is the scaling factor to set everything to
        '''
        if scaling_factor <= 0:
            raise ValueError('The scaling factor must strictly be positive')
        self.scaling_factor = scaling_factor
        self.scaled_data = (self._raw_data*self.dilution_factor/self.mass) * scaling_factor
        self.mean = np.mean(self.scaled_data)
        self.std = np.std(self.scaled_data)
        self.var = np.var(self.scaled_data)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#pylab.base.qPCRdata">qPCRdata</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="pylab.base.qPCRdata.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, cfus, mass, dilution_factor)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.qPCRdata.__init__', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.qPCRdata.__init__" class="source">
    <pre><code>def __init__(self, cfus, mass, dilution_factor):
    self._raw_data = np.asarray(cfus)
    self.mass = mass
    self.dilution_factor = dilution_factor
    self.scaling_factor = 1 # Initialize with no scaling factor
    self.scaled_data = (self._raw_data*self.dilution_factor/self.mass)*self.scaling_factor
    self.mean = np.mean(self.scaled_data)
    self.std = np.std(self.scaled_data)
    self.var = np.var(self.scaled_data)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.qPCRdata.add">
    <p>def <span class="ident">add</span>(</p><p>self, raw_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a single qPCR measurement to add to the set of observations</p>
<h2>Parameters</h2>
<p>raw_data : float, array_like
    This is the measurement to add</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.qPCRdata.add', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.qPCRdata.add" class="source">
    <pre><code>def add(self,raw_data):
    '''Add a single qPCR measurement to add to the set of observations
    Parameters
    ----------
    raw_data : float, array_like
        This is the measurement to add
    '''
    self._raw_data = np.append(self._raw_data,raw_data)
    self.scaled_data = (self._raw_data*self.dilution_factor/self.mass)*self.scaling_factor
    self.mean = np.mean(self.scaled_data)
    self.std = np.std(self.scaled_data)
    self.var = np.var(self.scaled_data)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.qPCRdata.set_scaling_factor">
    <p>def <span class="ident">set_scaling_factor</span>(</p><p>self, scaling_factor)</p>
    </div>
    

    
  
    <div class="desc"><p>Resets the scaling factor</p>
<h2>Parameters</h2>
<p>scaling_factor : float, int
    This is the scaling factor to set everything to</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.qPCRdata.set_scaling_factor', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.qPCRdata.set_scaling_factor" class="source">
    <pre><code>def set_scaling_factor(self, scaling_factor):
    '''Resets the scaling factor
    Parameters
    ----------
    scaling_factor : float, int
        This is the scaling factor to set everything to
    '''
    if scaling_factor <= 0:
        raise ValueError('The scaling factor must strictly be positive')
    self.scaling_factor = scaling_factor
    self.scaled_data = (self._raw_data*self.dilution_factor/self.mass) * scaling_factor
    self.mean = np.mean(self.scaled_data)
    self.std = np.std(self.scaled_data)
    self.var = np.var(self.scaled_data)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="pylab.base.qPCRdata.set_to_nan">
    <p>def <span class="ident">set_to_nan</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Set all attributes to <code>np.nan</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-pylab.base.qPCRdata.set_to_nan', this);">Show source &equiv;</a></p>
  <div id="source-pylab.base.qPCRdata.set_to_nan" class="source">
    <pre><code>def set_to_nan(self):
    '''Set all attributes to `np.nan`
    '''
    self._raw_data *= np.nan
    self.scaled_data *= np.nan
    self.mass = np.nan
    self.dilution_factor = np.nan
    self.mean = np.nan
    self.std = np.nan
    self.var = np.nan
    self.scaling_factor = np.nan
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="pylab.base.qPCRdata.dilution_factor" class="name">var <span class="ident">dilution_factor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.qPCRdata.mass" class="name">var <span class="ident">mass</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.qPCRdata.mean" class="name">var <span class="ident">mean</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.qPCRdata.scaled_data" class="name">var <span class="ident">scaled_data</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.qPCRdata.scaling_factor" class="name">var <span class="ident">scaling_factor</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.qPCRdata.std" class="name">var <span class="ident">std</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="pylab.base.qPCRdata.var" class="name">var <span class="ident">var</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
