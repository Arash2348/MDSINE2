<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.pylab.random API documentation</title>
<meta name="description" content="Sample from efficient distributions â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.pylab.random</code></h1>
</header>
<section id="section-intro">
<p>Sample from efficient distributions.</p>
<p>The difference between these classes and the classes in <code>pylab.variables</code> is that
these are just efficnet wrappers of functions that do not require instantiating a
node whereas the classes in <code>pylab.variables</code> are meant to be inherited for posteriors
and to instantiate as objects. The functions of the distributions in <code>pylab.variables</code>
are implemented here</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Sample from efficient distributions.

The difference between these classes and the classes in `pylab.variables` is that
these are just efficnet wrappers of functions that do not require instantiating a
node whereas the classes in `pylab.variables` are meant to be inherited for posteriors
and to instantiate as objects. The functions of the distributions in `pylab.variables`
are implemented here
&#39;&#39;&#39;

import numpy as np
import math
import numpy.random as npr
import pickle
import random
import logging
import warnings
import sys
import scipy.stats
import warnings

from .base import Saveable
from .errors import MathError, UndefinedError
try:
    import _sample as c_sample
    # warnings.warn(&#39;PYLAB - USING C VERSIONS FOR DISTRIBUTIONS&#39;)

    C_SAMPLE = c_sample.Sample()
    CUSTOM_DIST_AVAIL = True
except ImportError as e:
    print(e)
    warnings.warn(&#39;PYLAB - WAS NOT ABLE TO IMPORT C VERSIONS OF DISTRIBUTIONS.&#39; \
        &#39; USING DEFAULT PYTHON INSTEAD.&#39;)
    CUSTOM_DIST_AVAIL = False


# For caluclating pdf, logpdf, cdf, logcdf - faster access and precomputation
import numba # for compiling and forcing function to stay in cache
from math import sqrt as SQRT
from math import pi as _PI
from math import erf as ERF
from math import gamma as GAMMA
from math import lgamma as LGAMMA
from numpy import exp as EXP
from numpy import log as LOG
from numpy import square as SQD

_INV_SQRT_2PI = 1/SQRT(2*_PI)
_LOG_INV_SQRT_2PI = LOG(1/SQRT(2*_PI))
_LOG_2PI = LOG(2*_PI)
_INV_SQRT_2 = 1/SQRT(2)
_LOG_INV_SQRT_2 = LOG(1/SQRT(2))
_LOG_ONE_HALF = LOG(0.5)
_NEGINF = float(&#39;-inf&#39;)

def israndom(x):
    &#39;&#39;&#39;Checks whether the input is a subclass of BaseRandom (not a
    random variable (isRandomVariable))

    Parameters
    ----------
    x : any
        Input instance to check the type of BaseRandom

    Returns
    -------
    bool
        True if `x` is of type BaseRandom, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, _BaseSample)

def seed(x):
    &#39;&#39;&#39;Sets all of the seeds with the given seed `x`

    Parameters
    ----------
    x (int)
        Seed to set everything at
    &#39;&#39;&#39;
    np.random.seed(x)
    random.seed(x)
    if CUSTOM_DIST_AVAIL:
        C_SAMPLE.seed(x)

def _safe_cholesky(M, jitter=False, save_if_crash=False):
    # if scipy.sparse.issparse(M):
    #     M = M.toarray()

    try:
        # if type(M) == torch.Tensor:
        #     L = torch.cholesky(M)
        # else:
        return np.linalg.cholesky(M)
    except:
        try:
            return scipy.linalg.cholesky(M)
        except:
            if not jitter:
                if save_if_crash:
                    saveloc = &#39;this_is_what_made_cholesky_crash_{}.npy&#39;.format(os.getpid())
                    np.save(saveloc, M)
                raise
        jitter = 1e-9
        while jitter &lt; 1.0:
            try:
                L = np.linalg.cholesky(M + np.diag(jitter*np.ones(M.shape[0])))
                logging.warning(&#39;jitter threshold: {}&#39;.format(jitter))
                return L
            except:
                jitter *= 10

    if save_if_crash:
        saveloc = &#39;this_is_what_made_cholesky_crash_{}.npy&#39;.format(os.getpid())
        np.save(saveloc, M)
    raise MathError(&#39;Cholesky could not be calculated with jitter. Array that &#39; \
        &#39;crashed the system saved as `this_is_what_made_cholesky_crash.npy`&#39;)

def _log_det_func(M):
    # if scipy.sparse.issparse(M):
    #     M_ = M.toarray()
    # else:
    #     M_ = M
    L = _safe_cholesky(M)
    return 2*np.sum(np.log(np.diag(L)))

class misc:
    &#39;&#39;&#39;These are miscellaneus methods
    &#39;&#39;&#39;
    @staticmethod
    def multivariate_normal_fast_2d(mean, cov):
        &#39;&#39;&#39;Sample from 2d normal.

        Parameters
        ----------
        mean : 1d array
        cov : 2 x 2 array

        Returns
        -------
        np.ndarray (2,)
            Two samples
        &#39;&#39;&#39;
        z0 = C_SAMPLE.c_standard_normal()
        SQRT_COV_00 = math.sqrt(cov[0,0])
        mean[0] += SQRT_COV_00 * z0
        mean[1] += cov[1,0] / SQRT_COV_00 * z0 + math.sqrt(cov[1,1] - \
            cov[1,0]**2 / cov[0,0]) * C_SAMPLE.c_standard_normal()
        return mean

    @staticmethod
    def fast_sample_standard_uniform():
        &#39;&#39;&#39;Sample from a uniform distribution on [0,1)
        &#39;&#39;&#39;
        return C_SAMPLE.c_standard_uniform()

    @staticmethod
    def fast_sample_normal(mean, std):
        &#39;&#39;&#39;Sample from a c_implementation of a normal distribution.
        Only accepts floats

        Parameters
        ----------
        mean, std : float
            Mean and standard devition, respectively

        Returns
        -------
        float
        &#39;&#39;&#39;
        return C_SAMPLE.c_normal(mean, std)


class _BaseSample:

    @staticmethod
    def sample(*args, **kwargs):
        &#39;&#39;&#39;Sample a random variable from the distribution
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def pdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the pdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def logpdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the logpdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def cdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the cdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)

    @staticmethod
    def logcdf(*args, **kwargs):
        &#39;&#39;&#39;Calculate the logcdf
        &#39;&#39;&#39;
        raise UndefinedError(&#39;This function is undefined.&#39;)


class normal(_BaseSample):
    &#39;&#39;&#39;Scalar normal distribution parameterized by a mean and standard deviation
    &#39;&#39;&#39;
    @staticmethod
    def sample(mean=0, std=1, size=None):
        &#39;&#39;&#39;Sample from a normal random distribution
        &#39;&#39;&#39;
        return npr.normal(mean, std, size=size)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value, mean, std):
        return _INV_SQRT_2PI * EXP(-0.5*((value-mean)/std)**2) / std

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value, mean, std):
        return _LOG_INV_SQRT_2PI + (-0.5*((value-mean)/std)**2) - LOG(std)


    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def cdf(value, mean, std):
        return 0.5 * (1 + ERF(_INV_SQRT_2 * ((value-mean)/std)))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logcdf(value, mean, std):
        return _LOG_ONE_HALF + LOG(1 + ERF(_INV_SQRT_2 * ((value-mean)/std)))


class lognormal(_BaseSample):
    &#39;&#39;&#39;Sample from a log-normal distribution:

    X = exp(\mu + \sigma Z), Z ~ Normal(0,1)
    &#39;&#39;&#39; 
    @staticmethod
    def sample(mean, std, size=None):
        return np.exp(mean + std * npr.normal(0,1,size=size))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value, mean, std):
        return _INV_SQRT_2PI * (1/(std*value)) * EXP(-0.5 * \
            ((LOG(value)-mean)/std) ** 2)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value, mean, std):
        return _LOG_INV_SQRT_2PI - LOG(std) - LOG(value) + \
            (-0.5*((LOG(value)-mean)/std)**2)


class truncnormal(_BaseSample):

    @staticmethod
    def sample(mean, std, low=float(&#39;-inf&#39;), high=float(&#39;inf&#39;), size=None):
        &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
        [low, high] with mean `mean` and standard deviation `std`
        &#39;&#39;&#39;
        if size is not None:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        mean,std,low,high) for i in range(len(size))])
                except:
                    value = scipy.stats.truncnorm(
                        a=(low-mean)/std,
                        b=(high-mean)/std,
                        loc=mean,
                        scale=std).rvs(size=size)
            else:
                value = scipy.stats.truncnorm(
                    a=(low-mean)/std,
                    b=(high-mean)/std,
                    loc=mean,
                    scale=std).rvs(size=size)
        else:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = C_SAMPLE.c_truncated_normal(mean, std, low, high)
                except:
                    # likely because the mean and std are vectors
                    # try vectorizing it
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        mean[i],std[i],low,high) for i in range(len(mean))])
            else:
                value = scipy.stats.truncnorm(
                    a=(low-mean)/std,
                    b=(high-mean)/std,
                    loc=mean,
                    scale=std).rvs(size=size)
        return value

    @staticmethod
    def sample_vec(mean, std, low=float(&#39;-inf&#39;), high=float(&#39;inf&#39;), size=None):
        &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
        [low, high] with mean `mean` and standard deviation `std`
        &#39;&#39;&#39;
        return np.asarray([C_SAMPLE.c_truncated_normal(
            mean[i],std[i],low,high) for i in range(len(mean))])

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def pdf(value, mean, std, low, high):
        return scipy.stats.truncnorm.pdf(value, (low-mean)/std, (high-mean)/std, mean, std)

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logpdf(value, mean, std, low, high):
        return scipy.stats.truncnorm.logpdf(value, (low-mean)/std, (high-mean)/std, mean, std)


class multivariate_normal(_BaseSample):

    @staticmethod
    def sample(mean, cov, size=None):
        return npr.multivariate_normal(mean=mean, cov=cov, size=size)

    @staticmethod
    def logpdf(value, mean, cov):
        k = cov.shape[0]
        logdet = _log_det_func(cov)
        prec = np.linalg.pinv(cov)
        vmm = value - mean
        a = -k * 0.5 * _LOG_2PI
        b = -0.5 * logdet
        c = -0.5 * ( vmm.T @ prec @ vmm)
        return np.squeeze(a + b + c)


class gamma(_BaseSample):

    @staticmethod
    def sample(shape, scale, size=None):
        return npr.gamma(shape=shape, scale=scale, size=size)

    @staticmethod
    def pdf(value, shape, scale):
        return scipy.stats.gamma.pdf(x=value, a=shape, scale=scale)


class beta(_BaseSample):

    @staticmethod
    def sample(a, b, size=None):
        return npr.beta(a=a, b=b, size=size)


class sics(_BaseSample):
    &#39;&#39;&#39;Scaled Inverse Chi^2 distribution.
    &#39;&#39;&#39;
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value, dof, scale):
        dofdiv2 = dof/2
        a = ((scale * dofdiv2)**(dofdiv2))/(GAMMA(dofdiv2))
        b = EXP(-scale*dofdiv2/(value)) / (value ** (1 + (dofdiv2)))
        return a*b
        
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value, dof, scale):
        dofdiv2 = dof/2
        a = dofdiv2*LOG(scale*dofdiv2)
        b = -LGAMMA(dofdiv2)
        c = -scale * dofdiv2 / value
        d = -(1+dofdiv2) * LOG(value)
        return a + b + c + d

    @staticmethod
    def sample(dof, scale, size=None):
        return invgamma.sample(shape=dof/2, scale=dof*scale/2, size=size)


class invchisquared(_BaseSample):

    @staticmethod
    def sample(nu, size=None):
        return invgamma.sample(shape=nu/2, scale=0.5, size=size)


class invgamma(_BaseSample):

    @staticmethod
    def sample(shape, scale, size=None):
        return 1/npr.gamma(shape=shape, scale=1/scale, size=size)

    @staticmethod
    def pdf(value, shape, scale):
        return scipy.stats.invgamma.pdf(value, a=shape, scale=scale)

    @staticmethod
    def logpdf(value, shape, scale):
        return scipy.stats.invgamma.logpdf(value, a=shape, scale=scale)


class uniform(_BaseSample):


    @staticmethod
    def sample(low=0, high=1, size=None):
        return npr.uniform(low=low, high=high, size=size)

    @staticmethod
    def pdf(value, low, high):
        if value &lt; low or value &gt; high:
            return 0
        else:
            return 1/(high-low)

    @staticmethod
    def logpdf(value, low, high):
        if value &lt; low or value &gt; high:
            return 0
        else:
            return -LOG(high-low)

    @staticmethod
    def cdf(value, low, high):
        if value &lt; low:
            return 0
        elif value &gt;= high:
            return 1
        else:
            return (value-low)/(high-value)

    @staticmethod
    def logcdf(value, low, high):
        if value &lt; low:
            return float(&#39;-inf&#39;)
        elif value &gt;= high:
            return 0
        else:
            return LOG(value-low) - LOG(high-value)


class negative_binomial(_BaseSample):
    &#39;&#39;&#39;Parameterization of the negative binomial with mean $\\phi$ and dispersion
    $\\epsilon$:
        $\\text{NegBin}(y; \\phi, \\epsilon) =
            \\Gamma(r+y) / (y! * \\Gamma(r)) *
            (\\phi / (\\phi + r))^y *
            (r / (r + \\phi))^r$, where $r = 1/\\epsilon$
    We reparameterize the inputs so we can use the scipy implementation
    &#39;&#39;&#39;
    @staticmethod
    def sample(mean, dispersion, size=None):
        &#39;&#39;&#39;Sample
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom(n=n, p=p).rvs(size=size)

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def pmf(value, mean, dispersion):
        &#39;&#39;&#39;Calculate the pmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.pmf(value, n, p)

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logpmf(value, mean, dispersion):
        &#39;&#39;&#39;Calculate the logpmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.logpmf(value, n, p)

    @staticmethod
    @numba.jit(nopython=True, cache=True)
    def convert_params(mu, theta):
        &#34;&#34;&#34;
        Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports

        Parameters
        ----------
        mu : float
           Mean of NB distribution.
        theta : float
           Dispersion parameter used for variance calculation.

        Returns
        -------
        float, float
            Returns n, p

        See Also
        --------
        https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations
        &#34;&#34;&#34;
        r = 1/theta
        var = mu + 1 / r * mu ** 2
        p = (var - mu) / var
        return r, 1-p


class bernoulli:

    @staticmethod
    def sample(p=0.5, size=None):
        &#39;&#39;&#39;Sample a random variable from the distribution
        &#39;&#39;&#39;
        return npr.binomial(n=1, p=p, size=size)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdsine2.pylab.random.israndom"><code class="name flex">
<span>def <span class="ident">israndom</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the input is a subclass of BaseRandom (not a
random variable (isRandomVariable))</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>any</code></dt>
<dd>Input instance to check the type of BaseRandom</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>x</code> is of type BaseRandom, else False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def israndom(x):
    &#39;&#39;&#39;Checks whether the input is a subclass of BaseRandom (not a
    random variable (isRandomVariable))

    Parameters
    ----------
    x : any
        Input instance to check the type of BaseRandom

    Returns
    -------
    bool
        True if `x` is of type BaseRandom, else False
    &#39;&#39;&#39;
    return x is not None and issubclass(x.__class__, _BaseSample)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.seed"><code class="name flex">
<span>def <span class="ident">seed</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets all of the seeds with the given seed <code>x</code></p>
<h2 id="parameters">Parameters</h2>
<p>x (int)
Seed to set everything at</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seed(x):
    &#39;&#39;&#39;Sets all of the seeds with the given seed `x`

    Parameters
    ----------
    x (int)
        Seed to set everything at
    &#39;&#39;&#39;
    np.random.seed(x)
    random.seed(x)
    if CUSTOM_DIST_AVAIL:
        C_SAMPLE.seed(x)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdsine2.pylab.random.bernoulli"><code class="flex name class">
<span>class <span class="ident">bernoulli</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class bernoulli:

    @staticmethod
    def sample(p=0.5, size=None):
        &#39;&#39;&#39;Sample a random variable from the distribution
        &#39;&#39;&#39;
        return npr.binomial(n=1, p=p, size=size)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.bernoulli.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>p=0.5, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(p=0.5, size=None):
    &#39;&#39;&#39;Sample a random variable from the distribution
    &#39;&#39;&#39;
    return npr.binomial(n=1, p=p, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.beta"><code class="flex name class">
<span>class <span class="ident">beta</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class beta(_BaseSample):

    @staticmethod
    def sample(a, b, size=None):
        return npr.beta(a=a, b=b, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.beta.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>a, b, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(a, b, size=None):
    return npr.beta(a=a, b=b, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.gamma"><code class="flex name class">
<span>class <span class="ident">gamma</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class gamma(_BaseSample):

    @staticmethod
    def sample(shape, scale, size=None):
        return npr.gamma(shape=shape, scale=scale, size=size)

    @staticmethod
    def pdf(value, shape, scale):
        return scipy.stats.gamma.pdf(x=value, a=shape, scale=scale)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.gamma.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value, shape, scale)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pdf(value, shape, scale):
    return scipy.stats.gamma.pdf(x=value, a=shape, scale=scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.gamma.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>shape, scale, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(shape, scale, size=None):
    return npr.gamma(shape=shape, scale=scale, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.invchisquared"><code class="flex name class">
<span>class <span class="ident">invchisquared</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class invchisquared(_BaseSample):

    @staticmethod
    def sample(nu, size=None):
        return invgamma.sample(shape=nu/2, scale=0.5, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.invchisquared.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>nu, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(nu, size=None):
    return invgamma.sample(shape=nu/2, scale=0.5, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.invgamma"><code class="flex name class">
<span>class <span class="ident">invgamma</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class invgamma(_BaseSample):

    @staticmethod
    def sample(shape, scale, size=None):
        return 1/npr.gamma(shape=shape, scale=1/scale, size=size)

    @staticmethod
    def pdf(value, shape, scale):
        return scipy.stats.invgamma.pdf(value, a=shape, scale=scale)

    @staticmethod
    def logpdf(value, shape, scale):
        return scipy.stats.invgamma.logpdf(value, a=shape, scale=scale)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.invgamma.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value, shape, scale)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpdf(value, shape, scale):
    return scipy.stats.invgamma.logpdf(value, a=shape, scale=scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.invgamma.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value, shape, scale)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pdf(value, shape, scale):
    return scipy.stats.invgamma.pdf(value, a=shape, scale=scale)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.invgamma.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>shape, scale, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(shape, scale, size=None):
    return 1/npr.gamma(shape=shape, scale=1/scale, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.lognormal"><code class="flex name class">
<span>class <span class="ident">lognormal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a log-normal distribution:</p>
<p>X = exp(\mu + \sigma Z), Z ~ Normal(0,1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class lognormal(_BaseSample):
    &#39;&#39;&#39;Sample from a log-normal distribution:

    X = exp(\mu + \sigma Z), Z ~ Normal(0,1)
    &#39;&#39;&#39; 
    @staticmethod
    def sample(mean, std, size=None):
        return np.exp(mean + std * npr.normal(0,1,size=size))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value, mean, std):
        return _INV_SQRT_2PI * (1/(std*value)) * EXP(-0.5 * \
            ((LOG(value)-mean)/std) ** 2)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value, mean, std):
        return _LOG_INV_SQRT_2PI - LOG(std) - LOG(value) + \
            (-0.5*((LOG(value)-mean)/std)**2)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.lognormal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value, mean, std)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def logpdf(value, mean, std):
    return _LOG_INV_SQRT_2PI - LOG(std) - LOG(value) + \
        (-0.5*((LOG(value)-mean)/std)**2)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.lognormal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value, mean, std)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def pdf(value, mean, std):
    return _INV_SQRT_2PI * (1/(std*value)) * EXP(-0.5 * \
        ((LOG(value)-mean)/std) ** 2)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.lognormal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>mean, std, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(mean, std, size=None):
    return np.exp(mean + std * npr.normal(0,1,size=size))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.misc"><code class="flex name class">
<span>class <span class="ident">misc</span></span>
</code></dt>
<dd>
<div class="desc"><p>These are miscellaneus methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class misc:
    &#39;&#39;&#39;These are miscellaneus methods
    &#39;&#39;&#39;
    @staticmethod
    def multivariate_normal_fast_2d(mean, cov):
        &#39;&#39;&#39;Sample from 2d normal.

        Parameters
        ----------
        mean : 1d array
        cov : 2 x 2 array

        Returns
        -------
        np.ndarray (2,)
            Two samples
        &#39;&#39;&#39;
        z0 = C_SAMPLE.c_standard_normal()
        SQRT_COV_00 = math.sqrt(cov[0,0])
        mean[0] += SQRT_COV_00 * z0
        mean[1] += cov[1,0] / SQRT_COV_00 * z0 + math.sqrt(cov[1,1] - \
            cov[1,0]**2 / cov[0,0]) * C_SAMPLE.c_standard_normal()
        return mean

    @staticmethod
    def fast_sample_standard_uniform():
        &#39;&#39;&#39;Sample from a uniform distribution on [0,1)
        &#39;&#39;&#39;
        return C_SAMPLE.c_standard_uniform()

    @staticmethod
    def fast_sample_normal(mean, std):
        &#39;&#39;&#39;Sample from a c_implementation of a normal distribution.
        Only accepts floats

        Parameters
        ----------
        mean, std : float
            Mean and standard devition, respectively

        Returns
        -------
        float
        &#39;&#39;&#39;
        return C_SAMPLE.c_normal(mean, std)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.misc.fast_sample_normal"><code class="name flex">
<span>def <span class="ident">fast_sample_normal</span></span>(<span>mean, std)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a c_implementation of a normal distribution.
Only accepts floats</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong>, <strong><code>std</code></strong> :&ensp;<code>float</code></dt>
<dd>Mean and standard devition, respectively</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fast_sample_normal(mean, std):
    &#39;&#39;&#39;Sample from a c_implementation of a normal distribution.
    Only accepts floats

    Parameters
    ----------
    mean, std : float
        Mean and standard devition, respectively

    Returns
    -------
    float
    &#39;&#39;&#39;
    return C_SAMPLE.c_normal(mean, std)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.misc.fast_sample_standard_uniform"><code class="name flex">
<span>def <span class="ident">fast_sample_standard_uniform</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a uniform distribution on [0,1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fast_sample_standard_uniform():
    &#39;&#39;&#39;Sample from a uniform distribution on [0,1)
    &#39;&#39;&#39;
    return C_SAMPLE.c_standard_uniform()</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.misc.multivariate_normal_fast_2d"><code class="name flex">
<span>def <span class="ident">multivariate_normal_fast_2d</span></span>(<span>mean, cov)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from 2d normal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>1d array</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>cov</code></strong> :&ensp;<code>2 x 2 array</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray (2,)</code></dt>
<dd>Two samples</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def multivariate_normal_fast_2d(mean, cov):
    &#39;&#39;&#39;Sample from 2d normal.

    Parameters
    ----------
    mean : 1d array
    cov : 2 x 2 array

    Returns
    -------
    np.ndarray (2,)
        Two samples
    &#39;&#39;&#39;
    z0 = C_SAMPLE.c_standard_normal()
    SQRT_COV_00 = math.sqrt(cov[0,0])
    mean[0] += SQRT_COV_00 * z0
    mean[1] += cov[1,0] / SQRT_COV_00 * z0 + math.sqrt(cov[1,1] - \
        cov[1,0]**2 / cov[0,0]) * C_SAMPLE.c_standard_normal()
    return mean</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.multivariate_normal"><code class="flex name class">
<span>class <span class="ident">multivariate_normal</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class multivariate_normal(_BaseSample):

    @staticmethod
    def sample(mean, cov, size=None):
        return npr.multivariate_normal(mean=mean, cov=cov, size=size)

    @staticmethod
    def logpdf(value, mean, cov):
        k = cov.shape[0]
        logdet = _log_det_func(cov)
        prec = np.linalg.pinv(cov)
        vmm = value - mean
        a = -k * 0.5 * _LOG_2PI
        b = -0.5 * logdet
        c = -0.5 * ( vmm.T @ prec @ vmm)
        return np.squeeze(a + b + c)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.multivariate_normal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value, mean, cov)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpdf(value, mean, cov):
    k = cov.shape[0]
    logdet = _log_det_func(cov)
    prec = np.linalg.pinv(cov)
    vmm = value - mean
    a = -k * 0.5 * _LOG_2PI
    b = -0.5 * logdet
    c = -0.5 * ( vmm.T @ prec @ vmm)
    return np.squeeze(a + b + c)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.multivariate_normal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>mean, cov, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(mean, cov, size=None):
    return npr.multivariate_normal(mean=mean, cov=cov, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial"><code class="flex name class">
<span>class <span class="ident">negative_binomial</span></span>
</code></dt>
<dd>
<div class="desc"><p>Parameterization of the negative binomial with mean $\phi$ and dispersion
$\epsilon$:
$\text{NegBin}(y; \phi, \epsilon) =
\Gamma(r+y) / (y! * \Gamma(r)) *
(\phi / (\phi + r))^y *
(r / (r + \phi))^r$, where $r = 1/\epsilon$
We reparameterize the inputs so we can use the scipy implementation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class negative_binomial(_BaseSample):
    &#39;&#39;&#39;Parameterization of the negative binomial with mean $\\phi$ and dispersion
    $\\epsilon$:
        $\\text{NegBin}(y; \\phi, \\epsilon) =
            \\Gamma(r+y) / (y! * \\Gamma(r)) *
            (\\phi / (\\phi + r))^y *
            (r / (r + \\phi))^r$, where $r = 1/\\epsilon$
    We reparameterize the inputs so we can use the scipy implementation
    &#39;&#39;&#39;
    @staticmethod
    def sample(mean, dispersion, size=None):
        &#39;&#39;&#39;Sample
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom(n=n, p=p).rvs(size=size)

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def pmf(value, mean, dispersion):
        &#39;&#39;&#39;Calculate the pmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.pmf(value, n, p)

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logpmf(value, mean, dispersion):
        &#39;&#39;&#39;Calculate the logpmf
        &#39;&#39;&#39;
        n,p = negative_binomial.convert_params(mean, dispersion)
        return scipy.stats.nbinom.logpmf(value, n, p)

    @staticmethod
    @numba.jit(nopython=True, cache=True)
    def convert_params(mu, theta):
        &#34;&#34;&#34;
        Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports

        Parameters
        ----------
        mu : float
           Mean of NB distribution.
        theta : float
           Dispersion parameter used for variance calculation.

        Returns
        -------
        float, float
            Returns n, p

        See Also
        --------
        https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations
        &#34;&#34;&#34;
        r = 1/theta
        var = mu + 1 / r * mu ** 2
        p = (var - mu) / var
        return r, 1-p</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.negative_binomial.convert_params"><code class="name flex">
<span>def <span class="ident">convert_params</span></span>(<span>mu, theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt>Mean of NB distribution.</dt>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Dispersion parameter used for variance calculation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float, float</code></dt>
<dd>Returns n, p</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>&lt;https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations&gt;</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, cache=True)
def convert_params(mu, theta):
    &#34;&#34;&#34;
    Convert mean/dispersion parameterization of a negative binomial to the ones scipy supports

    Parameters
    ----------
    mu : float
       Mean of NB distribution.
    theta : float
       Dispersion parameter used for variance calculation.

    Returns
    -------
    float, float
        Returns n, p

    See Also
    --------
    https://en.wikipedia.org/wiki/Negative_binomial_distribution#Alternative_formulations
    &#34;&#34;&#34;
    r = 1/theta
    var = mu + 1 / r * mu ** 2
    p = (var - mu) / var
    return r, 1-p</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial.logpmf"><code class="name flex">
<span>def <span class="ident">logpmf</span></span>(<span>value, mean, dispersion)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpmf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def logpmf(value, mean, dispersion):
    &#39;&#39;&#39;Calculate the logpmf
    &#39;&#39;&#39;
    n,p = negative_binomial.convert_params(mean, dispersion)
    return scipy.stats.nbinom.logpmf(value, n, p)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial.pmf"><code class="name flex">
<span>def <span class="ident">pmf</span></span>(<span>value, mean, dispersion)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pmf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def pmf(value, mean, dispersion):
    &#39;&#39;&#39;Calculate the pmf
    &#39;&#39;&#39;
    n,p = negative_binomial.convert_params(mean, dispersion)
    return scipy.stats.nbinom.pmf(value, n, p)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.negative_binomial.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>mean, dispersion, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(mean, dispersion, size=None):
    &#39;&#39;&#39;Sample
    &#39;&#39;&#39;
    n,p = negative_binomial.convert_params(mean, dispersion)
    return scipy.stats.nbinom(n=n, p=p).rvs(size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.normal"><code class="flex name class">
<span>class <span class="ident">normal</span></span>
</code></dt>
<dd>
<div class="desc"><p>Scalar normal distribution parameterized by a mean and standard deviation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class normal(_BaseSample):
    &#39;&#39;&#39;Scalar normal distribution parameterized by a mean and standard deviation
    &#39;&#39;&#39;
    @staticmethod
    def sample(mean=0, std=1, size=None):
        &#39;&#39;&#39;Sample from a normal random distribution
        &#39;&#39;&#39;
        return npr.normal(mean, std, size=size)

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value, mean, std):
        return _INV_SQRT_2PI * EXP(-0.5*((value-mean)/std)**2) / std

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value, mean, std):
        return _LOG_INV_SQRT_2PI + (-0.5*((value-mean)/std)**2) - LOG(std)


    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def cdf(value, mean, std):
        return 0.5 * (1 + ERF(_INV_SQRT_2 * ((value-mean)/std)))

    @staticmethod
    @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logcdf(value, mean, std):
        return _LOG_ONE_HALF + LOG(1 + ERF(_INV_SQRT_2 * ((value-mean)/std)))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.normal.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>value, mean, std)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def cdf(value, mean, std):
    return 0.5 * (1 + ERF(_INV_SQRT_2 * ((value-mean)/std)))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>value, mean, std)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def logcdf(value, mean, std):
    return _LOG_ONE_HALF + LOG(1 + ERF(_INV_SQRT_2 * ((value-mean)/std)))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value, mean, std)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def logpdf(value, mean, std):
    return _LOG_INV_SQRT_2PI + (-0.5*((value-mean)/std)**2) - LOG(std)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value, mean, std)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def pdf(value, mean, std):
    return _INV_SQRT_2PI * EXP(-0.5*((value-mean)/std)**2) / std</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.normal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>mean=0, std=1, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a normal random distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(mean=0, std=1, size=None):
    &#39;&#39;&#39;Sample from a normal random distribution
    &#39;&#39;&#39;
    return npr.normal(mean, std, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.sics"><code class="flex name class">
<span>class <span class="ident">sics</span></span>
</code></dt>
<dd>
<div class="desc"><p>Scaled Inverse Chi^2 distribution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sics(_BaseSample):
    &#39;&#39;&#39;Scaled Inverse Chi^2 distribution.
    &#39;&#39;&#39;
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def pdf(value, dof, scale):
        dofdiv2 = dof/2
        a = ((scale * dofdiv2)**(dofdiv2))/(GAMMA(dofdiv2))
        b = EXP(-scale*dofdiv2/(value)) / (value ** (1 + (dofdiv2)))
        return a*b
        
    @staticmethod
    @numba.jit(nopython=True, fastmath=True, cache=True)
    def logpdf(value, dof, scale):
        dofdiv2 = dof/2
        a = dofdiv2*LOG(scale*dofdiv2)
        b = -LGAMMA(dofdiv2)
        c = -scale * dofdiv2 / value
        d = -(1+dofdiv2) * LOG(value)
        return a + b + c + d

    @staticmethod
    def sample(dof, scale, size=None):
        return invgamma.sample(shape=dof/2, scale=dof*scale/2, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.sics.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value, dof, scale)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def logpdf(value, dof, scale):
    dofdiv2 = dof/2
    a = dofdiv2*LOG(scale*dofdiv2)
    b = -LGAMMA(dofdiv2)
    c = -scale * dofdiv2 / value
    d = -(1+dofdiv2) * LOG(value)
    return a + b + c + d</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.sics.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value, dof, scale)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@numba.jit(nopython=True, fastmath=True, cache=True)
def pdf(value, dof, scale):
    dofdiv2 = dof/2
    a = ((scale * dofdiv2)**(dofdiv2))/(GAMMA(dofdiv2))
    b = EXP(-scale*dofdiv2/(value)) / (value ** (1 + (dofdiv2)))
    return a*b</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.sics.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>dof, scale, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(dof, scale, size=None):
    return invgamma.sample(shape=dof/2, scale=dof*scale/2, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.truncnormal"><code class="flex name class">
<span>class <span class="ident">truncnormal</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class truncnormal(_BaseSample):

    @staticmethod
    def sample(mean, std, low=float(&#39;-inf&#39;), high=float(&#39;inf&#39;), size=None):
        &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
        [low, high] with mean `mean` and standard deviation `std`
        &#39;&#39;&#39;
        if size is not None:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        mean,std,low,high) for i in range(len(size))])
                except:
                    value = scipy.stats.truncnorm(
                        a=(low-mean)/std,
                        b=(high-mean)/std,
                        loc=mean,
                        scale=std).rvs(size=size)
            else:
                value = scipy.stats.truncnorm(
                    a=(low-mean)/std,
                    b=(high-mean)/std,
                    loc=mean,
                    scale=std).rvs(size=size)
        else:
            if CUSTOM_DIST_AVAIL:
                try:
                    value = C_SAMPLE.c_truncated_normal(mean, std, low, high)
                except:
                    # likely because the mean and std are vectors
                    # try vectorizing it
                    value = np.asarray([C_SAMPLE.c_truncated_normal(
                        mean[i],std[i],low,high) for i in range(len(mean))])
            else:
                value = scipy.stats.truncnorm(
                    a=(low-mean)/std,
                    b=(high-mean)/std,
                    loc=mean,
                    scale=std).rvs(size=size)
        return value

    @staticmethod
    def sample_vec(mean, std, low=float(&#39;-inf&#39;), high=float(&#39;inf&#39;), size=None):
        &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
        [low, high] with mean `mean` and standard deviation `std`
        &#39;&#39;&#39;
        return np.asarray([C_SAMPLE.c_truncated_normal(
            mean[i],std[i],low,high) for i in range(len(mean))])

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def pdf(value, mean, std, low, high):
        return scipy.stats.truncnorm.pdf(value, (low-mean)/std, (high-mean)/std, mean, std)

    @staticmethod
    # @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
    def logpdf(value, mean, std, low, high):
        return scipy.stats.truncnorm.logpdf(value, (low-mean)/std, (high-mean)/std, mean, std)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.truncnormal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value, mean, std, low, high)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def logpdf(value, mean, std, low, high):
    return scipy.stats.truncnorm.logpdf(value, (low-mean)/std, (high-mean)/std, mean, std)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.truncnormal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value, mean, std, low, high)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
# @numba.jit(nopython=True, fastmath=True, parallel=True, cache=True)
def pdf(value, mean, std, low, high):
    return scipy.stats.truncnorm.pdf(value, (low-mean)/std, (high-mean)/std, mean, std)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.truncnormal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>mean, std, low=-inf, high=inf, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a truncated normal random distribution defined on
[low, high] with mean <code>mean</code> and standard deviation <code>std</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(mean, std, low=float(&#39;-inf&#39;), high=float(&#39;inf&#39;), size=None):
    &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
    [low, high] with mean `mean` and standard deviation `std`
    &#39;&#39;&#39;
    if size is not None:
        if CUSTOM_DIST_AVAIL:
            try:
                value = np.asarray([C_SAMPLE.c_truncated_normal(
                    mean,std,low,high) for i in range(len(size))])
            except:
                value = scipy.stats.truncnorm(
                    a=(low-mean)/std,
                    b=(high-mean)/std,
                    loc=mean,
                    scale=std).rvs(size=size)
        else:
            value = scipy.stats.truncnorm(
                a=(low-mean)/std,
                b=(high-mean)/std,
                loc=mean,
                scale=std).rvs(size=size)
    else:
        if CUSTOM_DIST_AVAIL:
            try:
                value = C_SAMPLE.c_truncated_normal(mean, std, low, high)
            except:
                # likely because the mean and std are vectors
                # try vectorizing it
                value = np.asarray([C_SAMPLE.c_truncated_normal(
                    mean[i],std[i],low,high) for i in range(len(mean))])
        else:
            value = scipy.stats.truncnorm(
                a=(low-mean)/std,
                b=(high-mean)/std,
                loc=mean,
                scale=std).rvs(size=size)
    return value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.truncnormal.sample_vec"><code class="name flex">
<span>def <span class="ident">sample_vec</span></span>(<span>mean, std, low=-inf, high=inf, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a truncated normal random distribution defined on
[low, high] with mean <code>mean</code> and standard deviation <code>std</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample_vec(mean, std, low=float(&#39;-inf&#39;), high=float(&#39;inf&#39;), size=None):
    &#39;&#39;&#39;Sample from a truncated normal random distribution defined on
    [low, high] with mean `mean` and standard deviation `std`
    &#39;&#39;&#39;
    return np.asarray([C_SAMPLE.c_truncated_normal(
        mean[i],std[i],low,high) for i in range(len(mean))])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mdsine2.pylab.random.uniform"><code class="flex name class">
<span>class <span class="ident">uniform</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class uniform(_BaseSample):


    @staticmethod
    def sample(low=0, high=1, size=None):
        return npr.uniform(low=low, high=high, size=size)

    @staticmethod
    def pdf(value, low, high):
        if value &lt; low or value &gt; high:
            return 0
        else:
            return 1/(high-low)

    @staticmethod
    def logpdf(value, low, high):
        if value &lt; low or value &gt; high:
            return 0
        else:
            return -LOG(high-low)

    @staticmethod
    def cdf(value, low, high):
        if value &lt; low:
            return 0
        elif value &gt;= high:
            return 1
        else:
            return (value-low)/(high-value)

    @staticmethod
    def logcdf(value, low, high):
        if value &lt; low:
            return float(&#39;-inf&#39;)
        elif value &gt;= high:
            return 0
        else:
            return LOG(value-low) - LOG(high-value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>mdsine2.pylab.random._BaseSample</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mdsine2.pylab.random.uniform.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>value, low, high)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def cdf(value, low, high):
    if value &lt; low:
        return 0
    elif value &gt;= high:
        return 1
    else:
        return (value-low)/(high-value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>value, low, high)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logcdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logcdf(value, low, high):
    if value &lt; low:
        return float(&#39;-inf&#39;)
    elif value &gt;= high:
        return 0
    else:
        return LOG(value-low) - LOG(high-value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>value, low, high)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logpdf(value, low, high):
    if value &lt; low or value &gt; high:
        return 0
    else:
        return -LOG(high-low)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>value, low, high)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def pdf(value, low, high):
    if value &lt; low or value &gt; high:
        return 0
    else:
        return 1/(high-low)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.random.uniform.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>low=0, high=1, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample a random variable from the distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sample(low=0, high=1, size=None):
    return npr.uniform(low=low, high=high, size=size)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2.pylab" href="index.html">mdsine2.pylab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdsine2.pylab.random.israndom" href="#mdsine2.pylab.random.israndom">israndom</a></code></li>
<li><code><a title="mdsine2.pylab.random.seed" href="#mdsine2.pylab.random.seed">seed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdsine2.pylab.random.bernoulli" href="#mdsine2.pylab.random.bernoulli">bernoulli</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.bernoulli.sample" href="#mdsine2.pylab.random.bernoulli.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.beta" href="#mdsine2.pylab.random.beta">beta</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.beta.sample" href="#mdsine2.pylab.random.beta.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.gamma" href="#mdsine2.pylab.random.gamma">gamma</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.gamma.pdf" href="#mdsine2.pylab.random.gamma.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.gamma.sample" href="#mdsine2.pylab.random.gamma.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.invchisquared" href="#mdsine2.pylab.random.invchisquared">invchisquared</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.invchisquared.sample" href="#mdsine2.pylab.random.invchisquared.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.invgamma" href="#mdsine2.pylab.random.invgamma">invgamma</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.invgamma.logpdf" href="#mdsine2.pylab.random.invgamma.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.invgamma.pdf" href="#mdsine2.pylab.random.invgamma.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.invgamma.sample" href="#mdsine2.pylab.random.invgamma.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.lognormal" href="#mdsine2.pylab.random.lognormal">lognormal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.lognormal.logpdf" href="#mdsine2.pylab.random.lognormal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.lognormal.pdf" href="#mdsine2.pylab.random.lognormal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.lognormal.sample" href="#mdsine2.pylab.random.lognormal.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.misc" href="#mdsine2.pylab.random.misc">misc</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.misc.fast_sample_normal" href="#mdsine2.pylab.random.misc.fast_sample_normal">fast_sample_normal</a></code></li>
<li><code><a title="mdsine2.pylab.random.misc.fast_sample_standard_uniform" href="#mdsine2.pylab.random.misc.fast_sample_standard_uniform">fast_sample_standard_uniform</a></code></li>
<li><code><a title="mdsine2.pylab.random.misc.multivariate_normal_fast_2d" href="#mdsine2.pylab.random.misc.multivariate_normal_fast_2d">multivariate_normal_fast_2d</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.multivariate_normal" href="#mdsine2.pylab.random.multivariate_normal">multivariate_normal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.multivariate_normal.logpdf" href="#mdsine2.pylab.random.multivariate_normal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.multivariate_normal.sample" href="#mdsine2.pylab.random.multivariate_normal.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.negative_binomial" href="#mdsine2.pylab.random.negative_binomial">negative_binomial</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.negative_binomial.convert_params" href="#mdsine2.pylab.random.negative_binomial.convert_params">convert_params</a></code></li>
<li><code><a title="mdsine2.pylab.random.negative_binomial.logpmf" href="#mdsine2.pylab.random.negative_binomial.logpmf">logpmf</a></code></li>
<li><code><a title="mdsine2.pylab.random.negative_binomial.pmf" href="#mdsine2.pylab.random.negative_binomial.pmf">pmf</a></code></li>
<li><code><a title="mdsine2.pylab.random.negative_binomial.sample" href="#mdsine2.pylab.random.negative_binomial.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.normal" href="#mdsine2.pylab.random.normal">normal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.normal.cdf" href="#mdsine2.pylab.random.normal.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.logcdf" href="#mdsine2.pylab.random.normal.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.logpdf" href="#mdsine2.pylab.random.normal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.pdf" href="#mdsine2.pylab.random.normal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.normal.sample" href="#mdsine2.pylab.random.normal.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.sics" href="#mdsine2.pylab.random.sics">sics</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.sics.logpdf" href="#mdsine2.pylab.random.sics.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.sics.pdf" href="#mdsine2.pylab.random.sics.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.sics.sample" href="#mdsine2.pylab.random.sics.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.truncnormal" href="#mdsine2.pylab.random.truncnormal">truncnormal</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.truncnormal.logpdf" href="#mdsine2.pylab.random.truncnormal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.truncnormal.pdf" href="#mdsine2.pylab.random.truncnormal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.truncnormal.sample" href="#mdsine2.pylab.random.truncnormal.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.random.truncnormal.sample_vec" href="#mdsine2.pylab.random.truncnormal.sample_vec">sample_vec</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.random.uniform" href="#mdsine2.pylab.random.uniform">uniform</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.random.uniform.cdf" href="#mdsine2.pylab.random.uniform.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.logcdf" href="#mdsine2.pylab.random.uniform.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.logpdf" href="#mdsine2.pylab.random.uniform.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.pdf" href="#mdsine2.pylab.random.uniform.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.random.uniform.sample" href="#mdsine2.pylab.random.uniform.sample">sample</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>