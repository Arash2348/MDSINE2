<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.pylab.variables API documentation</title>
<meta name="description" content="This module defines constant, variable, and random classes â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.pylab.variables</code></h1>
</header>
<section id="section-intro">
<p>This module defines constant, variable, and random classes.</p>
<h2 id="tracing">Tracing</h2>
<p>There are two kinds of tracing:
Variable.trace
This is a trace that stores the tracing on RAM. This can be accessed very fast.
The local index to use this is called <code>ckpt_iter</code> (int). This is the corresponds
to the index in the preallocated space in Varibale.trace where to next add a variable.
Variable.G.tracer
This is an object that stores the data of the variable on Disk. Reading and writing to
disk is slower but it is needed for inferences that are sufficiently large as you cannot
store all of the trace data in RAM. <code>sample_iter</code> (int) corresponds to the overall sample
iteration number that we are on in the inference, which includes the <code>ckpt_iter</code>. You must
be careful when you read from disk as the tracer does not differentiate between the burnin
and the regular samples.
When you call <code>add_trace</code>, the internal mechanism automatically pushes the local trace to
disk once it has reached the checkpoint to write to disk.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;This module defines constant, variable, and random classes.

Tracing
-------
There are two kinds of tracing:
Variable.trace
    This is a trace that stores the tracing on RAM. This can be accessed very fast.
    The local index to use this is called `ckpt_iter` (int). This is the corresponds 
    to the index in the preallocated space in Varibale.trace where to next add a variable.
Variable.G.tracer
    This is an object that stores the data of the variable on Disk. Reading and writing to 
    disk is slower but it is needed for inferences that are sufficiently large as you cannot
    store all of the trace data in RAM. `sample_iter` (int) corresponds to the overall sample
    iteration number that we are on in the inference, which includes the `ckpt_iter`. You must
    be careful when you read from disk as the tracer does not differentiate between the burnin
    and the regular samples.
When you call `add_trace`, the internal mechanism automatically pushes the local trace to
disk once it has reached the checkpoint to write to disk.
&#39;&#39;&#39;
import numpy as np
import math
import numpy.random as npr
import pickle
import random
import logging
import warnings
import sys
import scipy.stats

from .graph import get_default_graph, Node, isnode
from .base import Traceable, istraceable
from .errors import UndefinedError, MathError, InitializationError, \
    NeedToImplementError
from . import random
from .util import isarray, isbool, isstr, istype, istuple

# Constants
DEFAULT_VARIABLE_TYPE = float

DEFAULT_NORMAL_MEAN_SUFFIX = &#39;_mean&#39;
DEFAULT_NORMAL_VAR_SUFFIX = &#39;_var&#39;
DEFAULT_LOGNORMAL_STD_SUFFIX = &#39;_std&#39;
DEFAULT_UNIFORM_LOW_SUFFIX = &#39;_low&#39;
DEFAULT_UNIFORM_HIGH_SUFFIX = &#39;_high&#39;
DEFAULT_SICS_DOF_SUFFIX = &#39;_dof&#39;
DEFAULT_SICS_SCALE_SUFFIX = &#39;_scale&#39;
DEFAULT_GAMMA_SHAPE_SUFFIX = &#39;_shape&#39;
DEFAULT_GAMMA_SCALE_SUFFIX = &#39;_scale&#39;
DEFAULT_BERNOULLI_P_SUFFIX = &#39;_p&#39;
DEFAULT_BETA_ALPHA_SUFFIX = &#39;_a&#39;
DEFAULT_BETA_BETA_SUFFIX = &#39;_b&#39;
DEFAULT_MVN_MEAN_SUFFIX = &#39;_mean&#39;
DEFAULT_MVN_COV_SUFFIX = &#39;_cov&#39;


def isVariable(var):
    &#39;&#39;&#39;Checks if `a` is a subclass of a Variable

    Parameters
    ----------
    a : any
        Instance we are checking

    Returns
    -------
    bool
        True if `a` is a subclass of a Variable
    &#39;&#39;&#39;
    return var is not None and issubclass(var.__class__, Variable)

def isRandomVariable(var):
    &#39;&#39;&#39;Checks if `a` is a subclass of a RandomVariable

    Parameters
    ----------
    a : any
        Instance we are checking

    Returns
    -------
    bool
        True if `a` is a subclass of a RandomVariable
    &#39;&#39;&#39;
    return var is not None and issubclass(var.__class__, _RandomBase)

def summary(var, set_nan_to_0=False, section=&#39;posterior&#39;, only=None):
    &#39;&#39;&#39;Calculates different metrics about the given trace (mean, 
    median, 25th percentile, 75th percentile)

    Parameters
    ----------
    var : Traceable, np.ndarray
        Variable/trace we are doing the calculations on
    set_nan_to_0 : bool
        If True, we set the NaNs in the trace to zeros
    section : str
        This is the section of the MH samples for us to retreive
    only : None, list(str)
        If this is specified, then only calculate the types that are 
        in here. Accepted:
            &#39;mean&#39;, &#39;median&#39;, &#39;25th percentile&#39;, &#39;75th percentile&#39;

    Returns
    -------
    dict
        mean (&#39;mean&#39;), median (&#39;median&#39;), 25th percentile 
        (&#39;25th percentile&#39;), and 75th percentile (&#39;75th percentile&#39;), 
    &#39;&#39;&#39;
    if istraceable(var):
        if var.G.inference.ckpt is None:
            if section == &#39;burnin&#39;:
                var = var.trace[:var.G.inference.burnin, ...]
            elif section == &#39;posterior&#39;:
                var = var.trace[var.G.inference.burnin:, ...]
            elif section == &#39;entire&#39;:
                var = var.trace
            else:
                raise ValueError(&#39;`section` ({}) not recognized&#39;.format(section))
        else:
            var = var.get_trace_from_disk(section=section)
    elif isarray(var):
        var = np.asarray(var)
    else:
        raise ValueError(&#39;`var` ({}) must either be a subclass of Traceable &#39; \
            &#39;or an array&#39;.format(type(var)))
    if not isbool(set_nan_to_0):
        raise ValueError(&#39;`set_nan_to_0` ({}) must be a bool&#39;.format(type(set_nan_to_0)))
    if set_nan_to_0:
        var = np.nan_to_num(var)
    ret = {}
    try:
        do = True
        if only is not None:
            do = &#39;median&#39; in only
        if do is True:
            ret[&#39;median&#39;] = np.nan_to_num(np.nanmedian(var,axis=0))
    except:
        logging.error(&#39;median failed&#39;)
        ret[&#39;median&#39;] = np.nan
    try:
        do = True
        if only is not None:
            do = &#39;mean&#39; in only
        if do is True:
            ret[&#39;mean&#39;] = np.nan_to_num(np.nanmean(var,axis=0))
    except:
        logging.error(&#39;mean failed&#39;)
        ret[&#39;mean&#39;] = np.nan
    try:
        do = True
        if only is not None:
            do = &#39;25th percentile&#39; in only
        if do is True:
            ret[&#39;25th percentile&#39;] = np.nan_to_num(np.nanpercentile(var,25,axis=0))
    except:
        logging.error(&#39;25th percentile failed&#39;)
        ret[&#39;25th percentile&#39;] = np.nan
    try:
        do = True
        if only is not None:
            do = &#39;75th percentile&#39; in only
        if do is True:
            ret[&#39;75th percentile&#39;] = np.nan_to_num(np.nanpercentile(var,75,axis=0))
    except:
        logging.error(&#39;75th percentile failed&#39;)
        ret[&#39;75th percentile&#39;] = np.nan
    return ret


class _BaseArithmeticClass:
    &#39;&#39;&#39;This is a baseclass that lets us do arithmetic on the 
    value.

    Nothing is checked in this arithmetic for of speed
    If something is going to fail, other, faster libraries (numpy) will fail
    &#34;Ask forgiveness, not permission&#34;
    &#39;&#39;&#39;
    def __str__(self):
        return str(self.value)

    # ----------------
    # Binary operators
    # ----------------
    def __mul__(self, val):
        # self * val
        return self.value * val

    def __imul__(self, val):
        # self *= val
        self.value = self.value * val
        return self

    def __rmul__(self, val):
        # val * self
        return val * self.value

    def __add__(self,val):
        # self + val
        return self.value + val

    def __iadd__(self,val):
        # self += val
        self.value = self.value + val
        return self

    def __radd__(self,val):
        # val + self
        return self.value + val

    def __sub__(self,val):
        # self - val
        return self.value - val

    def __rsub__(self,val):
        # val - self
        return val - self.value

    def __isub__(self,val):
        # self -= val
        self.value = self.value - val
        return self

    def __truediv__(self,val):
        # self / val
        return self.value / val

    def __rtruediv__(self,val):
        # val / self
        return val / self.value

    def __itruediv__(self,val):
        # self /= val
        self.value = self.value / val
        return self

    def __floordiv__(self,val):
        # self // val
        return self.value // val

    def __rfloordiv__(self,val):
        # val // self
        return val // self.value

    def __ifloordiv__(self,val):
        # self //= val
        self.value = self.value // val
        return self

    def __mod__(self,val):
        # self % val
        return self.value % val

    def __rmod__(self,val):
        # val % self
        return val % self.value

    def __imod__(self, val):
        # self %= val
        self.value = self.value % val
        return self

    def __pow__(self,val):
        # self ** val
        return self.value ** val

    def __rpow__(self,val):
        # val ** self
        return val ** self.value

    def __ipow__(self,val):
        # self **= val
        self.value = self.value ** val
        return self

    # ------------------
    # Comparison methods
    # ------------------
    def __eq__(self,val):
        # self == val
        return self.value == val

    def __ne__(self,val):
        # self != val
        return self.value != val

    def __le__(self,val):
        # self &lt; val=
        return self.value &lt;= val

    def __ge__(self,val):
        # self &gt;= val
        return self.value &gt;= val

    def __lt__(self,val):
        # self &lt; val
        return self.value &lt; val

    def __gt__(self,val):
        # self &gt; val
        return self.value &gt; val

    # ----------------
    # Unary operations
    # ----------------
    def __invert__(self):
        # ~self
        return ~self.value

    def __abs__(self):
        # abs(self)
        return abs(self.value)

    def __neg__(self):
        # -self
        return -self.value

    def __pos__(self):
        # + self
        return self.value

    def __int__(self):
        # int(self)
        return int(self.value)

    def __float__(self):
        # float(self)
        return float(self.value)

    # ----------------
    # Matrix operations
    # ----------------
    def __matmul__(self,val):
        # self @ val
        return self.value @ np.asarray(val)

    def __rmatmul__(self,val):
        # val # self
        return np.array(val) @ self.value

    def __imatmul__(self,val):
        # self @= val
        self.value = self.value @ np.asarray(val)

    def __getitem__(self,*args, **kwargs):
        return self.value.__getitem__(*args, **kwargs)

    def __setitem__(self, *args, **kwargs):
        self.value.__setitem__(*args, **kwargs)


class _RandomBase:
    def sample(self, *args, **kwargs):
        &#39;&#39;&#39;Sample with the given parameters
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf with the specified value. If `value` is not
        specified, then use the current value

        Parameters
        ----------
        value : float, int, array_like
            Value we are using instead of self.value

        Returns
        -------
        float
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf with the specified value. If `value` is not
        specified, then use the current value

        Parameters
        ----------
        value : float, int, array_like
            Value we are using instead of self.value

        Returns
        -------
        float
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf with the specified value. If `value` is not
        specified, then use the current value

        Parameters
        ----------
        value : float, int, array_like
            Value we are using instead of self.value

        Returns
        -------
        float
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf with the specified value. If `value` is not
        specified, then use the current value

        Parameters
        ----------
        value : float, int, array_like
            Value we are using instead of self.value

        Returns
        -------
        float
        &#39;&#39;&#39;
        raise NeedToImplementError(&#39;User needs to implement this function&#39;)


class Constant(Node, _BaseArithmeticClass):
    &#39;&#39;&#39;A value in the graph that does not change.
    This can be a scalar or a matrix. We can manually override the value
    by calling `override_value`. We do this for model safety.

    Parameters
    ----------
    value : any
        This is the value of the constant
    kwargs : dict
        These are the extra arguments for the Node class
    &#39;&#39;&#39;
    def __init__(self, value, **kwargs):
        self._value = value
        Node.__init__(self, **kwargs)

    def override_value(self, val):
        &#39;&#39;&#39;Override the value with `val`

        Parameters
        ----------
        val : any
            Value to override self.value with
        &#39;&#39;&#39;
        self._value = val

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, val):
        raise UndefinedError(&#39;{} - Cannot change the value of a constant. If you &#39; \
            &#39;want to change the value, then you must call the function &#39; \
            &#39;`override_value` explicitly&#39;.format(self.name))


class Variable(Node, _BaseArithmeticClass, Traceable):
    &#39;&#39;&#39;Scalar values that can change over time and be traced

    Parameters
    ----------
    value : int, float, None
        This is the value of the scalar
    dtype : Type
        This is the type of the variable
    kwargs :dict
        These are the extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, value=None, dtype=None, shape=None, **kwargs):
        Node.__init__(self, **kwargs)
        if dtype is None:
            dtype = DEFAULT_VARIABLE_TYPE
        if not istype(dtype):
            raise TypeError(&#39;`dtype` ({}) must be a type object&#39;.format(type(dtype)))
        if shape is not None:
            if not istuple(shape):
                raise TypeError(&#39;`shape` ({}) must be a tuple or None&#39;)
        self.dtype = dtype
        self.value = value
        self._shape = shape
        self._init_value = None

    def __len__(self):
        if self._shape is None:
            raise ValueError(&#39;`No length for scalar`&#39;)
        return self._shape[0]

    def set_trace(self):
        &#39;&#39;&#39;Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        &#39;&#39;&#39;
        if self.G.inference.tracer_filename is not None:
            self.G.tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)
            ckpt = self.G.tracer.ckpt
        else:
            ckpt = self.G.inference.n_samples + self.G.inference.burnin
        
        self.ckpt_iter = 0
        self.sample_iter = 0
        shape = (ckpt, )
        if self._shape is not None:
            shape += self._shape
        self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)

    def remove_local_trace(self):
        &#39;&#39;&#39;Destroy the local trace of the object
        &#39;&#39;&#39;
        self.trace = None

    def add_trace(self):
        &#39;&#39;&#39;Adds the current value to the trace. If the buffer is full
        it will end it to disk
        &#39;&#39;&#39;
        try:
            self.trace[self.ckpt_iter] = self.value
        except:
            logging.critical(&#39;{} - trace shape ({}), value shape ({})&#39;.format(
                self.name, self.trace[self.ckpt_iter].shape, self.value.shape))
            raise
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            if self.G.inference.ckpt is None:
                # No writing to disk
                return
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            shape = (self.G.tracer.ckpt, )
            if self._shape is not None:
                shape += self._shape
            self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
            self.ckpt_iter = 0

        if self.ckpt_iter &gt; len(self.trace):
            raise ValueError(&#39;Iteration {} too long for RAM trace {}&#39;.format(self.ckpt_iter, 
                len(self.trace)))

    def set_value_shape(self, shape):
        &#39;&#39;&#39;Set the shape
        
        Parameters
        ----------
        shape : tuple
        &#39;&#39;&#39;
        if not istuple(shape):
            raise TypeError(&#39;`shape` ({}) must be a tuple&#39;.format(type(shape)))
        self._shape = shape

    @property
    def T(self):
        &#39;&#39;&#39;Transpose
        &#39;&#39;&#39;
        return self.value.T


class Normal(Variable, _RandomBase):
    &#39;&#39;&#39;Scalar normal variable parameterized by the mean and variance

    Parameters
    ----------
    mean : float, int
        This is the mean of the distribution
    var : float, int
        This is the variance of the distribution
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, mean=None, var=None, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_NORMAL_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(var):
            self._var = Variable(
                value=var,
                name=self.name + DEFAULT_NORMAL_VAR_SUFFIX,
                G=self.G)
        else:
            self._var = var

        # Set graph with parents
        self.add_parent(self._mean)
        self.add_parent(self._var)

    @property
    def mean(self):
        return self._mean

    @property
    def var(self):
        return self._var

    @property
    def std(self):
        return np.sqrt(self._var.value)

    def mode(self):
        return self._mean.value

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.mean` and `self.var`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.normal.sample(
            mean=self._mean.value, 
            std=np.sqrt(self._var.value),
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.pdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.logpdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.cdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.logcdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))


class Lognormal(Variable, _RandomBase):
    &#39;&#39;&#39;Lognormal distribution

    Parameters
    ----------
    mean : numeric, array
        This is the mean of the distribution
    std : numeric array
        This is the standard deviation of the array
    kwargs
    &#39;&#39;&#39;
    def __init__(self, mean, std, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_NORMAL_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(std):
            self._std = Variable(
                value=std,
                name=self.name + DEFAULT_LOGNORMAL_STD_SUFFIX,
                G=self.G)
        else:
            self._std = std

        # Set graph with parents
        self.add_parent(self._mean)
        self.add_parent(self._std)

    @property
    def mean(self):
        return self._mean

    @property
    def std(self):
        return self._std

    def mode(self):
        return self._mean.value

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.mean` and `self.var`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.lognormal.sample(
            mean=self._mean.value, 
            std=self._std.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.pdf(value=value, mean=self._mean.value,
            std=self._std.value)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.logpdf(value=value, mean=self._mean.value,
            std=self._std.value)

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.cdf(value=value, mean=self._mean.value,
            std=self._std.value)

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.logcdf(value=value, mean=self._mean.value,
            std=self._std.value)


class Uniform(Variable, _RandomBase):
    &#39;&#39;&#39;Scalar Uniform variable parameterized by the low and high

    Parameters
    ----------
    low : float, int
        This is the low of the distribution
    high : float, int
        This is the high of the distribution
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, low=None, high=None, **kwargs):
        Variable.__init__(self, **kwargs)
        # Wrap parameters in nodes
        if not isnode(low):
            self._low = Variable(
                value=low,
                name=self.name+DEFAULT_UNIFORM_LOW_SUFFIX,
                G=self.G)
        else:
            self._low = low
        if not isnode(high):
            self._high = Variable(
                value=high,
                name=self.name + DEFAULT_UNIFORM_HIGH_SUFFIX,
                G=self.G)
        else:
            self._high = high

        self.add_parent(self._low)
        self.add_parent(self._high)

    @property
    def low(self):
        return self._low

    @property
    def high(self):
        return self._high

    def mean(self):
        return 0.5*(self._low.value + self._high.value)

    def median(self):
        return self.mean()

    def var(self):
        return (1/12)*(self._high.value - self._low.value)**2

    def variance(self):
        return self.var()

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.low` and `self.high`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.uniform.sample(
            low=self._low.value, 
            high=self._high.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.pdf(value=value, low=self._low.value,
            high=self._high.value)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.logpdf(value=value, low=self._low.value,
            high=self._high.value)

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.cdf(value=value, low=self._low.value,
            high=self._high.value)

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.logcdf(value=value, low=self._low.value,
            high=self._high.value)


class TruncatedNormal(Variable, _RandomBase):
    &#39;&#39;&#39;Scalar truncated normal variable parameterized by the mean, variance,
    low, and high

    Parameters
    ----------
    mean : float, int
        This is the mean of the distribution
    var : float, int
        This is the variance of the distribution
    low : float, int
        This is the lowest value that can be sampled
    high : float, int
        This is the highest value that can be sampled
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, mean, var, low=None, high=None, **kwargs):
        Variable.__init__(self, **kwargs)

        if low is None:
            low = float(&#39;-inf&#39;)
        if high is None:
            high = float(&#39;inf&#39;)
        if low &gt; high:
            raise ValueError(&#39;`low` ({}) cannot be larger than `high` ({})&#39;.format(
                low,high))

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_NORMAL_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(var):
            self._var = Variable(
                value=var,
                name=self.name + DEFAULT_NORMAL_VAR_SUFFIX,
                G=self.G)
        else:
            self._var = var

        self.low=low
        self.high=high

        # Set graph with parents
        self.add_parent(self._mean)
        self.add_parent(self._var)

    @property
    def mean(self):
        return self._mean

    @property
    def var(self):
        return self._var

    @property
    def std(self):
        return np.sqrt(self._var.value)

    def mode(self):
        if self.low &lt;= self.mean and self.mean &lt;= self.high:
            return self.mean
        elif self.mean &lt; self.low:
            return self.low
        else:
            return self.high

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.mean`, `self.var`, 
        `self.low`, and `self.high`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.truncnormal.sample(
            low=self.low,
            high=self.high,
            mean=self._mean.value,
            std=np.sqrt(self._var.value),
            size=size)

        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.pdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.logpdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.cdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.logcdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)


class SICS(Variable, _RandomBase):
    &#39;&#39;&#39;Scaled Inverse Chi Square parameterized by degrees of freedom `dof` and 
    scale `scale`.
    
    Parameters
    ----------
    dof : float, int
        This is the dof of the distribution
    scale : float, int
        This is the scale of the distribution
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, dof=None, scale=None, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(dof):
            self._dof = Variable(
                value=dof,
                name=self.name + DEFAULT_SICS_DOF_SUFFIX,
                G=self.G)
        else:
            self._dof = dof
        if not isnode(scale):
            self._scale = Variable(
                value=scale,
                name=self.name + DEFAULT_SICS_SCALE_SUFFIX,
                G=self.G)
        else:
            self._scale = scale

        # Set graph with parents
        self.add_parent(self._dof)
        self.add_parent(self._scale)

    @property
    def dof(self):
        return self._dof

    @property
    def scale(self):
        return self._scale

    def mean(self):
        return self._dof.value * self._scale.value/ \
            (self._dof.value-2)

    def mode(self):
        return self._dof.value * self._scale.value / \
            (self._dof.value + 2)

    def sample(self, size=None):
        &#39;&#39;&#39;Sample from a SICS distribution parameerized by the current
        values of `scale` and `dof`.

        Parameters
        ----------
        size : int, None
            This is how many samples to draw. If None then we only draw a 
            single sample.

        Returns
        -------
        float, np.ndarray(float)
        &#39;&#39;&#39;
        self.value = random.sics.sample(
            dof=self._dof.value,
            scale=self._scale.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given the internal state. If `value` is defined,
        calculate the pdf with the passed in value instead of `self.value`.

        Parameters
        ----------
        value : numeric
            Value to calculate the pdf of instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.sics.pdf(value=value,
            dof=self._dof.value, scale=self._scale.value)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given the internal state. If `value` is defined,
        calculate the logpdf with the passed in value instead of `self.value`.

        Parameters
        ----------
        value : numeric
            Value to calculate the logpdf of instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.sics.logpdf(value=value,
            dof=self._dof.value, scale=self._scale.value)


class Gamma(Variable, _RandomBase):
    &#39;&#39;&#39;Gamma Distribution but for multiple values

    `shape` is a pylab.variables.Variable, `scale` is a
    pylab.variables.Variable
    &#39;&#39;&#39;
    def __init__(self, shape, scale, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(shape):
            self._shape_var = Variable(
                value=shape,
                name=self.name + DEFAULT_GAMMA_SHAPE_SUFFIX,
                G=self.G)
        else:
            self._shape_var = shape
        if not isnode(scale):
            self._scale = Variable(
                value=scale,
                name=self.name + DEFAULT_GAMMA_SCALE_SUFFIX,
                G=self.G)
        else:
            self._scale = scale

        if isarray(shape):
            self._shape = np.asarray(shape).shape

        # Set graph with parents
        self.add_parent(self._shape_var)
        self.add_parent(self._scale)

    @property
    def shape(self):
        return self._shape_var

    @property
    def scale(self):
        return self._scale

    def mean(self):
        return self._shape_var.value * self._scale.value

    def variance(self):
        return self._shape_var.value * (self._scale.value) ** 2

    def sample(self, size=None):
        self.value = random.gamma.sample(
            shape=self._shape_var.value,
            scale=self._scale.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.shape`, and `self.scale`. 
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.gamma.pdf(value=value, 
            shape=self._shape_var.value, scale=self._scale.value)


class InvGamma(Variable, _RandomBase):
    def __init__(self, shape, scale, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(shape):
            self._shape_var = Variable(
                value=shape,
                name=self.name + DEFAULT_GAMMA_SHAPE_SUFFIX,
                G=self.G)
        else:
            self._shape_var = shape
        if not isnode(scale):
            self._scale = Variable(
                value=scale,
                name=self.name + DEFAULT_GAMMA_SCALE_SUFFIX,
                G=self.G)
        else:
            self._scale = scale

        if isarray(shape):
            self._shape = np.asarray(shape).shape

        # Set graph with parents
        self.add_parent(self._shape_var)
        self.add_parent(self._scale)

    @property
    def shape(self):
        return self._shape_var

    @property
    def scale(self):
        return self._scale

    def mean(self):
        if self._shape_var.value &lt;= 1:
            raise MathError(&#39;Mean for InvGamma is undefined for shape &lt;= 1 &#39; \
                &#39;({})&#39;.format(self._shape_var.value))
        return self._scale.value/(self._shape_var.value-1)

    def mode(self):
        return self._scale.value/(self._shape_var.value + 1)

    def variance(self):
        if self._scale.value &lt;= 2:
            raise MathError(&#39;Variance for InvGamma is undefined for &#39; \
                &#39;scale &lt;= 2 ({})&#39;.format(self._scale.value))
        return (self._scale.value**2)/ \
            ((self._shape_var.value - 1)**2) * (self._shape_var.value - 2)

    def sample(self, size=None):
        self.value = random.invgamma.sample(
            shape=self._shape_var.value,
            scale=self._scale.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        if value is None:
            value = self.value
        return random.invgamma.pdf(value=value, 
            shape=self._shape_var.value,
            scale=self._scale.value)

    def logpdf(self, value=None):
        if value is None:
            value = self.value
        return random.invgamma.logpdf(value=value, 
            shape=self._shape_var.value,
            scale=self._scale.value)


class NegativeBinomial(Variable, _RandomBase):
    def __init__(self, n, p, **kwargs):
        raise NotImplementedError(&#39;Need to switch to the mean and variance parameterization&#39;)
        Variable.__init__(self, **kwargs)
        # Wrap parameters in nodes
        if not isnode(p):
            self._p = Variable(
                value=p,
                name=self.name + &#39;_p&#39;,
                G=self.G)
        else:
            self._p = p
        self.add_parent(self._p)
        if not isnode(n):
            self._r = Variable(
                value=n,
                name=self.name + &#39;_n&#39;,
                G=self.G)
        else:
            self._n = n
        self.add_parent(self._n)

    @property
    def p(self):
        return self._p

    @property
    def n(self):
        return self._n

    def mean(self):
        return self._p.value * self._r.value / (1 - self._p.value)

    def mode(self):
        if self._r.value &gt; 1:
            # cast as int to round down
            p = self._p.value
            r = self._r.value
            return int(p*(r-1)/(1-p))
        else:
            return 0

    def variance(self):
        p = self._p.value
        r = self._r.value
        return p*r/((1-p)**2)

    def sample(self, size=None):
        self.value = npr.negative_binomial(
            n=self._n.value,
            p=self._p.value,
            size=size)
        return self.value


class Bernoulli(Variable, _RandomBase):

    def __init__(self, p, **kwargs):

        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(p):
            self._p = Variable(
                value=p,
                name=self.name + DEFAULT_BERNOULLI_P_SUFFIX,
                G=self.G)
        else:
            self._p = p

        self.add_parent(self._p)

    @property
    def p(self):
        return self._p


    def mean(self):
        return self._p

    def variance(self):
        return (1 - self._p.value) * self._p.value

    def mode(self):
        return int(self._p.value &gt;= 0.5)

    def sample(self, size=None):
        return random.bernoulli(p=self._p.value, size=size)


class Beta(Variable, _RandomBase):

    def __init__(self, a, b, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(a):
            self._a = Variable(
                value=a,
                name=self.name + DEFAULT_BETA_ALPHA_SUFFIX,
                G=self.G)
        else:
            self._a = a
        if not isnode(b):
            self._b = Variable(
                value=b,
                name=self.name + DEFAULT_BETA_BETA_SUFFIX,
                G=self.G)
        else:
            self._b = b

        self.add_parent(self._a)
        self.add_parent(self._b)

    @property
    def a(self):
        return self._a

    @property
    def b(self):
        return self._b

    def mean(self):
        &#39;&#39;&#39;E[X] = a/(a+b)
        &#39;&#39;&#39;
        return self._a.value / (self._a.value + self._b.value)

    def variance(self):
        &#39;&#39;&#39;var[X] = (a*b)/((a+b)**2 * (a+b+1))
        &#39;&#39;&#39;
        return self._a.value * self._b.value / ((self._a.value * \
            self._b.value)**2 * (self._a.value+self._b.value+1))

    def sample(self,size=None):
        self.value = random.beta.sample(a=self._a.value, b=self._b.value, size=size)
        return self.value


class MVN(Variable, _RandomBase):

    def __init__(self, mean=None, cov=None, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_MVN_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(cov):
            self._cov = Variable(
                value=cov,
                name=self.name + DEFAULT_MVN_COV_SUFFIX,
                G=self.G)
        else:
            self._cov = cov

        self.add_parent(self._mean)
        self.add_parent(self._cov)

    @property
    def mean(self):
        return self._mean

    @property
    def cov(self):
        return self._cov

    def mode(self):
        return self._mean.value

    def prec(self):
        return np.linalg.pinv(self._cov.value)

    def sample(self,idxs=None,size=None):
        &#39;&#39;&#39;
        Sample all indices or only sample at the target indices (idxs) and
        set NaN to everything else. You would want to do this if you are
        using indicator variables and you do not want to sample certain
        values

        Parameters

        idxs (array, Optional)
            - If `idxs` is specified, only set values for those indices specified
            - If an index is not specified, set it to nan
            - If nothing is sent in, it sets the values to all
        &#39;&#39;&#39;
        try:
            if idxs is None:
                self.value = random.multivariate_normal.sample(
                    mean=self._mean.value, cov=self._cov.value, size=size)
            else:
                self.value = np.empty(shape=self.value.shape)
                self.value.fill(np.nan)
                self.value[idxs] = random.multivariate_normal.sample(
                    mean=self._mean.value, cov=self._cov.value, size=size)
        except RuntimeWarning:
            logging.critical(&#39;covariance is not positive semi-definate&#39;)
            print(&#39;mean\n&#39;,np.squeeze(self._mean.value))
            print(&#39;cov\n&#39;,self._cov.value)
            raise

        return self.value</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdsine2.pylab.variables.isRandomVariable"><code class="name flex">
<span>def <span class="ident">isRandomVariable</span></span>(<span>var)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code>a</code> is a subclass of a RandomVariable</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>any</code></dt>
<dd>Instance we are checking</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>a</code> is a subclass of a RandomVariable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isRandomVariable(var):
    &#39;&#39;&#39;Checks if `a` is a subclass of a RandomVariable

    Parameters
    ----------
    a : any
        Instance we are checking

    Returns
    -------
    bool
        True if `a` is a subclass of a RandomVariable
    &#39;&#39;&#39;
    return var is not None and issubclass(var.__class__, _RandomBase)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.isVariable"><code class="name flex">
<span>def <span class="ident">isVariable</span></span>(<span>var)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code>a</code> is a subclass of a Variable</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a</code></strong> :&ensp;<code>any</code></dt>
<dd>Instance we are checking</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if <code>a</code> is a subclass of a Variable</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isVariable(var):
    &#39;&#39;&#39;Checks if `a` is a subclass of a Variable

    Parameters
    ----------
    a : any
        Instance we are checking

    Returns
    -------
    bool
        True if `a` is a subclass of a Variable
    &#39;&#39;&#39;
    return var is not None and issubclass(var.__class__, Variable)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.summary"><code class="name flex">
<span>def <span class="ident">summary</span></span>(<span>var, set_nan_to_0=False, section='posterior', only=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates different metrics about the given trace (mean,
median, 25th percentile, 75th percentile)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>var</code></strong> :&ensp;<code>Traceable, np.ndarray</code></dt>
<dd>Variable/trace we are doing the calculations on</dd>
<dt><strong><code>set_nan_to_0</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, we set the NaNs in the trace to zeros</dd>
<dt><strong><code>section</code></strong> :&ensp;<code>str</code></dt>
<dd>This is the section of the MH samples for us to retreive</dd>
<dt><strong><code>only</code></strong> :&ensp;<code>None, list(str)</code></dt>
<dd>If this is specified, then only calculate the types that are
in here. Accepted:
'mean', 'median', '25th percentile', '75th percentile'</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>mean ('mean'), median ('median'), 25th percentile
('25th percentile'), and 75th percentile ('75th percentile'),</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def summary(var, set_nan_to_0=False, section=&#39;posterior&#39;, only=None):
    &#39;&#39;&#39;Calculates different metrics about the given trace (mean, 
    median, 25th percentile, 75th percentile)

    Parameters
    ----------
    var : Traceable, np.ndarray
        Variable/trace we are doing the calculations on
    set_nan_to_0 : bool
        If True, we set the NaNs in the trace to zeros
    section : str
        This is the section of the MH samples for us to retreive
    only : None, list(str)
        If this is specified, then only calculate the types that are 
        in here. Accepted:
            &#39;mean&#39;, &#39;median&#39;, &#39;25th percentile&#39;, &#39;75th percentile&#39;

    Returns
    -------
    dict
        mean (&#39;mean&#39;), median (&#39;median&#39;), 25th percentile 
        (&#39;25th percentile&#39;), and 75th percentile (&#39;75th percentile&#39;), 
    &#39;&#39;&#39;
    if istraceable(var):
        if var.G.inference.ckpt is None:
            if section == &#39;burnin&#39;:
                var = var.trace[:var.G.inference.burnin, ...]
            elif section == &#39;posterior&#39;:
                var = var.trace[var.G.inference.burnin:, ...]
            elif section == &#39;entire&#39;:
                var = var.trace
            else:
                raise ValueError(&#39;`section` ({}) not recognized&#39;.format(section))
        else:
            var = var.get_trace_from_disk(section=section)
    elif isarray(var):
        var = np.asarray(var)
    else:
        raise ValueError(&#39;`var` ({}) must either be a subclass of Traceable &#39; \
            &#39;or an array&#39;.format(type(var)))
    if not isbool(set_nan_to_0):
        raise ValueError(&#39;`set_nan_to_0` ({}) must be a bool&#39;.format(type(set_nan_to_0)))
    if set_nan_to_0:
        var = np.nan_to_num(var)
    ret = {}
    try:
        do = True
        if only is not None:
            do = &#39;median&#39; in only
        if do is True:
            ret[&#39;median&#39;] = np.nan_to_num(np.nanmedian(var,axis=0))
    except:
        logging.error(&#39;median failed&#39;)
        ret[&#39;median&#39;] = np.nan
    try:
        do = True
        if only is not None:
            do = &#39;mean&#39; in only
        if do is True:
            ret[&#39;mean&#39;] = np.nan_to_num(np.nanmean(var,axis=0))
    except:
        logging.error(&#39;mean failed&#39;)
        ret[&#39;mean&#39;] = np.nan
    try:
        do = True
        if only is not None:
            do = &#39;25th percentile&#39; in only
        if do is True:
            ret[&#39;25th percentile&#39;] = np.nan_to_num(np.nanpercentile(var,25,axis=0))
    except:
        logging.error(&#39;25th percentile failed&#39;)
        ret[&#39;25th percentile&#39;] = np.nan
    try:
        do = True
        if only is not None:
            do = &#39;75th percentile&#39; in only
        if do is True:
            ret[&#39;75th percentile&#39;] = np.nan_to_num(np.nanpercentile(var,75,axis=0))
    except:
        logging.error(&#39;75th percentile failed&#39;)
        ret[&#39;75th percentile&#39;] = np.nan
    return ret</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdsine2.pylab.variables.Bernoulli"><code class="flex name class">
<span>class <span class="ident">Bernoulli</span></span>
<span>(</span><span>p, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar values that can change over time and be traced</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int, float, None</code></dt>
<dd>This is the value of the scalar</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Type</code></dt>
<dd>This is the type of the variable</dd>
</dl>
<p>kwargs :dict
These are the extra parameters for the Node class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bernoulli(Variable, _RandomBase):

    def __init__(self, p, **kwargs):

        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(p):
            self._p = Variable(
                value=p,
                name=self.name + DEFAULT_BERNOULLI_P_SUFFIX,
                G=self.G)
        else:
            self._p = p

        self.add_parent(self._p)

    @property
    def p(self):
        return self._p


    def mean(self):
        return self._p

    def variance(self):
        return (1 - self._p.value) * self._p.value

    def mode(self):
        return int(self._p.value &gt;= 0.5)

    def sample(self, size=None):
        return random.bernoulli(p=self._p.value, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Bernoulli.p"><code class="name">var <span class="ident">p</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def p(self):
    return self._p</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Bernoulli.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    return self._p</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Bernoulli.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    return int(self._p.value &gt;= 0.5)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Bernoulli.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample with the given parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    return random.bernoulli(p=self._p.value, size=size)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Bernoulli.variance"><code class="name flex">
<span>def <span class="ident">variance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance(self):
    return (1 - self._p.value) * self._p.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.Beta"><code class="flex name class">
<span>class <span class="ident">Beta</span></span>
<span>(</span><span>a, b, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar values that can change over time and be traced</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int, float, None</code></dt>
<dd>This is the value of the scalar</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Type</code></dt>
<dd>This is the type of the variable</dd>
</dl>
<p>kwargs :dict
These are the extra parameters for the Node class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Beta(Variable, _RandomBase):

    def __init__(self, a, b, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(a):
            self._a = Variable(
                value=a,
                name=self.name + DEFAULT_BETA_ALPHA_SUFFIX,
                G=self.G)
        else:
            self._a = a
        if not isnode(b):
            self._b = Variable(
                value=b,
                name=self.name + DEFAULT_BETA_BETA_SUFFIX,
                G=self.G)
        else:
            self._b = b

        self.add_parent(self._a)
        self.add_parent(self._b)

    @property
    def a(self):
        return self._a

    @property
    def b(self):
        return self._b

    def mean(self):
        &#39;&#39;&#39;E[X] = a/(a+b)
        &#39;&#39;&#39;
        return self._a.value / (self._a.value + self._b.value)

    def variance(self):
        &#39;&#39;&#39;var[X] = (a*b)/((a+b)**2 * (a+b+1))
        &#39;&#39;&#39;
        return self._a.value * self._b.value / ((self._a.value * \
            self._b.value)**2 * (self._a.value+self._b.value+1))

    def sample(self,size=None):
        self.value = random.beta.sample(a=self._a.value, b=self._b.value, size=size)
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.posterior.ClusterInteractionIndicatorProbability" href="../posterior.html#mdsine2.posterior.ClusterInteractionIndicatorProbability">ClusterInteractionIndicatorProbability</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Beta.a"><code class="name">var <span class="ident">a</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def a(self):
    return self._a</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Beta.b"><code class="name">var <span class="ident">b</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def b(self):
    return self._b</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Beta.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>E[X] = a/(a+b)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    &#39;&#39;&#39;E[X] = a/(a+b)
    &#39;&#39;&#39;
    return self._a.value / (self._a.value + self._b.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Beta.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample with the given parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self,size=None):
    self.value = random.beta.sample(a=self._a.value, b=self._b.value, size=size)
    return self.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Beta.variance"><code class="name flex">
<span>def <span class="ident">variance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>var[X] = (a<em>b)/((a+b)</em>*2 * (a+b+1))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance(self):
    &#39;&#39;&#39;var[X] = (a*b)/((a+b)**2 * (a+b+1))
    &#39;&#39;&#39;
    return self._a.value * self._b.value / ((self._a.value * \
        self._b.value)**2 * (self._a.value+self._b.value+1))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.Constant"><code class="flex name class">
<span>class <span class="ident">Constant</span></span>
<span>(</span><span>value, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A value in the graph that does not change.
This can be a scalar or a matrix. We can manually override the value
by calling <code>override_value</code>. We do this for model safety.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>any</code></dt>
<dd>This is the value of the constant</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are the extra arguments for the Node class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Constant(Node, _BaseArithmeticClass):
    &#39;&#39;&#39;A value in the graph that does not change.
    This can be a scalar or a matrix. We can manually override the value
    by calling `override_value`. We do this for model safety.

    Parameters
    ----------
    value : any
        This is the value of the constant
    kwargs : dict
        These are the extra arguments for the Node class
    &#39;&#39;&#39;
    def __init__(self, value, **kwargs):
        self._value = value
        Node.__init__(self, **kwargs)

    def override_value(self, val):
        &#39;&#39;&#39;Override the value with `val`

        Parameters
        ----------
        val : any
            Value to override self.value with
        &#39;&#39;&#39;
        self._value = val

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, val):
        raise UndefinedError(&#39;{} - Cannot change the value of a constant. If you &#39; \
            &#39;want to change the value, then you must call the function &#39; \
            &#39;`override_value` explicitly&#39;.format(self.name))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Constant.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    return self._value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Constant.override_value"><code class="name flex">
<span>def <span class="ident">override_value</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Override the value with <code>val</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>val</code></strong> :&ensp;<code>any</code></dt>
<dd>Value to override self.value with</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_value(self, val):
    &#39;&#39;&#39;Override the value with `val`

    Parameters
    ----------
    val : any
        Value to override self.value with
    &#39;&#39;&#39;
    self._value = val</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.graph.Node.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.Gamma"><code class="flex name class">
<span>class <span class="ident">Gamma</span></span>
<span>(</span><span>shape, scale, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Gamma Distribution but for multiple values</p>
<p><code>shape</code> is a pylab.variables.Variable, <code>scale</code> is a
pylab.variables.Variable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gamma(Variable, _RandomBase):
    &#39;&#39;&#39;Gamma Distribution but for multiple values

    `shape` is a pylab.variables.Variable, `scale` is a
    pylab.variables.Variable
    &#39;&#39;&#39;
    def __init__(self, shape, scale, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(shape):
            self._shape_var = Variable(
                value=shape,
                name=self.name + DEFAULT_GAMMA_SHAPE_SUFFIX,
                G=self.G)
        else:
            self._shape_var = shape
        if not isnode(scale):
            self._scale = Variable(
                value=scale,
                name=self.name + DEFAULT_GAMMA_SCALE_SUFFIX,
                G=self.G)
        else:
            self._scale = scale

        if isarray(shape):
            self._shape = np.asarray(shape).shape

        # Set graph with parents
        self.add_parent(self._shape_var)
        self.add_parent(self._scale)

    @property
    def shape(self):
        return self._shape_var

    @property
    def scale(self):
        return self._scale

    def mean(self):
        return self._shape_var.value * self._scale.value

    def variance(self):
        return self._shape_var.value * (self._scale.value) ** 2

    def sample(self, size=None):
        self.value = random.gamma.sample(
            shape=self._shape_var.value,
            scale=self._scale.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.shape`, and `self.scale`. 
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.gamma.pdf(value=value, 
            shape=self._shape_var.value, scale=self._scale.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.posterior.Concentration" href="../posterior.html#mdsine2.posterior.Concentration">Concentration</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Gamma.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale(self):
    return self._scale</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Gamma.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._shape_var</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Gamma.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    return self._shape_var.value * self._scale.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Gamma.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf given <code>self.value</code>, <code>self.shape</code>, and <code>self.scale</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self, value=None):
    &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.shape`, and `self.scale`. 
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.gamma.pdf(value=value, 
        shape=self._shape_var.value, scale=self._scale.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Gamma.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample with the given parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    self.value = random.gamma.sample(
        shape=self._shape_var.value,
        scale=self._scale.value,
        size=size)
    return self.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Gamma.variance"><code class="name flex">
<span>def <span class="ident">variance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance(self):
    return self._shape_var.value * (self._scale.value) ** 2</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.InvGamma"><code class="flex name class">
<span>class <span class="ident">InvGamma</span></span>
<span>(</span><span>shape, scale, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar values that can change over time and be traced</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int, float, None</code></dt>
<dd>This is the value of the scalar</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Type</code></dt>
<dd>This is the type of the variable</dd>
</dl>
<p>kwargs :dict
These are the extra parameters for the Node class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvGamma(Variable, _RandomBase):
    def __init__(self, shape, scale, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(shape):
            self._shape_var = Variable(
                value=shape,
                name=self.name + DEFAULT_GAMMA_SHAPE_SUFFIX,
                G=self.G)
        else:
            self._shape_var = shape
        if not isnode(scale):
            self._scale = Variable(
                value=scale,
                name=self.name + DEFAULT_GAMMA_SCALE_SUFFIX,
                G=self.G)
        else:
            self._scale = scale

        if isarray(shape):
            self._shape = np.asarray(shape).shape

        # Set graph with parents
        self.add_parent(self._shape_var)
        self.add_parent(self._scale)

    @property
    def shape(self):
        return self._shape_var

    @property
    def scale(self):
        return self._scale

    def mean(self):
        if self._shape_var.value &lt;= 1:
            raise MathError(&#39;Mean for InvGamma is undefined for shape &lt;= 1 &#39; \
                &#39;({})&#39;.format(self._shape_var.value))
        return self._scale.value/(self._shape_var.value-1)

    def mode(self):
        return self._scale.value/(self._shape_var.value + 1)

    def variance(self):
        if self._scale.value &lt;= 2:
            raise MathError(&#39;Variance for InvGamma is undefined for &#39; \
                &#39;scale &lt;= 2 ({})&#39;.format(self._scale.value))
        return (self._scale.value**2)/ \
            ((self._shape_var.value - 1)**2) * (self._shape_var.value - 2)

    def sample(self, size=None):
        self.value = random.invgamma.sample(
            shape=self._shape_var.value,
            scale=self._scale.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        if value is None:
            value = self.value
        return random.invgamma.pdf(value=value, 
            shape=self._shape_var.value,
            scale=self._scale.value)

    def logpdf(self, value=None):
        if value is None:
            value = self.value
        return random.invgamma.logpdf(value=value, 
            shape=self._shape_var.value,
            scale=self._scale.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.InvGamma.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale(self):
    return self._scale</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.InvGamma.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._shape_var</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.InvGamma.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf with the specified value. If <code>value</code> is not
specified, then use the current value</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, array_like</code></dt>
<dd>Value we are using instead of self.value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logpdf(self, value=None):
    if value is None:
        value = self.value
    return random.invgamma.logpdf(value=value, 
        shape=self._shape_var.value,
        scale=self._scale.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.InvGamma.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    if self._shape_var.value &lt;= 1:
        raise MathError(&#39;Mean for InvGamma is undefined for shape &lt;= 1 &#39; \
            &#39;({})&#39;.format(self._shape_var.value))
    return self._scale.value/(self._shape_var.value-1)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.InvGamma.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    return self._scale.value/(self._shape_var.value + 1)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.InvGamma.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf with the specified value. If <code>value</code> is not
specified, then use the current value</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, array_like</code></dt>
<dd>Value we are using instead of self.value</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self, value=None):
    if value is None:
        value = self.value
    return random.invgamma.pdf(value=value, 
        shape=self._shape_var.value,
        scale=self._scale.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.InvGamma.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample with the given parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    self.value = random.invgamma.sample(
        shape=self._shape_var.value,
        scale=self._scale.value,
        size=size)
    return self.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.InvGamma.variance"><code class="name flex">
<span>def <span class="ident">variance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance(self):
    if self._scale.value &lt;= 2:
        raise MathError(&#39;Variance for InvGamma is undefined for &#39; \
            &#39;scale &lt;= 2 ({})&#39;.format(self._scale.value))
    return (self._scale.value**2)/ \
        ((self._shape_var.value - 1)**2) * (self._shape_var.value - 2)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.Lognormal"><code class="flex name class">
<span>class <span class="ident">Lognormal</span></span>
<span>(</span><span>mean, std, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Lognormal distribution</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>numeric, array</code></dt>
<dd>This is the mean of the distribution</dd>
<dt><strong><code>std</code></strong> :&ensp;<code>numeric array</code></dt>
<dd>This is the standard deviation of the array</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lognormal(Variable, _RandomBase):
    &#39;&#39;&#39;Lognormal distribution

    Parameters
    ----------
    mean : numeric, array
        This is the mean of the distribution
    std : numeric array
        This is the standard deviation of the array
    kwargs
    &#39;&#39;&#39;
    def __init__(self, mean, std, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_NORMAL_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(std):
            self._std = Variable(
                value=std,
                name=self.name + DEFAULT_LOGNORMAL_STD_SUFFIX,
                G=self.G)
        else:
            self._std = std

        # Set graph with parents
        self.add_parent(self._mean)
        self.add_parent(self._std)

    @property
    def mean(self):
        return self._mean

    @property
    def std(self):
        return self._std

    def mode(self):
        return self._mean.value

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.mean` and `self.var`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.lognormal.sample(
            mean=self._mean.value, 
            std=self._std.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.pdf(value=value, mean=self._mean.value,
            std=self._std.value)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.logpdf(value=value, mean=self._mean.value,
            std=self._std.value)

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.cdf(value=value, mean=self._mean.value,
            std=self._std.value)

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.lognormal.logcdf(value=value, mean=self._mean.value,
            std=self._std.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Lognormal.mean"><code class="name">var <span class="ident">mean</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean(self):
    return self._mean</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Lognormal.std"><code class="name">var <span class="ident">std</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def std(self):
    return self._std</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Lognormal.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, value=None):
    &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.lognormal.cdf(value=value, mean=self._mean.value,
        std=self._std.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Lognormal.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logcdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logcdf(self, value=None):
    &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.lognormal.logcdf(value=value, mean=self._mean.value,
        std=self._std.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Lognormal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logpdf(self, value=None):
    &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.lognormal.logpdf(value=value, mean=self._mean.value,
        std=self._std.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Lognormal.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    return self._mean.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Lognormal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self, value=None):
    &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.lognormal.pdf(value=value, mean=self._mean.value,
        std=self._std.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Lognormal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the distirbution given <code>self.mean</code> and <code>self.var</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int, None, Optional</code></dt>
<dd>How many samples the pull</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    &#39;&#39;&#39;Sample the distirbution given `self.mean` and `self.var`

    Parameters
    ----------
    size : int, None, Optional
        How many samples the pull

    Returns
    -------
    float
    &#39;&#39;&#39;
    self.value = random.lognormal.sample(
        mean=self._mean.value, 
        std=self._std.value,
        size=size)
    return self.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.MVN"><code class="flex name class">
<span>class <span class="ident">MVN</span></span>
<span>(</span><span>mean=None, cov=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar values that can change over time and be traced</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int, float, None</code></dt>
<dd>This is the value of the scalar</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Type</code></dt>
<dd>This is the type of the variable</dd>
</dl>
<p>kwargs :dict
These are the extra parameters for the Node class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MVN(Variable, _RandomBase):

    def __init__(self, mean=None, cov=None, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_MVN_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(cov):
            self._cov = Variable(
                value=cov,
                name=self.name + DEFAULT_MVN_COV_SUFFIX,
                G=self.G)
        else:
            self._cov = cov

        self.add_parent(self._mean)
        self.add_parent(self._cov)

    @property
    def mean(self):
        return self._mean

    @property
    def cov(self):
        return self._cov

    def mode(self):
        return self._mean.value

    def prec(self):
        return np.linalg.pinv(self._cov.value)

    def sample(self,idxs=None,size=None):
        &#39;&#39;&#39;
        Sample all indices or only sample at the target indices (idxs) and
        set NaN to everything else. You would want to do this if you are
        using indicator variables and you do not want to sample certain
        values

        Parameters

        idxs (array, Optional)
            - If `idxs` is specified, only set values for those indices specified
            - If an index is not specified, set it to nan
            - If nothing is sent in, it sets the values to all
        &#39;&#39;&#39;
        try:
            if idxs is None:
                self.value = random.multivariate_normal.sample(
                    mean=self._mean.value, cov=self._cov.value, size=size)
            else:
                self.value = np.empty(shape=self.value.shape)
                self.value.fill(np.nan)
                self.value[idxs] = random.multivariate_normal.sample(
                    mean=self._mean.value, cov=self._cov.value, size=size)
        except RuntimeWarning:
            logging.critical(&#39;covariance is not positive semi-definate&#39;)
            print(&#39;mean\n&#39;,np.squeeze(self._mean.value))
            print(&#39;cov\n&#39;,self._cov.value)
            raise

        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.posterior.ClusterInteractionValue" href="../posterior.html#mdsine2.posterior.ClusterInteractionValue">ClusterInteractionValue</a></li>
<li><a title="mdsine2.posterior.RegressCoeff" href="../posterior.html#mdsine2.posterior.RegressCoeff">RegressCoeff</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.MVN.cov"><code class="name">var <span class="ident">cov</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cov(self):
    return self._cov</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.MVN.mean"><code class="name">var <span class="ident">mean</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean(self):
    return self._mean</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.MVN.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    return self._mean.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.MVN.prec"><code class="name flex">
<span>def <span class="ident">prec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prec(self):
    return np.linalg.pinv(self._cov.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.MVN.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, idxs=None, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample all indices or only sample at the target indices (idxs) and
set NaN to everything else. You would want to do this if you are
using indicator variables and you do not want to sample certain
values</p>
<p>Parameters</p>
<p>idxs (array, Optional)
- If <code>idxs</code> is specified, only set values for those indices specified
- If an index is not specified, set it to nan
- If nothing is sent in, it sets the values to all</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self,idxs=None,size=None):
    &#39;&#39;&#39;
    Sample all indices or only sample at the target indices (idxs) and
    set NaN to everything else. You would want to do this if you are
    using indicator variables and you do not want to sample certain
    values

    Parameters

    idxs (array, Optional)
        - If `idxs` is specified, only set values for those indices specified
        - If an index is not specified, set it to nan
        - If nothing is sent in, it sets the values to all
    &#39;&#39;&#39;
    try:
        if idxs is None:
            self.value = random.multivariate_normal.sample(
                mean=self._mean.value, cov=self._cov.value, size=size)
        else:
            self.value = np.empty(shape=self.value.shape)
            self.value.fill(np.nan)
            self.value[idxs] = random.multivariate_normal.sample(
                mean=self._mean.value, cov=self._cov.value, size=size)
    except RuntimeWarning:
        logging.critical(&#39;covariance is not positive semi-definate&#39;)
        print(&#39;mean\n&#39;,np.squeeze(self._mean.value))
        print(&#39;cov\n&#39;,self._cov.value)
        raise

    return self.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.NegativeBinomial"><code class="flex name class">
<span>class <span class="ident">NegativeBinomial</span></span>
<span>(</span><span>n, p, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar values that can change over time and be traced</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int, float, None</code></dt>
<dd>This is the value of the scalar</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Type</code></dt>
<dd>This is the type of the variable</dd>
</dl>
<p>kwargs :dict
These are the extra parameters for the Node class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NegativeBinomial(Variable, _RandomBase):
    def __init__(self, n, p, **kwargs):
        raise NotImplementedError(&#39;Need to switch to the mean and variance parameterization&#39;)
        Variable.__init__(self, **kwargs)
        # Wrap parameters in nodes
        if not isnode(p):
            self._p = Variable(
                value=p,
                name=self.name + &#39;_p&#39;,
                G=self.G)
        else:
            self._p = p
        self.add_parent(self._p)
        if not isnode(n):
            self._r = Variable(
                value=n,
                name=self.name + &#39;_n&#39;,
                G=self.G)
        else:
            self._n = n
        self.add_parent(self._n)

    @property
    def p(self):
        return self._p

    @property
    def n(self):
        return self._n

    def mean(self):
        return self._p.value * self._r.value / (1 - self._p.value)

    def mode(self):
        if self._r.value &gt; 1:
            # cast as int to round down
            p = self._p.value
            r = self._r.value
            return int(p*(r-1)/(1-p))
        else:
            return 0

    def variance(self):
        p = self._p.value
        r = self._r.value
        return p*r/((1-p)**2)

    def sample(self, size=None):
        self.value = npr.negative_binomial(
            n=self._n.value,
            p=self._p.value,
            size=size)
        return self.value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.NegativeBinomial.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    return self._n</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.NegativeBinomial.p"><code class="name">var <span class="ident">p</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def p(self):
    return self._p</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.NegativeBinomial.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    return self._p.value * self._r.value / (1 - self._p.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.NegativeBinomial.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    if self._r.value &gt; 1:
        # cast as int to round down
        p = self._p.value
        r = self._r.value
        return int(p*(r-1)/(1-p))
    else:
        return 0</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.NegativeBinomial.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample with the given parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    self.value = npr.negative_binomial(
        n=self._n.value,
        p=self._p.value,
        size=size)
    return self.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.NegativeBinomial.variance"><code class="name flex">
<span>def <span class="ident">variance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance(self):
    p = self._p.value
    r = self._r.value
    return p*r/((1-p)**2)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.Normal"><code class="flex name class">
<span>class <span class="ident">Normal</span></span>
<span>(</span><span>mean=None, var=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar normal variable parameterized by the mean and variance</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the mean of the distribution</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the variance of the distribution</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are extra parameters for the Node class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Normal(Variable, _RandomBase):
    &#39;&#39;&#39;Scalar normal variable parameterized by the mean and variance

    Parameters
    ----------
    mean : float, int
        This is the mean of the distribution
    var : float, int
        This is the variance of the distribution
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, mean=None, var=None, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_NORMAL_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(var):
            self._var = Variable(
                value=var,
                name=self.name + DEFAULT_NORMAL_VAR_SUFFIX,
                G=self.G)
        else:
            self._var = var

        # Set graph with parents
        self.add_parent(self._mean)
        self.add_parent(self._var)

    @property
    def mean(self):
        return self._mean

    @property
    def var(self):
        return self._var

    @property
    def std(self):
        return np.sqrt(self._var.value)

    def mode(self):
        return self._mean.value

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.mean` and `self.var`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.normal.sample(
            mean=self._mean.value, 
            std=np.sqrt(self._var.value),
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.pdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.logpdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.cdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, and `self.var`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.normal.logcdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.posterior.PerturbationMagnitudes" href="../posterior.html#mdsine2.posterior.PerturbationMagnitudes">PerturbationMagnitudes</a></li>
<li><a title="mdsine2.posterior.PriorMeanInteractions" href="../posterior.html#mdsine2.posterior.PriorMeanInteractions">PriorMeanInteractions</a></li>
<li><a title="mdsine2.posterior.PriorMeanPerturbationSingle" href="../posterior.html#mdsine2.posterior.PriorMeanPerturbationSingle">PriorMeanPerturbationSingle</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Normal.mean"><code class="name">var <span class="ident">mean</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean(self):
    return self._mean</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Normal.std"><code class="name">var <span class="ident">std</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def std(self):
    return np.sqrt(self._var.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Normal.var"><code class="name">var <span class="ident">var</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def var(self):
    return self._var</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Normal.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, value=None):
    &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.normal.cdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Normal.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logcdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logcdf(self, value=None):
    &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.normal.logcdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Normal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logpdf(self, value=None):
    &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.normal.logpdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Normal.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    return self._mean.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Normal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf given <code>self.value</code>, <code>self.mean</code>, and <code>self.var</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self, value=None):
    &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, and `self.var`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.normal.pdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value))</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Normal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the distirbution given <code>self.mean</code> and <code>self.var</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int, None, Optional</code></dt>
<dd>How many samples the pull</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    &#39;&#39;&#39;Sample the distirbution given `self.mean` and `self.var`

    Parameters
    ----------
    size : int, None, Optional
        How many samples the pull

    Returns
    -------
    float
    &#39;&#39;&#39;
    self.value = random.normal.sample(
        mean=self._mean.value, 
        std=np.sqrt(self._var.value),
        size=size)
    return self.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.SICS"><code class="flex name class">
<span>class <span class="ident">SICS</span></span>
<span>(</span><span>dof=None, scale=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scaled Inverse Chi Square parameterized by degrees of freedom <code>dof</code> and
scale <code>scale</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dof</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the dof of the distribution</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the scale of the distribution</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are extra parameters for the Node class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SICS(Variable, _RandomBase):
    &#39;&#39;&#39;Scaled Inverse Chi Square parameterized by degrees of freedom `dof` and 
    scale `scale`.
    
    Parameters
    ----------
    dof : float, int
        This is the dof of the distribution
    scale : float, int
        This is the scale of the distribution
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, dof=None, scale=None, **kwargs):
        Variable.__init__(self, **kwargs)

        # Wrap parameters in nodes
        if not isnode(dof):
            self._dof = Variable(
                value=dof,
                name=self.name + DEFAULT_SICS_DOF_SUFFIX,
                G=self.G)
        else:
            self._dof = dof
        if not isnode(scale):
            self._scale = Variable(
                value=scale,
                name=self.name + DEFAULT_SICS_SCALE_SUFFIX,
                G=self.G)
        else:
            self._scale = scale

        # Set graph with parents
        self.add_parent(self._dof)
        self.add_parent(self._scale)

    @property
    def dof(self):
        return self._dof

    @property
    def scale(self):
        return self._scale

    def mean(self):
        return self._dof.value * self._scale.value/ \
            (self._dof.value-2)

    def mode(self):
        return self._dof.value * self._scale.value / \
            (self._dof.value + 2)

    def sample(self, size=None):
        &#39;&#39;&#39;Sample from a SICS distribution parameerized by the current
        values of `scale` and `dof`.

        Parameters
        ----------
        size : int, None
            This is how many samples to draw. If None then we only draw a 
            single sample.

        Returns
        -------
        float, np.ndarray(float)
        &#39;&#39;&#39;
        self.value = random.sics.sample(
            dof=self._dof.value,
            scale=self._scale.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given the internal state. If `value` is defined,
        calculate the pdf with the passed in value instead of `self.value`.

        Parameters
        ----------
        value : numeric
            Value to calculate the pdf of instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.sics.pdf(value=value,
            dof=self._dof.value, scale=self._scale.value)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given the internal state. If `value` is defined,
        calculate the logpdf with the passed in value instead of `self.value`.

        Parameters
        ----------
        value : numeric
            Value to calculate the logpdf of instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.sics.logpdf(value=value,
            dof=self._dof.value, scale=self._scale.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.posterior.PriorVarInteractions" href="../posterior.html#mdsine2.posterior.PriorVarInteractions">PriorVarInteractions</a></li>
<li><a title="mdsine2.posterior.PriorVarMH" href="../posterior.html#mdsine2.posterior.PriorVarMH">PriorVarMH</a></li>
<li><a title="mdsine2.posterior.PriorVarPerturbationSingle" href="../posterior.html#mdsine2.posterior.PriorVarPerturbationSingle">PriorVarPerturbationSingle</a></li>
<li><a title="mdsine2.posterior.ProcessVarGlobal" href="../posterior.html#mdsine2.posterior.ProcessVarGlobal">ProcessVarGlobal</a></li>
<li><a title="mdsine2.posterior.qPCRScaleL" href="../posterior.html#mdsine2.posterior.qPCRScaleL">qPCRScaleL</a></li>
<li><a title="mdsine2.posterior.qPCRVarianceReplicate" href="../posterior.html#mdsine2.posterior.qPCRVarianceReplicate">qPCRVarianceReplicate</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.SICS.dof"><code class="name">var <span class="ident">dof</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dof(self):
    return self._dof</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.SICS.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale(self):
    return self._scale</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.SICS.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf given the internal state. If <code>value</code> is defined,
calculate the logpdf with the passed in value instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>numeric</code></dt>
<dd>Value to calculate the logpdf of instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logpdf(self, value=None):
    &#39;&#39;&#39;Calculate the logpdf given the internal state. If `value` is defined,
    calculate the logpdf with the passed in value instead of `self.value`.

    Parameters
    ----------
    value : numeric
        Value to calculate the logpdf of instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.sics.logpdf(value=value,
        dof=self._dof.value, scale=self._scale.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.SICS.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    return self._dof.value * self._scale.value/ \
        (self._dof.value-2)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.SICS.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    return self._dof.value * self._scale.value / \
        (self._dof.value + 2)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.SICS.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf given the internal state. If <code>value</code> is defined,
calculate the pdf with the passed in value instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>numeric</code></dt>
<dd>Value to calculate the pdf of instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self, value=None):
    &#39;&#39;&#39;Calculate the pdf given the internal state. If `value` is defined,
    calculate the pdf with the passed in value instead of `self.value`.

    Parameters
    ----------
    value : numeric
        Value to calculate the pdf of instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.sics.pdf(value=value,
        dof=self._dof.value, scale=self._scale.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.SICS.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from a SICS distribution parameerized by the current
values of <code>scale</code> and <code>dof</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int, None</code></dt>
<dd>This is how many samples to draw. If None then we only draw a
single sample.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float, np.ndarray(float)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    &#39;&#39;&#39;Sample from a SICS distribution parameerized by the current
    values of `scale` and `dof`.

    Parameters
    ----------
    size : int, None
        This is how many samples to draw. If None then we only draw a 
        single sample.

    Returns
    -------
    float, np.ndarray(float)
    &#39;&#39;&#39;
    self.value = random.sics.sample(
        dof=self._dof.value,
        scale=self._scale.value,
        size=size)
    return self.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal"><code class="flex name class">
<span>class <span class="ident">TruncatedNormal</span></span>
<span>(</span><span>mean, var, low=None, high=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar truncated normal variable parameterized by the mean, variance,
low, and high</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the mean of the distribution</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the variance of the distribution</dd>
<dt><strong><code>low</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the lowest value that can be sampled</dd>
<dt><strong><code>high</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the highest value that can be sampled</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are extra parameters for the Node class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TruncatedNormal(Variable, _RandomBase):
    &#39;&#39;&#39;Scalar truncated normal variable parameterized by the mean, variance,
    low, and high

    Parameters
    ----------
    mean : float, int
        This is the mean of the distribution
    var : float, int
        This is the variance of the distribution
    low : float, int
        This is the lowest value that can be sampled
    high : float, int
        This is the highest value that can be sampled
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, mean, var, low=None, high=None, **kwargs):
        Variable.__init__(self, **kwargs)

        if low is None:
            low = float(&#39;-inf&#39;)
        if high is None:
            high = float(&#39;inf&#39;)
        if low &gt; high:
            raise ValueError(&#39;`low` ({}) cannot be larger than `high` ({})&#39;.format(
                low,high))

        # Wrap parameters in nodes
        if not isnode(mean):
            self._mean = Variable(
                value=mean,
                name=self.name + DEFAULT_NORMAL_MEAN_SUFFIX,
                G=self.G)
        else:
            self._mean = mean
        if not isnode(var):
            self._var = Variable(
                value=var,
                name=self.name + DEFAULT_NORMAL_VAR_SUFFIX,
                G=self.G)
        else:
            self._var = var

        self.low=low
        self.high=high

        # Set graph with parents
        self.add_parent(self._mean)
        self.add_parent(self._var)

    @property
    def mean(self):
        return self._mean

    @property
    def var(self):
        return self._var

    @property
    def std(self):
        return np.sqrt(self._var.value)

    def mode(self):
        if self.low &lt;= self.mean and self.mean &lt;= self.high:
            return self.mean
        elif self.mean &lt; self.low:
            return self.low
        else:
            return self.high

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.mean`, `self.var`, 
        `self.low`, and `self.high`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.truncnormal.sample(
            low=self.low,
            high=self.high,
            mean=self._mean.value,
            std=np.sqrt(self._var.value),
            size=size)

        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.pdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.logpdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.cdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, `self.var`, 
        `self.low` and `self.high`. If `value` is provided we use `value` 
        instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.truncnormal.logcdf(value=value, mean=self._mean.value,
            std=np.sqrt(self._var.value), low=self.low, high=self.high)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.posterior.Growth" href="../posterior.html#mdsine2.posterior.Growth">Growth</a></li>
<li><a title="mdsine2.posterior.PriorMeanMH" href="../posterior.html#mdsine2.posterior.PriorMeanMH">PriorMeanMH</a></li>
<li><a title="mdsine2.posterior.SelfInteractions" href="../posterior.html#mdsine2.posterior.SelfInteractions">SelfInteractions</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.TruncatedNormal.mean"><code class="name">var <span class="ident">mean</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean(self):
    return self._mean</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal.std"><code class="name">var <span class="ident">std</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def std(self):
    return np.sqrt(self._var.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal.var"><code class="name">var <span class="ident">var</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def var(self):
    return self._var</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.TruncatedNormal.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cdf given <code>self.value</code>, <code>self.mean</code>, <code>self.var</code>,
<code>self.low</code> and <code>self.high</code>. If <code>value</code> is provided we use <code>value</code>
instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, value=None):
    &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.mean`, `self.var`, 
    `self.low` and `self.high`. If `value` is provided we use `value` 
    instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.truncnormal.cdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value), low=self.low, high=self.high)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logcdf given <code>self.value</code>, <code>self.mean</code>, <code>self.var</code>,
<code>self.low</code> and <code>self.high</code>. If <code>value</code> is provided we use <code>value</code>
instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logcdf(self, value=None):
    &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.mean`, `self.var`, 
    `self.low` and `self.high`. If `value` is provided we use `value` 
    instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.truncnormal.logcdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value), low=self.low, high=self.high)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf given <code>self.value</code>, <code>self.mean</code>, <code>self.var</code>,
<code>self.low</code> and <code>self.high</code>. If <code>value</code> is provided we use <code>value</code>
instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logpdf(self, value=None):
    &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.mean`, `self.var`, 
    `self.low` and `self.high`. If `value` is provided we use `value` 
    instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.truncnormal.logpdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value), low=self.low, high=self.high)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal.mode"><code class="name flex">
<span>def <span class="ident">mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mode(self):
    if self.low &lt;= self.mean and self.mean &lt;= self.high:
        return self.mean
    elif self.mean &lt; self.low:
        return self.low
    else:
        return self.high</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf given <code>self.value</code>, <code>self.mean</code>, <code>self.var</code>,
<code>self.low</code> and <code>self.high</code>. If <code>value</code> is provided we use <code>value</code>
instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self, value=None):
    &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.mean`, `self.var`, 
    `self.low` and `self.high`. If `value` is provided we use `value` 
    instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.truncnormal.pdf(value=value, mean=self._mean.value,
        std=np.sqrt(self._var.value), low=self.low, high=self.high)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.TruncatedNormal.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the distirbution given <code>self.mean</code>, <code>self.var</code>,
<code>self.low</code>, and <code>self.high</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int, None, Optional</code></dt>
<dd>How many samples the pull</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    &#39;&#39;&#39;Sample the distirbution given `self.mean`, `self.var`, 
    `self.low`, and `self.high`

    Parameters
    ----------
    size : int, None, Optional
        How many samples the pull

    Returns
    -------
    float
    &#39;&#39;&#39;
    self.value = random.truncnormal.sample(
        low=self.low,
        high=self.high,
        mean=self._mean.value,
        std=np.sqrt(self._var.value),
        size=size)

    return self.value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.Uniform"><code class="flex name class">
<span>class <span class="ident">Uniform</span></span>
<span>(</span><span>low=None, high=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar Uniform variable parameterized by the low and high</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>low</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the low of the distribution</dd>
<dt><strong><code>high</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the high of the distribution</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are extra parameters for the Node class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Uniform(Variable, _RandomBase):
    &#39;&#39;&#39;Scalar Uniform variable parameterized by the low and high

    Parameters
    ----------
    low : float, int
        This is the low of the distribution
    high : float, int
        This is the high of the distribution
    kwargs : dict
        These are extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, low=None, high=None, **kwargs):
        Variable.__init__(self, **kwargs)
        # Wrap parameters in nodes
        if not isnode(low):
            self._low = Variable(
                value=low,
                name=self.name+DEFAULT_UNIFORM_LOW_SUFFIX,
                G=self.G)
        else:
            self._low = low
        if not isnode(high):
            self._high = Variable(
                value=high,
                name=self.name + DEFAULT_UNIFORM_HIGH_SUFFIX,
                G=self.G)
        else:
            self._high = high

        self.add_parent(self._low)
        self.add_parent(self._high)

    @property
    def low(self):
        return self._low

    @property
    def high(self):
        return self._high

    def mean(self):
        return 0.5*(self._low.value + self._high.value)

    def median(self):
        return self.mean()

    def var(self):
        return (1/12)*(self._high.value - self._low.value)**2

    def variance(self):
        return self.var()

    def sample(self, size=None):
        &#39;&#39;&#39;Sample the distirbution given `self.low` and `self.high`

        Parameters
        ----------
        size : int, None, Optional
            How many samples the pull

        Returns
        -------
        float
        &#39;&#39;&#39;
        self.value = random.uniform.sample(
            low=self._low.value, 
            high=self._high.value,
            size=size)
        return self.value

    def pdf(self, value=None):
        &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.pdf(value=value, low=self._low.value,
            high=self._high.value)

    def logpdf(self, value=None):
        &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.logpdf(value=value, low=self._low.value,
            high=self._high.value)

    def cdf(self, value=None):
        &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.cdf(value=value, low=self._low.value,
            high=self._high.value)

    def logcdf(self, value=None):
        &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.low`, and `self.high`.
        If `value` is provided we use `value` instead of `self.value`.

        Parameters
        ----------
        value : float, int, None
            Value to calculate from instead of `self.value`

        Returns
        -------
        float
        &#39;&#39;&#39;
        if value is None:
            value = self.value
        return random.uniform.logcdf(value=value, low=self._low.value,
            high=self._high.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.negbin.NegBinDispersionParam" href="../negbin.html#mdsine2.negbin.NegBinDispersionParam">NegBinDispersionParam</a></li>
<li><a title="mdsine2.posterior.qPCRDegsOfFreedomL" href="../posterior.html#mdsine2.posterior.qPCRDegsOfFreedomL">qPCRDegsOfFreedomL</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Uniform.high"><code class="name">var <span class="ident">high</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def high(self):
    return self._high</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.low"><code class="name">var <span class="ident">low</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def low(self):
    return self._low</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Uniform.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cdf given <code>self.value</code>, <code>self.low</code>, and <code>self.high</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, value=None):
    &#39;&#39;&#39;Calculate the cdf given `self.value`, `self.low`, and `self.high`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.uniform.cdf(value=value, low=self._low.value,
        high=self._high.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.logcdf"><code class="name flex">
<span>def <span class="ident">logcdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logcdf given <code>self.value</code>, <code>self.low</code>, and <code>self.high</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logcdf(self, value=None):
    &#39;&#39;&#39;Calculate the logcdf given `self.value`, `self.low`, and `self.high`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.uniform.logcdf(value=value, low=self._low.value,
        high=self._high.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.logpdf"><code class="name flex">
<span>def <span class="ident">logpdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the logpdf given <code>self.value</code>, <code>self.low</code>, and <code>self.high</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logpdf(self, value=None):
    &#39;&#39;&#39;Calculate the logpdf given `self.value`, `self.low`, and `self.high`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.uniform.logpdf(value=value, low=self._low.value,
        high=self._high.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self):
    return 0.5*(self._low.value + self._high.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.median"><code class="name flex">
<span>def <span class="ident">median</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def median(self):
    return self.mean()</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the pdf given <code>self.value</code>, <code>self.low</code>, and <code>self.high</code>.
If <code>value</code> is provided we use <code>value</code> instead of <code>self.value</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, int, None</code></dt>
<dd>Value to calculate from instead of <code>self.value</code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self, value=None):
    &#39;&#39;&#39;Calculate the pdf given `self.value`, `self.low`, and `self.high`.
    If `value` is provided we use `value` instead of `self.value`.

    Parameters
    ----------
    value : float, int, None
        Value to calculate from instead of `self.value`

    Returns
    -------
    float
    &#39;&#39;&#39;
    if value is None:
        value = self.value
    return random.uniform.pdf(value=value, low=self._low.value,
        high=self._high.value)</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample the distirbution given <code>self.low</code> and <code>self.high</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int, None, Optional</code></dt>
<dd>How many samples the pull</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample(self, size=None):
    &#39;&#39;&#39;Sample the distirbution given `self.low` and `self.high`

    Parameters
    ----------
    size : int, None, Optional
        How many samples the pull

    Returns
    -------
    float
    &#39;&#39;&#39;
    self.value = random.uniform.sample(
        low=self._low.value, 
        high=self._high.value,
        size=size)
    return self.value</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.var"><code class="name flex">
<span>def <span class="ident">var</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var(self):
    return (1/12)*(self._high.value - self._low.value)**2</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Uniform.variance"><code class="name flex">
<span>def <span class="ident">variance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variance(self):
    return self.var()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.pylab.variables.Variable"><code class="flex name class">
<span>class <span class="ident">Variable</span></span>
<span>(</span><span>value=None, dtype=None, shape=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar values that can change over time and be traced</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int, float, None</code></dt>
<dd>This is the value of the scalar</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>Type</code></dt>
<dd>This is the type of the variable</dd>
</dl>
<p>kwargs :dict
These are the extra parameters for the Node class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Variable(Node, _BaseArithmeticClass, Traceable):
    &#39;&#39;&#39;Scalar values that can change over time and be traced

    Parameters
    ----------
    value : int, float, None
        This is the value of the scalar
    dtype : Type
        This is the type of the variable
    kwargs :dict
        These are the extra parameters for the Node class
    &#39;&#39;&#39;
    def __init__(self, value=None, dtype=None, shape=None, **kwargs):
        Node.__init__(self, **kwargs)
        if dtype is None:
            dtype = DEFAULT_VARIABLE_TYPE
        if not istype(dtype):
            raise TypeError(&#39;`dtype` ({}) must be a type object&#39;.format(type(dtype)))
        if shape is not None:
            if not istuple(shape):
                raise TypeError(&#39;`shape` ({}) must be a tuple or None&#39;)
        self.dtype = dtype
        self.value = value
        self._shape = shape
        self._init_value = None

    def __len__(self):
        if self._shape is None:
            raise ValueError(&#39;`No length for scalar`&#39;)
        return self._shape[0]

    def set_trace(self):
        &#39;&#39;&#39;Initialize the trace arrays for the variable in the Tracer object. 

        It will initialize a buffer the size of the checkpoint size in Tracer
        &#39;&#39;&#39;
        if self.G.inference.tracer_filename is not None:
            self.G.tracer.set_trace(self.name, shape=self._shape, dtype=self.dtype)
            ckpt = self.G.tracer.ckpt
        else:
            ckpt = self.G.inference.n_samples + self.G.inference.burnin
        
        self.ckpt_iter = 0
        self.sample_iter = 0
        shape = (ckpt, )
        if self._shape is not None:
            shape += self._shape
        self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)

    def remove_local_trace(self):
        &#39;&#39;&#39;Destroy the local trace of the object
        &#39;&#39;&#39;
        self.trace = None

    def add_trace(self):
        &#39;&#39;&#39;Adds the current value to the trace. If the buffer is full
        it will end it to disk
        &#39;&#39;&#39;
        try:
            self.trace[self.ckpt_iter] = self.value
        except:
            logging.critical(&#39;{} - trace shape ({}), value shape ({})&#39;.format(
                self.name, self.trace[self.ckpt_iter].shape, self.value.shape))
            raise
        self.ckpt_iter += 1
        self.sample_iter += 1
        if self.ckpt_iter == len(self.trace):
            if self.G.inference.ckpt is None:
                # No writing to disk
                return
            # We have gotten the largest we can in the local buffer, write to disk
            self.G.tracer.write_to_disk(name=self.name)
            shape = (self.G.tracer.ckpt, )
            if self._shape is not None:
                shape += self._shape
            self.trace = np.full(shape=shape, fill_value=np.nan, dtype=self.dtype)
            self.ckpt_iter = 0

        if self.ckpt_iter &gt; len(self.trace):
            raise ValueError(&#39;Iteration {} too long for RAM trace {}&#39;.format(self.ckpt_iter, 
                len(self.trace)))

    def set_value_shape(self, shape):
        &#39;&#39;&#39;Set the shape
        
        Parameters
        ----------
        shape : tuple
        &#39;&#39;&#39;
        if not istuple(shape):
            raise TypeError(&#39;`shape` ({}) must be a tuple&#39;.format(type(shape)))
        self._shape = shape

    @property
    def T(self):
        &#39;&#39;&#39;Transpose
        &#39;&#39;&#39;
        return self.value.T</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mdsine2.negbin.TrajectorySet" href="../negbin.html#mdsine2.negbin.TrajectorySet">TrajectorySet</a></li>
<li><a title="mdsine2.posterior.ClusterInteractionIndicators" href="../posterior.html#mdsine2.posterior.ClusterInteractionIndicators">ClusterInteractionIndicators</a></li>
<li><a title="mdsine2.posterior.PriorMeanPerturbations" href="../posterior.html#mdsine2.posterior.PriorMeanPerturbations">PriorMeanPerturbations</a></li>
<li><a title="mdsine2.posterior.PriorVarPerturbations" href="../posterior.html#mdsine2.posterior.PriorVarPerturbations">PriorVarPerturbations</a></li>
<li>mdsine2.posterior._qPCRBase</li>
<li><a title="mdsine2.pylab.contrib.ClusterPerturbation" href="contrib.html#mdsine2.pylab.contrib.ClusterPerturbation">ClusterPerturbation</a></li>
<li><a title="mdsine2.pylab.contrib.Perturbation" href="contrib.html#mdsine2.pylab.contrib.Perturbation">Perturbation</a></li>
<li><a title="mdsine2.pylab.variables.Bernoulli" href="#mdsine2.pylab.variables.Bernoulli">Bernoulli</a></li>
<li><a title="mdsine2.pylab.variables.Beta" href="#mdsine2.pylab.variables.Beta">Beta</a></li>
<li><a title="mdsine2.pylab.variables.Gamma" href="#mdsine2.pylab.variables.Gamma">Gamma</a></li>
<li><a title="mdsine2.pylab.variables.InvGamma" href="#mdsine2.pylab.variables.InvGamma">InvGamma</a></li>
<li><a title="mdsine2.pylab.variables.Lognormal" href="#mdsine2.pylab.variables.Lognormal">Lognormal</a></li>
<li><a title="mdsine2.pylab.variables.MVN" href="#mdsine2.pylab.variables.MVN">MVN</a></li>
<li><a title="mdsine2.pylab.variables.NegativeBinomial" href="#mdsine2.pylab.variables.NegativeBinomial">NegativeBinomial</a></li>
<li><a title="mdsine2.pylab.variables.Normal" href="#mdsine2.pylab.variables.Normal">Normal</a></li>
<li><a title="mdsine2.pylab.variables.SICS" href="#mdsine2.pylab.variables.SICS">SICS</a></li>
<li><a title="mdsine2.pylab.variables.TruncatedNormal" href="#mdsine2.pylab.variables.TruncatedNormal">TruncatedNormal</a></li>
<li><a title="mdsine2.pylab.variables.Uniform" href="#mdsine2.pylab.variables.Uniform">Uniform</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.pylab.variables.Variable.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"><p>Transpose</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def T(self):
    &#39;&#39;&#39;Transpose
    &#39;&#39;&#39;
    return self.value.T</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.pylab.variables.Variable.remove_local_trace"><code class="name flex">
<span>def <span class="ident">remove_local_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy the local trace of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_local_trace(self):
    &#39;&#39;&#39;Destroy the local trace of the object
    &#39;&#39;&#39;
    self.trace = None</code></pre>
</details>
</dd>
<dt id="mdsine2.pylab.variables.Variable.set_value_shape"><code class="name flex">
<span>def <span class="ident">set_value_shape</span></span>(<span>self, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the shape</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_value_shape(self, shape):
    &#39;&#39;&#39;Set the shape
    
    Parameters
    ----------
    shape : tuple
    &#39;&#39;&#39;
    if not istuple(shape):
        raise TypeError(&#39;`shape` ({}) must be a tuple&#39;.format(type(shape)))
    self._shape = shape</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.graph.Node" href="graph.html#mdsine2.pylab.graph.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.graph.Node.add_child" href="graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_parent" href="graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_prior" href="graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_undirected" href="graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.degree" href="graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.delete" href="graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.get_adjacent_keys" href="graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.load" href="base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.metropolis" href="graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.save" href="base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.set_save_location" href="base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.Traceable.add_trace" href="base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.set_trace" href="base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
</ul>
</li>
<li><code><b><a title="mdsine2.pylab.base.Traceable" href="base.html#mdsine2.pylab.base.Traceable">Traceable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.base.Traceable.get_iter" href="base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.get_trace_from_disk" href="base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk" href="base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tracing">Tracing</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2.pylab" href="index.html">mdsine2.pylab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdsine2.pylab.variables.isRandomVariable" href="#mdsine2.pylab.variables.isRandomVariable">isRandomVariable</a></code></li>
<li><code><a title="mdsine2.pylab.variables.isVariable" href="#mdsine2.pylab.variables.isVariable">isVariable</a></code></li>
<li><code><a title="mdsine2.pylab.variables.summary" href="#mdsine2.pylab.variables.summary">summary</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdsine2.pylab.variables.Bernoulli" href="#mdsine2.pylab.variables.Bernoulli">Bernoulli</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.variables.Bernoulli.mean" href="#mdsine2.pylab.variables.Bernoulli.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Bernoulli.mode" href="#mdsine2.pylab.variables.Bernoulli.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Bernoulli.p" href="#mdsine2.pylab.variables.Bernoulli.p">p</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Bernoulli.sample" href="#mdsine2.pylab.variables.Bernoulli.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Bernoulli.variance" href="#mdsine2.pylab.variables.Bernoulli.variance">variance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.Beta" href="#mdsine2.pylab.variables.Beta">Beta</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.variables.Beta.a" href="#mdsine2.pylab.variables.Beta.a">a</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Beta.b" href="#mdsine2.pylab.variables.Beta.b">b</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Beta.mean" href="#mdsine2.pylab.variables.Beta.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Beta.sample" href="#mdsine2.pylab.variables.Beta.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Beta.variance" href="#mdsine2.pylab.variables.Beta.variance">variance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.Constant" href="#mdsine2.pylab.variables.Constant">Constant</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.variables.Constant.override_value" href="#mdsine2.pylab.variables.Constant.override_value">override_value</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Constant.value" href="#mdsine2.pylab.variables.Constant.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.Gamma" href="#mdsine2.pylab.variables.Gamma">Gamma</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.Gamma.mean" href="#mdsine2.pylab.variables.Gamma.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Gamma.pdf" href="#mdsine2.pylab.variables.Gamma.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Gamma.sample" href="#mdsine2.pylab.variables.Gamma.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Gamma.scale" href="#mdsine2.pylab.variables.Gamma.scale">scale</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Gamma.shape" href="#mdsine2.pylab.variables.Gamma.shape">shape</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Gamma.variance" href="#mdsine2.pylab.variables.Gamma.variance">variance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.InvGamma" href="#mdsine2.pylab.variables.InvGamma">InvGamma</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.InvGamma.logpdf" href="#mdsine2.pylab.variables.InvGamma.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.InvGamma.mean" href="#mdsine2.pylab.variables.InvGamma.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.InvGamma.mode" href="#mdsine2.pylab.variables.InvGamma.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.InvGamma.pdf" href="#mdsine2.pylab.variables.InvGamma.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.InvGamma.sample" href="#mdsine2.pylab.variables.InvGamma.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.InvGamma.scale" href="#mdsine2.pylab.variables.InvGamma.scale">scale</a></code></li>
<li><code><a title="mdsine2.pylab.variables.InvGamma.shape" href="#mdsine2.pylab.variables.InvGamma.shape">shape</a></code></li>
<li><code><a title="mdsine2.pylab.variables.InvGamma.variance" href="#mdsine2.pylab.variables.InvGamma.variance">variance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.Lognormal" href="#mdsine2.pylab.variables.Lognormal">Lognormal</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.Lognormal.cdf" href="#mdsine2.pylab.variables.Lognormal.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Lognormal.logcdf" href="#mdsine2.pylab.variables.Lognormal.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Lognormal.logpdf" href="#mdsine2.pylab.variables.Lognormal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Lognormal.mean" href="#mdsine2.pylab.variables.Lognormal.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Lognormal.mode" href="#mdsine2.pylab.variables.Lognormal.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Lognormal.pdf" href="#mdsine2.pylab.variables.Lognormal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Lognormal.sample" href="#mdsine2.pylab.variables.Lognormal.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Lognormal.std" href="#mdsine2.pylab.variables.Lognormal.std">std</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.MVN" href="#mdsine2.pylab.variables.MVN">MVN</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.variables.MVN.cov" href="#mdsine2.pylab.variables.MVN.cov">cov</a></code></li>
<li><code><a title="mdsine2.pylab.variables.MVN.mean" href="#mdsine2.pylab.variables.MVN.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.MVN.mode" href="#mdsine2.pylab.variables.MVN.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.MVN.prec" href="#mdsine2.pylab.variables.MVN.prec">prec</a></code></li>
<li><code><a title="mdsine2.pylab.variables.MVN.sample" href="#mdsine2.pylab.variables.MVN.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.NegativeBinomial" href="#mdsine2.pylab.variables.NegativeBinomial">NegativeBinomial</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.NegativeBinomial.mean" href="#mdsine2.pylab.variables.NegativeBinomial.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.NegativeBinomial.mode" href="#mdsine2.pylab.variables.NegativeBinomial.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.NegativeBinomial.n" href="#mdsine2.pylab.variables.NegativeBinomial.n">n</a></code></li>
<li><code><a title="mdsine2.pylab.variables.NegativeBinomial.p" href="#mdsine2.pylab.variables.NegativeBinomial.p">p</a></code></li>
<li><code><a title="mdsine2.pylab.variables.NegativeBinomial.sample" href="#mdsine2.pylab.variables.NegativeBinomial.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.NegativeBinomial.variance" href="#mdsine2.pylab.variables.NegativeBinomial.variance">variance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.Normal" href="#mdsine2.pylab.variables.Normal">Normal</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.Normal.cdf" href="#mdsine2.pylab.variables.Normal.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.logcdf" href="#mdsine2.pylab.variables.Normal.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.logpdf" href="#mdsine2.pylab.variables.Normal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.mean" href="#mdsine2.pylab.variables.Normal.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.mode" href="#mdsine2.pylab.variables.Normal.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.pdf" href="#mdsine2.pylab.variables.Normal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.sample" href="#mdsine2.pylab.variables.Normal.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.std" href="#mdsine2.pylab.variables.Normal.std">std</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.var" href="#mdsine2.pylab.variables.Normal.var">var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.SICS" href="#mdsine2.pylab.variables.SICS">SICS</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.SICS.dof" href="#mdsine2.pylab.variables.SICS.dof">dof</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.logpdf" href="#mdsine2.pylab.variables.SICS.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.mean" href="#mdsine2.pylab.variables.SICS.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.mode" href="#mdsine2.pylab.variables.SICS.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.pdf" href="#mdsine2.pylab.variables.SICS.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.sample" href="#mdsine2.pylab.variables.SICS.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.scale" href="#mdsine2.pylab.variables.SICS.scale">scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.TruncatedNormal" href="#mdsine2.pylab.variables.TruncatedNormal">TruncatedNormal</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.cdf" href="#mdsine2.pylab.variables.TruncatedNormal.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.logcdf" href="#mdsine2.pylab.variables.TruncatedNormal.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.logpdf" href="#mdsine2.pylab.variables.TruncatedNormal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.mean" href="#mdsine2.pylab.variables.TruncatedNormal.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.mode" href="#mdsine2.pylab.variables.TruncatedNormal.mode">mode</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.pdf" href="#mdsine2.pylab.variables.TruncatedNormal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.sample" href="#mdsine2.pylab.variables.TruncatedNormal.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.std" href="#mdsine2.pylab.variables.TruncatedNormal.std">std</a></code></li>
<li><code><a title="mdsine2.pylab.variables.TruncatedNormal.var" href="#mdsine2.pylab.variables.TruncatedNormal.var">var</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.Uniform" href="#mdsine2.pylab.variables.Uniform">Uniform</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.pylab.variables.Uniform.cdf" href="#mdsine2.pylab.variables.Uniform.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.high" href="#mdsine2.pylab.variables.Uniform.high">high</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.logcdf" href="#mdsine2.pylab.variables.Uniform.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.logpdf" href="#mdsine2.pylab.variables.Uniform.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.low" href="#mdsine2.pylab.variables.Uniform.low">low</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.mean" href="#mdsine2.pylab.variables.Uniform.mean">mean</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.median" href="#mdsine2.pylab.variables.Uniform.median">median</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.pdf" href="#mdsine2.pylab.variables.Uniform.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.sample" href="#mdsine2.pylab.variables.Uniform.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.var" href="#mdsine2.pylab.variables.Uniform.var">var</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Uniform.variance" href="#mdsine2.pylab.variables.Uniform.variance">variance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.pylab.variables.Variable" href="#mdsine2.pylab.variables.Variable">Variable</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.remove_local_trace" href="#mdsine2.pylab.variables.Variable.remove_local_trace">remove_local_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>