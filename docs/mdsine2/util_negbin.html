<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.util_negbin API documentation</title>
<meta name="description" content="Stores the classes and functions used in the `main_negbin` module that
is used to learn the negative binomial dispersion parameters offline." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.util_negbin</code></h1>
</header>
<section id="section-intro">
<p>Stores the classes and functions used in the <code>main_negbin</code> module that
is used to learn the negative binomial dispersion parameters offline.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Stores the classes and functions used in the `main_negbin` module that
is used to learn the negative binomial dispersion parameters offline.
&#39;&#39;&#39;
import numpy as np
import logging
import sys
import time
import pandas as pd
import os
import os.path
import argparse

import numpy.random as npr
import random
import math
import numba

import matplotlib.pyplot as plt
import seaborn as sns

from . import pylab as pl
from . import config
from .names import REPRNAMES, STRNAMES


def build_synthetic_subjset(params):
    &#39;&#39;&#39;Build the `pylab.base.Study` object used to store the data
    for synthetic learning of the negative binomial dispersion parameters

    Parameters
    ----------
    params : config.NegBinConfig
        Parameters to construct the object

    Returns
    -------
    pylab.base.Study, pylab.base.Study
        First one is the one that we learn from with added noise, second one
        is the ground truth
    &#39;&#39;&#39;
    if type(params) != config.NegBinConfig:
        raise TypeError(&#39;`params` ({}) not recognized&#39;.format(type(params)))

    reads = pd.read_csv(params.RAW_COUNTS_FILENAME, sep=&#39;\t&#39;, header=0)
    reads = reads.set_index(&#39;otuName&#39;)

    # Make the subjset object
    subjset_main_inference = pl.base.Study.load(params.MAIN_INFERENCE_SUBJSET_FILENAME)
    subjset = pl.base.Study(asvs=subjset_main_inference.asvs)

    # Ground truth object
    subjset_true = pl.base.Study(asvs=subjset_main_inference.asvs)

    days = params.SYNTHETIC_DAYS
    # Sample around each of the days using the specified amount of noise (a0 and a1)
    for day in days:
        logging.info(&#39;day {} in {}&#39;.format(day, days))
        col = &#39;M2-D{}-1A&#39;.format(day)
        d = reads[col].to_numpy()

        # Make a small offset so there are no math errors
        means = d + 1e-100
        rels = means/np.sum(means)
        dispersions = params.SYNTHETIC_A0 / rels + params.SYNTHETIC_A1
        counts = []

        for _ in range(params.SYNTHETIC_N_REPLICATES):
            temp = np.asarray([pl.random.negative_binomial.sample(means[i], dispersions[i]) for \
                    i in range(d.shape[0])])
            counts.append(temp.reshape(-1,1))
        counts = np.hstack(counts)

        # Get qPCR
        qpcr = subjset_main_inference[&#39;2&#39;].qpcr[day]
        subjset = _build_subject_single_qPCR(subjectset=subjset, counts=counts, 
            qpcr_measurement=qpcr)
        subjset_true = _build_subject_single_qPCR(subjectset=subjset_true, 
            counts=d.reshape(-1,1), qpcr_measurement=qpcr)

    return subjset, subjset_true

def build_real_subjset(params):
    &#39;&#39;&#39;Build the `pylab.base.Study` object used to store the data
    for learning real data of the negative binomial dispersion parameters.

    Parameters
    ----------
    params : config.NegBinConfig
        Parameters to construct the object

    Returns
    -------
    pylab.base.Study
    &#39;&#39;&#39;
    if type(params) != config.NegBinConfig:
        raise TypeError(&#39;`params` ({}) not recognized&#39;.format(type(params)))

    reads = pd.read_csv(params.RAW_COUNTS_FILENAME, sep=&#39;\t&#39;, header=0)
    reads = reads.set_index(&#39;otuName&#39;)

    # Make the subjset object
    subjset_main_inference = pl.base.Study.load(params.MAIN_INFERENCE_SUBJSET_FILENAME)
    subjset = pl.base.Study(asvs=subjset_main_inference.asvs)

    for day, data_cols in params.REPLICATE_DATA_COLS:
        counts = reads[data_cols].to_numpy()
        qpcr = subjset_main_inference[&#39;2&#39;].qpcr[day]
        subjset = _build_subject_single_qPCR(subjectset=subjset, counts=counts, 
            qpcr_measurement=qpcr)

    return subjset

def _build_subject_single_qPCR(subjectset, counts, qpcr_measurement, name=None):
    &#39;&#39;&#39;Build a `pylab.base.Subject` object using the counts and qPCR measurement
    and adds it to the `pylab.base.Study` object `subjset`.
    
    This is a special case because we have no time. We assume that the counts are 
    all replicates of the same measurement at time t. And thus we only have one
    qPCR measurement.

    Parameters
    ----------
    subjectset : pylab.base.Study
        This is the subject set we are adding the subject to
    counts : np.ndarray (n_asvs x n_replicates) dtype int
        counts[i,k] = Number of counts for ith ASV and kth replicate.
        If it is a single replicate it must be a column vector.
    qPCR_measurement : pl.base.qPCRdata
        A single qPCR measurement
    name : str, None
        This is the name of the subject to add. If None it will be the string of
        the replicate index
    
    Returns
    -------
    pylab.base.Study
    &#39;&#39;&#39;
    if not pl.isstudy(subjectset):
        raise TypeError(&#39;`subjectset` ({}) must be a pylab.base.Study&#39;.format(
            type(subjectset)))
    if not pl.isarray(counts):
        raise TypeError(&#39;`counts` ({}) must be an array&#39;.format(type(counts)))
    counts = np.array(counts, dtype=int)
    if np.any(counts &lt; 0):
        raise ValueError(&#39;All values in `counts` must be positive&#39;)
    if len(counts.shape) != 2:
        raise ValueError(&#39;Shape of `counts` must be 2 ({})&#39;.format(len(counts.shape)))
    if counts.shape[0] != len(subjectset.asvs):
        raise ValueError(&#39;First dimension of `counts` ({}) must be the same as the &#39; \
            &#39;number of ASVs in `subjectset` ({})&#39;.format(counts.shape[0], len(subjectset.asvs)))
    if not pl.isqpcrdata(qpcr_measurement):
        raise TypeError(&#39;`qpcr_measurement` ({}) must be a pylab.base.qPCRdata object&#39;.format(
            type(qpcr_measurement)))
    if name is None:
        name = str(len(subjectset))
    elif not pl.isstr(name):
        raise TypeError(&#39;`name` ({}) must be None or a str&#39;.format(type(name)))
    
    subjectset.add(name=name)
    subj = subjectset[name]
    subj.times = np.arange(counts.shape[1])
    for t in subj.times:
        subj.qpcr[t] = qpcr_measurement
        subj.reads[t] = counts[:,t]

    return subjectset

def filter_out_zero_asvs(subjset):
    &#39;&#39;&#39;Filter out asvs that have only 0 counts

    Parameters
    ----------
    subjset : pl.base.Study
        Contains the data

    Returns
    -------
    pylab.base.Study
    &#39;&#39;&#39;
    if not pl.isstudy(subjset):
        raise TypeError(&#39;`subjset` ({}) must be a pylab.base.Study object&#39;.format(
            type(subjset)))

    vs = []
    for subj in subjset:
        vs.append(subj.matrix()[&#39;raw&#39;])

    M = np.hstack(vs)

    aidxs_to_remove = []
    for aidx in range(M.shape[0]):
        if np.all(M[aidx, :] == 0):
            aidxs_to_remove.append(aidx)
    
    anames = subjset.asvs.names.order[aidxs_to_remove]

    logging.info(&#39;Deleting {} asvs because they have 0 counts in all samples&#39;.format(len(anames)))

    subjset.pop_asvs(anames)
    return subjset</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mdsine2.util_negbin.build_real_subjset"><code class="name flex">
<span>def <span class="ident">build_real_subjset</span></span>(<span>params)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the <code>pylab.base.Study</code> object used to store the data
for learning real data of the negative binomial dispersion parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>config.NegBinConfig</code></dt>
<dd>Parameters to construct the object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pylab.base.Study</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_real_subjset(params):
    &#39;&#39;&#39;Build the `pylab.base.Study` object used to store the data
    for learning real data of the negative binomial dispersion parameters.

    Parameters
    ----------
    params : config.NegBinConfig
        Parameters to construct the object

    Returns
    -------
    pylab.base.Study
    &#39;&#39;&#39;
    if type(params) != config.NegBinConfig:
        raise TypeError(&#39;`params` ({}) not recognized&#39;.format(type(params)))

    reads = pd.read_csv(params.RAW_COUNTS_FILENAME, sep=&#39;\t&#39;, header=0)
    reads = reads.set_index(&#39;otuName&#39;)

    # Make the subjset object
    subjset_main_inference = pl.base.Study.load(params.MAIN_INFERENCE_SUBJSET_FILENAME)
    subjset = pl.base.Study(asvs=subjset_main_inference.asvs)

    for day, data_cols in params.REPLICATE_DATA_COLS:
        counts = reads[data_cols].to_numpy()
        qpcr = subjset_main_inference[&#39;2&#39;].qpcr[day]
        subjset = _build_subject_single_qPCR(subjectset=subjset, counts=counts, 
            qpcr_measurement=qpcr)

    return subjset</code></pre>
</details>
</dd>
<dt id="mdsine2.util_negbin.build_synthetic_subjset"><code class="name flex">
<span>def <span class="ident">build_synthetic_subjset</span></span>(<span>params)</span>
</code></dt>
<dd>
<div class="desc"><p>Build the <code>pylab.base.Study</code> object used to store the data
for synthetic learning of the negative binomial dispersion parameters</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>config.NegBinConfig</code></dt>
<dd>Parameters to construct the object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pylab.base.Study, pylab.base.Study</code></dt>
<dd>First one is the one that we learn from with added noise, second one
is the ground truth</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_synthetic_subjset(params):
    &#39;&#39;&#39;Build the `pylab.base.Study` object used to store the data
    for synthetic learning of the negative binomial dispersion parameters

    Parameters
    ----------
    params : config.NegBinConfig
        Parameters to construct the object

    Returns
    -------
    pylab.base.Study, pylab.base.Study
        First one is the one that we learn from with added noise, second one
        is the ground truth
    &#39;&#39;&#39;
    if type(params) != config.NegBinConfig:
        raise TypeError(&#39;`params` ({}) not recognized&#39;.format(type(params)))

    reads = pd.read_csv(params.RAW_COUNTS_FILENAME, sep=&#39;\t&#39;, header=0)
    reads = reads.set_index(&#39;otuName&#39;)

    # Make the subjset object
    subjset_main_inference = pl.base.Study.load(params.MAIN_INFERENCE_SUBJSET_FILENAME)
    subjset = pl.base.Study(asvs=subjset_main_inference.asvs)

    # Ground truth object
    subjset_true = pl.base.Study(asvs=subjset_main_inference.asvs)

    days = params.SYNTHETIC_DAYS
    # Sample around each of the days using the specified amount of noise (a0 and a1)
    for day in days:
        logging.info(&#39;day {} in {}&#39;.format(day, days))
        col = &#39;M2-D{}-1A&#39;.format(day)
        d = reads[col].to_numpy()

        # Make a small offset so there are no math errors
        means = d + 1e-100
        rels = means/np.sum(means)
        dispersions = params.SYNTHETIC_A0 / rels + params.SYNTHETIC_A1
        counts = []

        for _ in range(params.SYNTHETIC_N_REPLICATES):
            temp = np.asarray([pl.random.negative_binomial.sample(means[i], dispersions[i]) for \
                    i in range(d.shape[0])])
            counts.append(temp.reshape(-1,1))
        counts = np.hstack(counts)

        # Get qPCR
        qpcr = subjset_main_inference[&#39;2&#39;].qpcr[day]
        subjset = _build_subject_single_qPCR(subjectset=subjset, counts=counts, 
            qpcr_measurement=qpcr)
        subjset_true = _build_subject_single_qPCR(subjectset=subjset_true, 
            counts=d.reshape(-1,1), qpcr_measurement=qpcr)

    return subjset, subjset_true</code></pre>
</details>
</dd>
<dt id="mdsine2.util_negbin.filter_out_zero_asvs"><code class="name flex">
<span>def <span class="ident">filter_out_zero_asvs</span></span>(<span>subjset)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter out asvs that have only 0 counts</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>subjset</code></strong> :&ensp;<code>pl.base.Study</code></dt>
<dd>Contains the data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pylab.base.Study</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_out_zero_asvs(subjset):
    &#39;&#39;&#39;Filter out asvs that have only 0 counts

    Parameters
    ----------
    subjset : pl.base.Study
        Contains the data

    Returns
    -------
    pylab.base.Study
    &#39;&#39;&#39;
    if not pl.isstudy(subjset):
        raise TypeError(&#39;`subjset` ({}) must be a pylab.base.Study object&#39;.format(
            type(subjset)))

    vs = []
    for subj in subjset:
        vs.append(subj.matrix()[&#39;raw&#39;])

    M = np.hstack(vs)

    aidxs_to_remove = []
    for aidx in range(M.shape[0]):
        if np.all(M[aidx, :] == 0):
            aidxs_to_remove.append(aidx)
    
    anames = subjset.asvs.names.order[aidxs_to_remove]

    logging.info(&#39;Deleting {} asvs because they have 0 counts in all samples&#39;.format(len(anames)))

    subjset.pop_asvs(anames)
    return subjset</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2" href="index.html">mdsine2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mdsine2.util_negbin.build_real_subjset" href="#mdsine2.util_negbin.build_real_subjset">build_real_subjset</a></code></li>
<li><code><a title="mdsine2.util_negbin.build_synthetic_subjset" href="#mdsine2.util_negbin.build_synthetic_subjset">build_synthetic_subjset</a></code></li>
<li><code><a title="mdsine2.util_negbin.filter_out_zero_asvs" href="#mdsine2.util_negbin.filter_out_zero_asvs">filter_out_zero_asvs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>