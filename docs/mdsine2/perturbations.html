<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mdsine2.perturbations API documentation</title>
<meta name="description" content="Perturbation parameters for the posterior" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdsine2.perturbations</code></h1>
</header>
<section id="section-intro">
<p>Perturbation parameters for the posterior</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Perturbation parameters for the posterior
&#39;&#39;&#39;
import logging
import time
import itertools
import numpy as np
import numpy.random as npr

from .util import expected_n_clusters, build_prior_covariance, build_prior_mean, \
    sample_categorical_log, log_det, pinv
from .names import STRNAMES, STRNAMES

from . import pylab as pl

class PerturbationMagnitudes(pl.variables.Normal):
    &#39;&#39;&#39;These update the perturbation values jointly.
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        &#39;&#39;&#39;Parameters
        &#39;&#39;&#39;

        kwargs[&#39;name&#39;] = STRNAMES.PERT_VALUE
        pl.variables.Normal.__init__(self, mean=None, var=None, dtype=float, **kwargs)
        self.perturbations = self.G.perturbations

    def __str__(self):
        s = &#39;Perturbation Magnitudes (multiplicative)&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\t perturbation {}: {}&#39;.format(
                perturbation.name, perturbation.cluster_array(only_pos_ind=True))
        return s

    def __len__(self):
        &#39;&#39;&#39;Return the number of on indicators
        &#39;&#39;&#39;
        n = 0
        for perturbation in self.perturbations:
            n += perturbation.indicator.num_on_clusters()
        return n

    def set_values(self, arr, use_indicators=True):
        &#39;&#39;&#39;Set the values of the perturbation of them stacked one on top of each other

        Parameters
        ----------
        arr : np.ndarray
            Values for all of the perturbations in order
        use_indicators : bool
            If True, the values only refer to the on indicators
        &#39;&#39;&#39;
        i = 0
        for perturbation in self.perturbations:
            l = perturbation.indicator.num_on_clusters()
            perturbation.set_values_from_array(values=arr[i:i+l],
                use_indicators=use_indicators)
            i += l

    def update_str(self):
        return

    @property
    def sample_iter(self):
        return self.perturbations[0].sample_iter

    def initialize(self, value_option, value=None, mean=None, var=None, delay=0):
        &#39;&#39;&#39;Initialize the prior and the value of the perturbation. We assume that
        each perturbation has the same hyperparameters for the prior

        Parameters
        ----------
        value_option : str
            How to initialize the values. Options:
                &#39;manual&#39;
                    Set the value manually, `value` must also be specified
                &#39;zero&#39;
                    Set all the values to zero.
                &#39;auto&#39;, &#39;prior-mean&#39;
                    Initialize to the same value as the prior mean
        delay : int, None
            How many MCMC iterations to delay the update of the values.
        mean, var, value : int, float, array
            - Only necessary if any of the options are &#39;manual&#39;
        &#39;&#39;&#39;
        if delay is None:
            delay = 0
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay
        for perturbation in self.perturbations:
            perturbation.magnitude.set_signal_when_clusters_change(True)

        # Set the value of the perturbations
        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            for pidx, perturbation in enumerate(self.perturbations):
                v = value[pidx]
                for cidx, val in enumerate(v):
                    cid = perturbation.clustering.order[cidx]
                    perturbation.indicator.value[cid] = not np.isnan(val)
                    perturbation.magnitude.value[cid] = val if not np.isnan(val) else 0

        elif value_option == &#39;zero&#39;:
            for perturbation in self.perturbations:
                for cid in perturbation.clustering.order:
                    perturbation.magnitude.value[cid] = 0
        elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
            for perturbation in self.perturbations:
                mean = perturbation.magnitude.prior.mean.value
                for cid in perturbation.clustering.order:
                    perturbation.magnitude.value[cid] = mean
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))


        s = &#39;Perturbation magnitude initialization results:\n&#39;
        for perturbation in self.perturbations:
            if perturbation.name is not None:
                a = perturbation.name
            s += &#39;\tPerturbation {}:\n&#39; \
                &#39;\t\tvalue: {}\n&#39;.format(a, perturbation.magnitude.cluster_array())
        logging.info(s)

    def update(self):
        &#39;&#39;&#39;Update with a gibbs step jointly
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return

        n_on = [perturbation.indicator.num_on_clusters() for perturbation in \
            self.perturbations]
        
        if n_on == 0:
            return

        rhs = [STRNAMES.PERT_VALUE]
        lhs = [
            STRNAMES.GROWTH_VALUE,
            STRNAMES.SELF_INTERACTION_VALUE,
            STRNAMES.CLUSTER_INTERACTION_VALUE]
        X = self.G.data.construct_rhs(keys=rhs, toarray=True)
        y = self.G.data.construct_lhs(keys=lhs,
            kwargs_dict={STRNAMES.GROWTH_VALUE:{
                &#39;with_perturbations&#39;:False}})

        process_prec = self.G[STRNAMES.PROCESSVAR].prec
        prior_prec = build_prior_covariance(G=self.G, cov=False, order=rhs, sparse=False)

        prior_mean = build_prior_mean(G=self.G, order=rhs).reshape(-1,1)

        a = X.T * process_prec
        prec = a @ X + prior_prec
        cov = pinv(prec, self)
        mean = np.asarray(cov @ (a @ y + prior_prec @ prior_mean)).ravel()

        # print(&#39;\n\ny\n&#39;,np.hstack((y, self.G.data.lhs.vector.reshape(-1,1))))
        # print(self.G[STRNAMES.CLUSTER_INTERACTION_VALUE].value)
        # print(self.G[STRNAMES.GROWTH_VALUE].value)
        # print(self.G[STRNAMES.SELF_INTERACTION_VALUE].value)

        self.mean.value = mean
        self.var.value = np.diag(cov)
        value = self.sample()

        if np.any(np.isnan(value)):
            logging.critical(&#39;mean: {}&#39;.format(self.mean.value))
            logging.critical(&#39;var: {}&#39;.format(self.var.value))
            logging.critical(&#39;value: {}&#39;.format(self.value))
            logging.critical(&#39;prior mean: {}&#39;.format(prior_mean.ravel()))
            raise ValueError(&#39;`Values in {} are nan: {}&#39;.format(self.name, self.value))

        i = 0
        for pidx, perturbation in enumerate(self.perturbations):
            perturbation.set_values_from_array(value[i:i+n_on[pidx]], use_indicators=True)
            i += n_on[pidx]

        # Rebuild the design matrix
        self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()

    def asarray(self):
        &#39;&#39;&#39;Get an array of the perturbation magnitudes
        &#39;&#39;&#39;
        a = []
        for perturbation in self.perturbations:
            a.append(perturbation.cluster_array(only_pos_ind=True))
        return np.asarray(list(itertools.chain.from_iterable(a)))

    def toarray(self):
        return self.asarray()


class PerturbationProbabilities(pl.Node):
    &#39;&#39;&#39;This is the probability for a positive interaction for a perturbation
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        &#39;&#39;&#39;Parameters

        prior (pl.variables.Beta)
            - prior probability
        pert_n (int)
            - This is the perturbation number that it corresponds to
        **kwargs
            - Other options like graph, value
        &#39;&#39;&#39;
        kwargs[&#39;name&#39;] = STRNAMES.PERT_INDICATOR_PROB
        pl.Node.__init__(self, **kwargs)
        self.perturbations = self.G.perturbations

    def __str__(self):
        s = &#39;Perturbation Indicator probabilities&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\tperturbation {}: {}&#39;.format(
                perturbation.name,
                perturbation.probability.value)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].probability.sample_iter

    def initialize(self, value_option, hyperparam_option, a=None, b=None, value=None,
        N=&#39;auto&#39;, delay=0):
        &#39;&#39;&#39;Initialize the hyperparameters of the prior and the value. Each
        perturbation has the same prior.

        Parameters
        ----------
        value_option : str
            How to initialize the values. Options:
                &#39;manual&#39;
                    Set the value manually, `value` must also be specified
                &#39;auto&#39;, &#39;prior-mean&#39;
                    Initialize the value as the prior mean
        hyperparam_option : str
            How to initialize `a` and `b`. Options:
                &#39;manual&#39;
                    Set the value manually. `a` and `b` must also be specified
                &#39;weak-agnostic&#39; or &#39;auto&#39;
                    a=b=0.5
                &#39;strong-dense&#39;
                    a = N, N are the expected number of clusters
                    b = 0.5
                &#39;strong-sparse&#39;
                    a = 0.5
                    b = N, N are the expected number of clusters
                &#39;very-strong-sparse&#39;
                    a = 0.5
                    b = N, N are the expected number of ASVs
        N : str, int
            This is the number of clusters to set the hyperparam options to 
            (if they are dependent on the number of cluster). If &#39;auto&#39;, set to the expected number
            of clusters from a dirichlet process. Else use this number (must be an int).
        delay : int
            How many MCMC iterations to delay starting the update of the variable
        value, a, b : int, float
            User specified values
            Only necessary if `hyperparam_option` == &#39;manual&#39;
        &#39;&#39;&#39;
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        # Set the hyper-parameters
        if not pl.isstr(hyperparam_option):
            raise ValueError(&#39;`hyperparam_option` ({}) must be a str&#39;.format(type(hyperparam_option)))
        if hyperparam_option == &#39;manual&#39;:
            if (not pl.isnumeric(a)) or (not pl.isnumeric(b)):
                raise TypeError(&#39;If `hyperparam_option` is &#34;manual&#34; then `a` ({})&#39; \
                    &#39; and `b` ({}) must be numerics&#39;.format(type(a), type(b)))
        elif hyperparam_option in [&#39;auto&#39;, &#39;weak-agnostic&#39;]:
            a = 0.5
            b = 0.5
        elif hyperparam_option == &#39;strong-dense&#39;:
            if pl.isstr(N):
                if N == &#39;auto&#39;:
                    N = expected_n_clusters(G=self.G)
                else:
                    raise ValueError(&#39;`N` ({}) nto recognized&#39;.format(N))
            elif pl.isint(N):
                if N &lt; 0:
                    raise ValueError(&#39;`N` ({}) must be positive&#39;.format(N))
            else:
                raise TypeError(&#39;`N` ({}) type not recognized&#39;.format(type(N)))
            a = N
            b = 0.5
        elif hyperparam_option == &#39;strong-sparse&#39;:
            if pl.isstr(N):
                if N == &#39;auto&#39;:
                    N = expected_n_clusters(G=self.G)
                else:
                    raise ValueError(&#39;`N` ({}) nto recognized&#39;.format(N))
            elif pl.isint(N):
                if N &lt; 0:
                    raise ValueError(&#39;`N` ({}) must be positive&#39;.format(N))
            else:
                raise TypeError(&#39;`N` ({}) type not recognized&#39;.format(type(N)))
            a = 0.5
            b = N
        elif hyperparam_option == &#39;very-strong-sparse&#39;:
            N = self.G.data.n_asvs
            a = 0.5
            b = N
        else:
            raise ValueError(&#39;`hyperparam_option` ({}) not recognized&#39;.format(hyperparam_option))
        for perturbation in self.perturbations:
            perturbation.probability.prior.a.override_value(a)
            perturbation.probability.prior.b.override_value(b)

        # Set the value
        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            if not pl.isnumeric(value):
                raise TypeError(&#39;If `value_option` is &#34;manual&#34; then `value` ({})&#39; \
                    &#39; must be a numeric&#39;.format(type(value)))
            for perturbation in self.perturbations:
                perturbation.probability.value = value
        elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
            for perturbation in self.perturbations:
                perturbation.probability.value = perturbation.probability.prior.mean()
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))

        s = &#39;Perturbation indicator probability initialization results:\n&#39;
        for i, perturbation in enumerate(self.perturbations):
            s += &#39;\tPerturbation {}:\n&#39; \
                &#39;\t\tprior a: {}\n&#39; \
                &#39;\t\tprior b: {}\n&#39; \
                &#39;\t\tvalue: {}\n&#39;.format(i,
                    perturbation.probability.prior.a.value,
                    perturbation.probability.prior.b.value,
                    perturbation.probability.value)
        logging.info(s)

    def update(self):
        &#39;&#39;&#39;Update according to how many positive and negative indicators there
        are
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return
        for perturbation in self.perturbations:
            num_pos = perturbation.indicator.num_on_clusters()
            num_neg = len(perturbation.clustering.clusters) - num_pos
            perturbation.probability.a.value = perturbation.probability.prior.a.value + num_pos
            perturbation.probability.b.value = perturbation.probability.prior.b.value + num_neg
            perturbation.probability.sample()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.probability.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.probability.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()


class PerturbationIndicators(pl.Node):
    &#39;&#39;&#39;This is the indicator for a perturbation

    We only need to trace once for the perturbations. Our default is to only
    trace from the magnitudes. Thus, we only trace the indicators (here) if
    we are learning here and not learning the magnitudes.
    &#39;&#39;&#39;
    def __init__(self, need_to_trace, relative, **kwargs):
        &#39;&#39;&#39;Parameters
        &#39;&#39;&#39;
        kwargs[&#39;name&#39;] = STRNAMES.PERT_INDICATOR
        pl.Node.__init__(self, **kwargs)
        self.need_to_trace = need_to_trace
        self.perturbations = self.G.perturbations
        self.clustering = None
        self._time_taken = None
        if relative:
            self.update = self.update_relative
        else:
            self.update = self.update_slow

    def __str__(self):
        s = &#39;Perturbation Indicators - time: {}s&#39;.format(self._time_taken)
        for perturbation in self.perturbations:
            arr = perturbation.indicator.cluster_bool_array()
            s += &#39;\nperturbation {} ({}/{}): {}&#39;.format(perturbation.name,
                np.sum(arr), len(arr), arr)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].sample_iter

    def add_trace(self):
        &#39;&#39;&#39;Only trace if perturbation indicators are being learned and the
        perturbation value is not being learned
        &#39;&#39;&#39;
        if self.need_to_trace:
            for perturbation in self.perturbations:
                perturbation.add_trace()

    def set_trace(self, *args, **kwargs):
        &#39;&#39;&#39;Only trace if perturbation indicators are being learned and the
        perturbation value is not being learned
        &#39;&#39;&#39;
        if self.need_to_trace:
            for perturbation in self.perturbations:
                perturbation.set_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        if self.need_to_trace:
            for perturbation in self.perturbations:
                perturbation.add_init_value()

    def initialize(self, value_option, p=None, delay=0):
        &#39;&#39;&#39;Initialize the based on the passed in option.

        Parameters
        ----------
        value_option (str)
            Different ways to initialize the values. Options:
                &#39;auto&#39;, &#39;all-off&#39;
                    Turn all of the indicators off
                &#39;all-on&#39;
                    Turn all the indicators on
                &#39;random&#39;
                    Randomly assign the indicator with probability `p`
        p : float
            Only required if `value_option` == &#39;random&#39;
        delay : int
            How many Gibbs steps to delay updating the values
        &#39;&#39;&#39;
        # print(&#39;in pert ind&#39;)
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        for perturbation in self.perturbations:
            perturbation.indicator.set_signal_when_clusters_change(True)
        self.clustering = self.G.perturbations[0].indicator.clustering

        # Set the value
        if not pl.isstr(value_option):
            raise ValueError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option in [&#39;all-off&#39;, &#39;auto&#39;]:
            value = False
        elif value_option == &#39;all-on&#39;:
            value = True
        elif value_option == &#39;random&#39;:
            if not pl.isfloat(p):
                raise TypeError(&#39;`p` ({}) must be a float&#39;.format(type(p)))
            if p &lt; 0 or p &gt; 1:
                raise ValueError(&#39;`p` ({}) must be [0,1]&#39;.format(p))
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))
        for perturbation in self.perturbations:
            for cid in perturbation.clustering.clusters:
                if value_option == &#39;random&#39;:
                    perturbation.indicator.value[cid] = bool(pl.random.bernoulli.sample(p))
                else:
                    perturbation.indicator.value[cid] = value

        # These are for the function `self._make_idx_for_clusters`
        self.ndts_bias = []
        self.n_replicates = self.G.data.n_replicates
        self.n_perturbations = len(self.G.perturbations)
        self.n_dts_for_replicate = self.G.data.n_dts_for_replicate
        self.total_dts = np.sum(self.n_dts_for_replicate)
        self.replicate_bias = np.zeros(self.n_replicates, dtype=int)
        self.n_asvs = len(self.G.data.asvs)
        for ridx in range(1, self.n_replicates):
            self.replicate_bias[ridx] = self.replicate_bias[ridx-1] + \
                self.n_asvs * self.n_dts_for_replicate[ridx - 1]
        for ridx in range(self.G.data.n_replicates):
            self.ndts_bias.append(
                np.arange(0, self.G.data.n_dts_for_replicate[ridx] * self.n_asvs, self.n_asvs))

        s = &#39;Perturbation indicator initialization results:\n&#39;
        for i, perturbation in enumerate(self.perturbations):
            s += &#39;\tPerturbation {}:\n&#39; \
                &#39;\t\tindicator: {}\n&#39;.format(i, perturbation.indicator.cluster_bool_array())
        logging.info(s)

    def _make_idx_for_clusters(self):
        &#39;&#39;&#39;Creates a dictionary that maps the cluster id to the
        rows that correspond to each ASV in the cluster.

        We cannot cast this with numba because it does not support Fortran style
        raveling :(.

        Returns
        -------
        dict: int -&gt; np.ndarray
            Maps the cluster ID to the row indices corresponding to it
        &#39;&#39;&#39;
        clusters = [np.asarray(oidxs, dtype=int).reshape(-1,1) \
            for oidxs in self.clustering.toarray()]
        n_dts=self.G.data.n_dts_for_replicate

        d = {}
        cids = self.clustering.order

        for cidx,cid in enumerate(cids):
            a = np.zeros(len(clusters[cidx]) * self.total_dts, dtype=int)
            i = 0
            for ridx in range(self.n_replicates):
                idxs = np.zeros(
                    (len(clusters[cidx]),
                    self.n_dts_for_replicate[ridx]), int)
                idxs = idxs + clusters[cidx]
                idxs = idxs + self.ndts_bias[ridx]
                idxs = idxs + self.replicate_bias[ridx]
                idxs = idxs.ravel(&#39;F&#39;)
                l = len(idxs)
                a[i:i+l] = idxs
                i += l

            d[cid] = a
        
        if self.G.data.zero_inflation_transition_policy is not None:
            # We need to convert the indices that are meant from no zero inflation to 
            # ones that take into account zero inflation - use the array from 
            # `data.Data._setrows_to_include_zero_inflation`. If the index should be
            # included, then we subtract the number of indexes that are previously off
            # before that index. If it should not be included then we exclude it
            prevoff_arr = self.G.data.off_previously_arr_zero_inflation
            rows_to_include = self.G.data.zero_inflation_transition_policy
            for cid in d:
                arr = d[cid]
                new_arr = np.zeros(len(arr), dtype=int)
                n = 0
                for i, idx in enumerate(arr):
                    if rows_to_include[idx]:
                        new_arr[n] = idx - prevoff_arr[i]
                        n += 1
                new_arr = new_arr[:n]
        return d

    # @profile
    def make_rel_params(self):
        &#39;&#39;&#39;We make the parameters needed to update the relative log-likelihod.
        This function is called once at the beginning of the update.

        THIS ASSUMES THAT EACH PERTURBATION CLUSTERS ARE DEFINED BY THE SAME CLUSTERS
            - To make this separate, make a higher level list for each perturbation index
              for each individual perturbation

        Parameters that we create with this function
        --------------------------------------------
        ys : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the observation matrix that it
            corresponds to (only the ASVs in the target cluster). This 
            array already has the growth and self-interactions subtracted
            out:
                $ \frac{log(x_{k+1}) - log(x_{k})}{dt} - a_{1,k} - a_{2,k}x_{k} $
        process_precs : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the vector of the process precision
            that corresponds to the target cluster (only the ASVs in the target
            cluster). This is a 1D array that corresponds to the diagonal of what
            would be the precision matrix.
        interactionXs : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the design matrix for the interactions
            going into that cluster. We pre-index it with the rows and columns
        prior_prec_interaction : dict (int -&gt; np.ndarray)
            Maps the target cluster id to to the diagonal of the prior precision 
            for the interaction values.
        prior_mean_interaction : dict (int -&gt; np.ndarray)
            Maps the target cluster id to to the diagonal of the prior mean 
            for the interaction values.
        prior_ll_ons : np.ndarray
            Prior log likelihood of a positive indicator. These are separate for each
            perturbation.
        prior_ll_offs : np.ndarray
            Prior log likelihood of the negative indicator. These are separate for each
            perturbation.
        priorvar_logdet_diffs : np.ndarray
            This is the prior variance log determinant that we add when the indicator
            is positive. This is different for each perturbation.
        perturbationsXs : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the design matrix that corresponds to 
            the on perturbations of the target clusters. This is preindexed by the 
            rows but not the columns - the columns assume that all of the perturbations
            are on and we index the ones that we want.
        prior_prec_perturbations : np.ndarray
            This is the prior precision of the magnitude for each of the perturbations. Use
            the perturbation index to get the value
        prior_mean_perturbations : np.ndarray
            This is the prior mean of the magnitude for each one of the perturbations. Use
            the perturbation index to get the value
        &#39;&#39;&#39;
        row_idxs = self._make_idx_for_clusters()

        # Create ys
        self.ys = {}
        y = self.G.data.construct_lhs(keys=[
            STRNAMES.SELF_INTERACTION_VALUE, STRNAMES.GROWTH_VALUE],
            kwargs_dict={STRNAMES.GROWTH_VALUE:{&#39;with_perturbations&#39;: False}})
        for tcid in self.clustering.order:
            self.ys[tcid] = y[row_idxs[tcid], :]

        # Create process_precs
        self.process_precs = {}
        process_prec_diag = self.G[STRNAMES.PROCESSVAR].prec
        for tcid in self.clustering.order:
            self.process_precs[tcid] = process_prec_diag[row_idxs[tcid]]

        # Make interactionXs
        self.interactionXs = {}
        interactions = self.G[STRNAMES.INTERACTIONS_OBJ]
        XM_master = self.G.data.design_matrices[STRNAMES.CLUSTER_INTERACTION_VALUE].toarray()
        for tcid in self.clustering.order:
            cols = []
            for i, interaction in enumerate(interactions.iter_valid()):
                if interaction.target_cid == tcid:
                    if interaction.indicator:
                        cols.append(i)
            cols = np.asarray(cols, dtype=int)
            self.interactionXs[tcid] = pl.util.fast_index(M=XM_master, 
                rows=row_idxs[tcid], cols=cols)

        # Make prior parameters for interactions
        self.prior_prec_interaction = 1/self.G[STRNAMES.PRIOR_VAR_INTERACTIONS].value
        self.prior_mean_interaction = self.G[STRNAMES.PRIOR_MEAN_INTERACTIONS].value

        # Make the perturbation parameters
        self.prior_ll_ons = []
        self.prior_ll_offs = []
        self.priorvar_logdet_diffs = []
        self.prior_prec_perturbations = []
        self.prior_mean_perturbations = []

        for perturbation in self.G.perturbations:
            prob_on = perturbation.probability.value
            self.prior_ll_ons.append(np.log(prob_on))
            self.prior_ll_offs.append(np.log(1 - prob_on))
            
            self.priorvar_logdet_diffs.append(
                np.log(perturbation.magnitude.prior.var.value))

            self.prior_prec_perturbations.append( 
                1/perturbation.magnitude.prior.var.value)

            self.prior_mean_perturbations.append(
                perturbation.magnitude.prior.mean.value)

        # Make perturbation matrices
        self.perturbationsXs = {}
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build(build=True, 
            build_for_neg_ind=True)
        Xpert_master = self.G.data.design_matrices[STRNAMES.PERT_VALUE].toarray()
        for tcid in self.clustering.order:
            self.perturbationsXs[tcid] = Xpert_master[row_idxs[tcid], :]

        self.n_clusters = len(self.clustering.order)
        self.clustering_order = self.clustering.order

        self.col2pidxcidx = []
        for pidx in range(len(self.perturbations)):
            for cidx in range(len(self.clustering.order)):
                self.col2pidxcidx.append((pidx, cidx))

        self.arr = []
        for perturbation in self.perturbations:
            self.arr = np.append(
                self.arr, 
                perturbation.indicator.cluster_bool_array())
        self.arr = np.asarray(self.arr, dtype=bool)

    # @profile
    def update_relative(self):
        &#39;&#39;&#39;Update each perturbation indicator for the given cluster by
        calculating the realtive loglikelihoods of it being on/off as
        supposed to as is. Because this is a relative loglikelihood, we
        only need to take into account the following parameters of the
        model:
            - Only the ASVs in the cluster in question
            - Only the perturbations for that cluster
            - Only the interactions going into the cluster

        Because these matrices are considerably smaller and considered &#39;dense&#39;, we
        do the operations in numpy instead of scipy sparse.

        We permute the order that the indices are updated for more robust mixing
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return
        start_time = time.time()

        self.make_rel_params()

        # Iterate over each perturbation indicator variable
        iidxs = npr.permutation(len(self.arr))
        for iidx in iidxs:
            self.update_single_idx_fast(idx=iidx)

        # Set the perturbation indicators from arr
        i = 0
        for perturbation in self.perturbations:
            for cid in self.clustering.order:
                perturbation.indicator.value[cid] = self.arr[i]
                i += 1

        # rebuild the growth design matrix
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()
        self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()
        self._time_taken = time.time() - start_time

    # @profile
    def update_single_idx_fast(self, idx):
        &#39;&#39;&#39;Do a Gibbs step for a single cluster
        &#39;&#39;&#39;
        pidx, cidx = self.col2pidxcidx[idx]

        prior_ll_on = self.prior_ll_ons[pidx]
        prior_ll_off = self.prior_ll_offs[pidx]

        d_on = self.calculate_relative_marginal_loglikelihood(idx=idx, val=True)
        d_off = self.calculate_relative_marginal_loglikelihood(idx=idx, val=False)

        ll_on = d_on + prior_ll_on
        ll_off = d_off + prior_ll_off
        dd = [ll_off, ll_on]

        # print(&#39;\nindicator&#39;, idx)
        # print(&#39;fast\n\ttotal: {}\n\tbeta_logdet_diff: {}\n\t&#39; \
        #     &#39;priorvar_logdet_diff: {}\n\tbEb_diff: {}\n\t&#39; \
        #     &#39;bEbprior_diff: {}&#39;.format(
        #         ll_on - ll_off,
        #         d_on[&#39;beta_logdet&#39;] - d_off[&#39;beta_logdet&#39;],
        #         d_on[&#39;priorvar_logdet&#39;] - d_off[&#39;priorvar_logdet&#39;],
        #         d_on[&#39;bEb&#39;] - d_off[&#39;bEb&#39;],
        #         d_on[&#39;bEbprior&#39;] - d_off[&#39;bEbprior&#39;]))
        # self.update_single_idx_slow(idx)

        res = bool(sample_categorical_log(dd))
        self.arr[idx] = res

    # @profile
    def calculate_relative_marginal_loglikelihood(self, idx, val):
        &#39;&#39;&#39;Calculate the relative marginal loglikelihood of switching the `idx`&#39;th index
        of the perturbation matrix to `val`

        Parameters
        ----------
        idx : int
            This is the index of the indicator we are sampling
        val : bool
            This is the value we are testing it at.

        Returns
        -------
        float
        &#39;&#39;&#39;
        # Create and get the data
        self.arr[idx] = val
        pidx, cidx = self.col2pidxcidx[idx]
        tcid = self.clustering_order[cidx]

        y = self.ys[tcid]
        process_prec = self.process_precs[tcid]
        X = self.interactionXs[tcid]

        prior_mean = []
        prior_prec_diag = []
        cols = []
        for temp_pidx in range(len(self.perturbations)):
            col = int(cidx + temp_pidx * self.n_clusters)
            if self.arr[col]:
                cols.append(col)
                prior_mean.append(self.prior_mean_perturbations[temp_pidx])
                prior_prec_diag.append(self.prior_prec_perturbations[temp_pidx])
        Xpert = self.perturbationsXs[tcid][:, cols]

        if Xpert.shape[1] + X.shape[1] == 0:
            # return {
            #     &#39;ret&#39;: 0,
            #     &#39;beta_logdet&#39;: 0,
            #     &#39;priorvar_logdet&#39;: 0,
            #     &#39;bEb&#39;: 0,
            #     &#39;bEbprior&#39;: 0}
            return 0

        prior_mean = np.append(
            prior_mean,
            np.full(X.shape[1], self.prior_mean_interaction))
        prior_prec_diag = np.append(
            prior_prec_diag,
            np.full(X.shape[1], self.prior_prec_interaction))
        X = np.hstack((Xpert, X))
        prior_prec = np.diag(prior_prec_diag)
        pm = (prior_prec_diag * prior_mean).reshape(-1,1)

        # Do the marginalization
        a = X.T * process_prec
        beta_prec = (a @ X) + prior_prec
        beta_cov = pinv(beta_prec, self)
        beta_mean = beta_cov @ ((a @ y) + pm )

        bEb = (beta_mean.T @ beta_prec @ beta_mean)[0,0]
        try:
            beta_logdet = log_det(beta_cov, self)
        except:
            logging.critical(&#39;Crashed in log_det&#39;)
            logging.critical(&#39;beta_cov:\n{}&#39;.format(beta_cov))
            logging.critical(&#39;prior_prec\n{}&#39;.format(prior_prec))
            raise
        
        if val:
            bEbprior = (self.prior_mean_perturbations[pidx]**2) * \
                self.prior_prec_perturbations[pidx]
            priorvar_logdet = self.priorvar_logdet_diffs[pidx]
        else:
            bEbprior = 0
            priorvar_logdet = 0

        ll2 = 0.5 * (beta_logdet - priorvar_logdet)
        ll3 = 0.5 * (bEb - bEbprior)

        # return {
        #     &#39;ret&#39;: ll2+ll3,
        #     &#39;beta_logdet&#39;: beta_logdet,
        #     &#39;priorvar_logdet&#39;: priorvar_logdet,
        #     &#39;bEb&#39;: bEb,
        #     &#39;bEbprior&#39;: bEbprior}
        return ll2 + ll3        

    # @profile
    def update_slow(self):
        &#39;&#39;&#39;Update each cluster indicator variable for the perturbation
        &#39;&#39;&#39;
        start_time = time.time()

        if self.sample_iter &lt; self.delay:
            return

        n_clusters = len(self.clustering.order)
        n_perturbations = len(self.perturbations)
        idxs = npr.permutation(int(n_clusters*n_perturbations))
        for idx in idxs:
            self.update_single_idx_slow(idx=idx)

        # rebuild the growth design matrix
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()
        self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()
        self._time_taken = time.time() - start_time

    # @profile
    def update_single_idx_slow(self, idx):
        &#39;&#39;&#39;Do a Gibbs step for a single cluster and perturbation

        Parameters
        ----------
        This is the index of the indicator in vectorized form
        &#39;&#39;&#39;
        cidx = idx % self.G.data.n_asvs
        cid = self.clustering.order[cidx]
        
        pidx = idx // self.G.data.n_asvs
        perturbation = self.perturbations[pidx]

        d_on = self.calculate_marginal_loglikelihood(cid=cid, val=True,
            perturbation=perturbation)
        d_off = self.calculate_marginal_loglikelihood(cid=cid, val=False,
            perturbation=perturbation)

        prior_ll_on = np.log(perturbation.probability.value)
        prior_ll_off = np.log(1 - perturbation.probability.value)

        ll_on = d_on[&#39;ret&#39;] + prior_ll_on
        ll_off = d_off[&#39;ret&#39;] + prior_ll_off

        # print(&#39;slow\n\ttotal: {}\n\tbeta_logdet_diff: {}\n\t&#39; \
        #     &#39;priorvar_logdet_diff: {}\n\tbEb_diff: {}\n\t&#39; \
        #     &#39;bEbprior_diff: {}&#39;.format(
        #         ll_on - ll_off,
        #         d_on[&#39;beta_logdet&#39;] - d_off[&#39;beta_logdet&#39;],
        #         d_on[&#39;priorvar_logdet&#39;] - d_off[&#39;priorvar_logdet&#39;],
        #         d_on[&#39;bEb&#39;] - d_off[&#39;bEb&#39;],
        #         d_on[&#39;bEbprior&#39;] - d_off[&#39;bEbprior&#39;]))

        dd = [ll_off, ll_on]

        res = bool(sample_categorical_log(dd))
        if perturbation.indicator.value[cid] != res:
            perturbation.indicator.value[cid] = res
            self.G.data.design_matrices[STRNAMES.PERT_VALUE].build()

    # @profile
    def calculate_marginal_loglikelihood(self, cid, val, perturbation):
        &#39;&#39;&#39;Calculate the log marginal likelihood with the perturbations integrated
        out
        &#39;&#39;&#39;
        # Set parameters
        perturbation.indicator.value[cid] = val
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()

        # Make matrices
        rhs = [STRNAMES.PERT_VALUE, STRNAMES.CLUSTER_INTERACTION_VALUE]
        lhs = [STRNAMES.GROWTH_VALUE, STRNAMES.SELF_INTERACTION_VALUE]
        X = self.G.data.construct_rhs(keys=rhs)
        y = self.G.data.construct_lhs(keys=lhs, 
            kwargs_dict={STRNAMES.GROWTH_VALUE:{&#39;with_perturbations&#39;: False}})
        
        if X.shape[1] == 0:
            return {
            &#39;ret&#39;: 0,
            &#39;beta_logdet&#39;: 0,
            &#39;priorvar_logdet&#39;: 0,
            &#39;bEb&#39;: 0,
            &#39;bEbprior&#39;: 0}

        process_prec = self.G[STRNAMES.PROCESSVAR].build_matrix(cov=False, sparse=False)
        prior_prec = build_prior_covariance(G=self.G, cov=False, order=rhs, sparse=False)
        prior_var = build_prior_covariance(G=self.G, cov=True, order=rhs, sparse=False)
        prior_mean = build_prior_mean(G=self.G, order=rhs, shape=(-1,1))

        # Calculate the posterior
        beta_prec = X.T @ process_prec @ X + prior_prec
        beta_cov = pinv(beta_prec, self)
        beta_mean = beta_cov @ ( X.T @ process_prec @ y + prior_prec @ prior_mean )
        beta_mean = np.asarray(beta_mean).reshape(-1,1)

        # Perform the marginalization
        try:
            beta_logdet = log_det(beta_cov, self)
        except:
            logging.critical(&#39;Crashed in log_det&#39;)
            logging.critical(&#39;beta_cov:\n{}&#39;.format(beta_cov))
            logging.critical(&#39;prior_prec\n{}&#39;.format(prior_prec))
            raise
        priorvar_logdet = log_det(prior_var, self)
        ll2 = 0.5 * (beta_logdet - priorvar_logdet)

        a = np.asarray(prior_mean.T @ prior_prec @ prior_mean)[0,0]
        b = np.asarray(beta_mean.T @ beta_prec @ beta_mean)[0,0]
        ll3 = -0.5 * (a  - b)

        return {
            &#39;ret&#39;: ll2+ll3,
            &#39;beta_logdet&#39;: beta_logdet,
            &#39;priorvar_logdet&#39;: priorvar_logdet,
            &#39;bEb&#39;: b,
            &#39;bEbprior&#39;: a}

    def total_on(self):
        n = 0
        for perturbation in self.perturbations:
            n += perturbation.indicator.num_on_clusters()
        return n


class PriorVarPerturbations(pl.Variable):
    &#39;&#39;&#39;Agglomerates the prior variances of the magnitudes for the perturbations.

    All perturbations get the same hyperparameters
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_VAR_PERT
        pl.Variable.__init__(self, **kwargs)
        self.perturbations = self.G.perturbations

        if self.perturbations is None:
            raise TypeError(&#39;Only instantiate this object if there are perturbations&#39;)

    def __str__(self):
        s = &#39;Perturbation Magnitude Prior Variances&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\tperturbation {}: {}&#39;.format(
                perturbation.name,
                perturbation.magnitude.prior.var.value)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].magnitude.prior.var.sample_iter

    def initialize(self, **kwargs):
        &#39;&#39;&#39;Every prior variance on the perturbations gets the same hyperparameters
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.initialize(**kwargs)

    def update(self):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.update()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()

    def get_single_value_of_perts(self):
        &#39;&#39;&#39;Get the variance for each perturbation
        &#39;&#39;&#39;
        return np.asarray([p.magnitude.prior.var.value for p in self.perturbations])

    def diag(self, only_pos_ind=True):
        &#39;&#39;&#39;Return the diagonal of the prior variances stacked up in order

        Parameters
        ----------
        only_pos_ind : bool
            If True, only put in the values for the positively indicated clusters
            for each perturbation

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        ret = []
        for perturbation in self.perturbations:
            if only_pos_ind:
                n = perturbation.indicator.num_on_clusters()
            else:
                n = len(perturbation.clustering)
            ret = np.append(
                ret,
                np.ones(n, dtype=float)*perturbation.magnitude.prior.var.value)
        return ret


class PriorVarPerturbationSingle(pl.variables.SICS):
    &#39;&#39;&#39;This is the posterior of the prior variance of regression coefficients
    for the interaction (off diagonal) variables
    &#39;&#39;&#39;
    def __init__(self, prior, perturbation, value=None, **kwargs):

        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_VAR_PERT + &#39;_&#39; + perturbation.name
        pl.variables.SICS.__init__(self, value=value, dtype=float, **kwargs)
        self.add_prior(prior)
        self.perturbation = perturbation

    def initialize(self, value_option, dof_option, scale_option, value=None,
        dof=None, scale=None, delay=0):
        &#39;&#39;&#39;Initialize the hyperparameters of the perturbation prior variance based on the
        passed in option

        Parameters
        ----------
        value_option : str
            - Initialize the value based on the specified option
            - Options
                &#39;manual&#39;
                    Set the value manually, `value` must also be specified
                &#39;auto&#39;, &#39;prior-mean&#39;
                    Set the value to the mean of the prior
                &#39;tight&#39;
                    value = 10^2
                &#39;diffuse&#39;
                    value = 10^4
        scale_option : str
            Initialize the scale of the prior
            Options
                &#39;manual&#39;
                    Set the value manually, `scale` must also be specified
                &#39;auto&#39;, &#39;diffuse&#39;
                    Set so that the mean of the distribution is 10^4
                &#39;tight&#39;
                    Set so that the mean of the distribution is 10^2
        dof_option : str
            Initialize the dof of the parameter
            Options:
                &#39;manual&#39;: Set the value with the parameter `dof`
                &#39;diffuse&#39;: Set the value to 2.5
                &#39;strong&#39;: Set the value to the expected number of interactions
                &#39;auto&#39;: Set to diffuse
        dof, scale : int, float
            User specified values
            Only necessary if  any of the options are &#39;manual&#39;
        &#39;&#39;&#39;
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        if not pl.isstr(dof_option):
            raise TypeError(&#39;`dof_option` ({}) must be a str&#39;.format(type(dof_option)))
        if dof_option == &#39;manual&#39;:
            if not pl.isnumeric(dof):
                raise TypeError(&#39;`dof` ({}) must be a numeric&#39;.format(type(dof)))
            if dof &lt; 0:
                raise ValueError(&#39;`dof` ({}) must be &gt; 0 for it to be a valid prior&#39;.format(shape))
        elif dof_option in [&#39;diffuse&#39;, &#39;auto&#39;]:
            dof = 2.5
        elif dof_option == &#39;strong&#39;:
            dof = expected_n_clusters(G=self.G)
        else:
            raise ValueError(&#39;`dof_option` ({}) not recognized&#39;.format(dof_option))
        self.prior.dof.override_value(dof)

        if not pl.isstr(scale_option):
            raise TypeError(&#39;`scale_option` ({}) must be a str&#39;.format(type(scale_option)))
        if scale_option == &#39;manual&#39;:
            if not pl.isnumeric(scale):
                raise TypeError(&#39;`scale` ({}) must be a numeric&#39;.format(type(scale)))
            if scale &lt; 0:
                raise ValueError(&#39;`scale` ({}) must be &gt; 0 for it to be a valid prior&#39;.format(scale))
        elif scale_option in [&#39;auto&#39;, &#39;diffuse&#39;]:
            # Calculate the mean to be 10
            scale = 1e4 * (self.prior.dof.value - 2) / self.prior.dof.value
        elif scale_option == &#39;tight&#39;:
            scale = 100 * (self.prior.dof.value - 2) / self.prior.dof.value
        else:
            raise ValueError(&#39;`scale_option` ({}) not recognized&#39;.format(scale_option))
        self.prior.scale.override_value(scale)

        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            if not pl.isnumeric(value):
                raise ValueError(&#39;`value` ({}) must be numeric (float,int)&#39;.format(value.__class__))
            self.value = value
        elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
            self.value = self.prior.mean()
        elif value_option == &#39;diffuse&#39;:
            self.value = 1e4
        elif value_option == &#39;tight&#39;:
            self.value = 1e2
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))

        logging.info(&#39;Prior Variance Interactions initialization results:\n&#39; \
            &#39;\tprior dof: {}\n&#39; \
            &#39;\tprior scale: {}\n&#39; \
            &#39;\tvalue: {}&#39;.format(
                self.prior.dof.value, self.prior.scale.value, self.value))

    # @profile
    def update(self):
        &#39;&#39;&#39;Calculate the posterior of the prior variance
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return

        x = self.perturbation.cluster_array(only_pos_ind=True)
        mu = self.perturbation.magnitude.prior.mean.value

        se = np.sum(np.square(x - mu))
        n = len(x)

        self.dof.value = self.prior.dof.value + n
        self.scale.value = ((self.prior.scale.value * self.prior.dof.value) + \
           se)/self.dof.value
        self.sample()


class PriorMeanPerturbations(pl.Variable):
    &#39;&#39;&#39;Agglomerates the prior variances of the magnitudes for the perturbations.

    All perturbations get the same hyperparameters
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_MEAN_PERT
        pl.Variable.__init__(self, **kwargs)
        self.perturbations = self.G.perturbations

        if self.perturbations is None:
            raise TypeError(&#39;Only instantiate this object if there are perturbations&#39;)

    def __str__(self):
        s = &#39;Perturbation Magnitude Prior Means&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\tperturbation {}: {}&#39;.format(
                perturbation.name,
                perturbation.magnitude.prior.mean.value)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].magnitude.prior.mean.sample_iter

    def initialize(self, **kwargs):
        &#39;&#39;&#39;Every prior variance on the perturbations gets the same hyperparameters
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.initialize(**kwargs)

    def update(self):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.update()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()

    def get_single_value_of_perts(self):
        &#39;&#39;&#39;Get the variance for each perturbation
        &#39;&#39;&#39;
        return np.asarray([p.magnitude.prior.mean.value for p in self.perturbations])

    def toarray(self, only_pos_ind=True):
        &#39;&#39;&#39;Return the diagonal of the prior variances stacked up in order

        Parameters
        ----------
        only_pos_ind : bool
            If True, only put in the values for the positively indicated clusters
            for each perturbation

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        ret = []
        for perturbation in self.perturbations:
            if only_pos_ind:
                n = perturbation.indicator.num_on_clusters()
            else:
                n = len(perturbation.clustering)
            ret = np.append(
                ret,
                np.ones(n, dtype=float)*perturbation.magnitude.prior.var.value)
        return ret


class PriorMeanPerturbationSingle(pl.variables.Normal):
    
    def __init__(self, prior, perturbation, **kwargs):

        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_MEAN_PERT + &#39;_&#39; + perturbation.name
        pl.variables.Normal.__init__(self, mean=None, var=None, dtype=float, **kwargs)
        self.add_prior(prior)
        self.perturbation = perturbation

    def initialize(self, value_option, mean_option, var_option, value=None,
        mean=None, var=None, delay=0):
        &#39;&#39;&#39;Initialize the hyperparameters

        Parameters
        ----------
        value_option : str
            How to set the value. Options:
                &#39;zero&#39;
                    Set to zero
                &#39;prior-mean&#39;, &#39;auto&#39;
                    Set to the mean of the prior
                &#39;manual&#39;
                    Specify with the `value` parameter
        mean_option : str
            How to set the mean of the prior
                &#39;zero&#39;, &#39;auto&#39;
                    Set to zero
                &#39;manual&#39;
                    Set with the `mean` parameter
        var_option : str
            &#39;diffuse&#39;, &#39;auto&#39;
                Variance is set to 10e4
            &#39;tight&#39;
                Variance is set to 1e2
            &#39;manual&#39;
                Set with the `var` parameter
        value, mean, var : float
            These are only necessary if we specify manual for any of the other 
            options
        delay : int
            How much to delay the start of the update during inference
        &#39;&#39;&#39;
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        # Set the mean
        if not pl.isstr(mean_option):
            raise TypeError(&#39;`mean_option` ({}) must be a str&#39;.format(type(mean_option)))
        if mean_option == &#39;manual&#39;:
            if not pl.isnumeric(mean):
                raise TypeError(&#39;`mean` ({}) must be a numeric&#39;.format(type(mean)))
        elif mean_option in [&#39;zero&#39;, &#39;auto&#39;]:
            mean = 0
        else:
            raise ValueError(&#39;`mean_option` ({}) not recognized&#39;.format(mean_option))
        self.prior.mean.override_value(mean)

        # Set the variance
        if not pl.isstr(var_option):
            raise TypeError(&#39;`var_option` ({}) must be a str&#39;.format(type(var_option)))
        if var_option == &#39;manual&#39;:
            if not pl.isnumeric(var):
                raise TypeError(&#39;`var` ({}) must be a numeric&#39;.format(type(var)))
            if var &lt;= 0:
                raise ValueError(&#39;`var` ({}) must be positive&#39;.format(var))
        elif var_option in [&#39;diffuse&#39;, &#39;auto&#39;]:
            var = 1e4
        elif var_option == &#39;tight&#39;:
            var = 1e2
        else:
            raise ValueError(&#39;`var_option` ({}) not recognized&#39;.format(var_option))
        self.prior.var.override_value(var)

        # Set the value
        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            if not pl.isnumeric(value):
                raise TypeError(&#39;`value` ({}) must be a numeric&#39;.format(type(value)))
        elif value_option in [&#39;prior-mean&#39;, &#39;auto&#39;]:
            value = self.prior.mean.value
        elif value_option == &#39;zero&#39;:
            value = 0
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))
        self.value = value
        
    def update(self):
        &#39;&#39;&#39;Update using a Gibbs update
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return

        x = self.perturbation.cluster_array(only_pos_ind=True)
        prec = 1/self.perturbation.magnitude.prior.var.value

        prior_prec = 1/self.prior.var.value
        prior_mean = self.prior.mean.value

        self.var.value = 1/(prior_prec + (len(x)*prec))
        self.mean.value = self.var.value * ((prior_mean * prior_prec) + (np.sum(x)*prec))
        self.sample()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdsine2.perturbations.PerturbationIndicators"><code class="flex name class">
<span>class <span class="ident">PerturbationIndicators</span></span>
<span>(</span><span>need_to_trace, relative, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the indicator for a perturbation</p>
<p>We only need to trace once for the perturbations. Our default is to only
trace from the magnitudes. Thus, we only trace the indicators (here) if
we are learning here and not learning the magnitudes.</p>
<p>Parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerturbationIndicators(pl.Node):
    &#39;&#39;&#39;This is the indicator for a perturbation

    We only need to trace once for the perturbations. Our default is to only
    trace from the magnitudes. Thus, we only trace the indicators (here) if
    we are learning here and not learning the magnitudes.
    &#39;&#39;&#39;
    def __init__(self, need_to_trace, relative, **kwargs):
        &#39;&#39;&#39;Parameters
        &#39;&#39;&#39;
        kwargs[&#39;name&#39;] = STRNAMES.PERT_INDICATOR
        pl.Node.__init__(self, **kwargs)
        self.need_to_trace = need_to_trace
        self.perturbations = self.G.perturbations
        self.clustering = None
        self._time_taken = None
        if relative:
            self.update = self.update_relative
        else:
            self.update = self.update_slow

    def __str__(self):
        s = &#39;Perturbation Indicators - time: {}s&#39;.format(self._time_taken)
        for perturbation in self.perturbations:
            arr = perturbation.indicator.cluster_bool_array()
            s += &#39;\nperturbation {} ({}/{}): {}&#39;.format(perturbation.name,
                np.sum(arr), len(arr), arr)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].sample_iter

    def add_trace(self):
        &#39;&#39;&#39;Only trace if perturbation indicators are being learned and the
        perturbation value is not being learned
        &#39;&#39;&#39;
        if self.need_to_trace:
            for perturbation in self.perturbations:
                perturbation.add_trace()

    def set_trace(self, *args, **kwargs):
        &#39;&#39;&#39;Only trace if perturbation indicators are being learned and the
        perturbation value is not being learned
        &#39;&#39;&#39;
        if self.need_to_trace:
            for perturbation in self.perturbations:
                perturbation.set_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        if self.need_to_trace:
            for perturbation in self.perturbations:
                perturbation.add_init_value()

    def initialize(self, value_option, p=None, delay=0):
        &#39;&#39;&#39;Initialize the based on the passed in option.

        Parameters
        ----------
        value_option (str)
            Different ways to initialize the values. Options:
                &#39;auto&#39;, &#39;all-off&#39;
                    Turn all of the indicators off
                &#39;all-on&#39;
                    Turn all the indicators on
                &#39;random&#39;
                    Randomly assign the indicator with probability `p`
        p : float
            Only required if `value_option` == &#39;random&#39;
        delay : int
            How many Gibbs steps to delay updating the values
        &#39;&#39;&#39;
        # print(&#39;in pert ind&#39;)
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        for perturbation in self.perturbations:
            perturbation.indicator.set_signal_when_clusters_change(True)
        self.clustering = self.G.perturbations[0].indicator.clustering

        # Set the value
        if not pl.isstr(value_option):
            raise ValueError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option in [&#39;all-off&#39;, &#39;auto&#39;]:
            value = False
        elif value_option == &#39;all-on&#39;:
            value = True
        elif value_option == &#39;random&#39;:
            if not pl.isfloat(p):
                raise TypeError(&#39;`p` ({}) must be a float&#39;.format(type(p)))
            if p &lt; 0 or p &gt; 1:
                raise ValueError(&#39;`p` ({}) must be [0,1]&#39;.format(p))
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))
        for perturbation in self.perturbations:
            for cid in perturbation.clustering.clusters:
                if value_option == &#39;random&#39;:
                    perturbation.indicator.value[cid] = bool(pl.random.bernoulli.sample(p))
                else:
                    perturbation.indicator.value[cid] = value

        # These are for the function `self._make_idx_for_clusters`
        self.ndts_bias = []
        self.n_replicates = self.G.data.n_replicates
        self.n_perturbations = len(self.G.perturbations)
        self.n_dts_for_replicate = self.G.data.n_dts_for_replicate
        self.total_dts = np.sum(self.n_dts_for_replicate)
        self.replicate_bias = np.zeros(self.n_replicates, dtype=int)
        self.n_asvs = len(self.G.data.asvs)
        for ridx in range(1, self.n_replicates):
            self.replicate_bias[ridx] = self.replicate_bias[ridx-1] + \
                self.n_asvs * self.n_dts_for_replicate[ridx - 1]
        for ridx in range(self.G.data.n_replicates):
            self.ndts_bias.append(
                np.arange(0, self.G.data.n_dts_for_replicate[ridx] * self.n_asvs, self.n_asvs))

        s = &#39;Perturbation indicator initialization results:\n&#39;
        for i, perturbation in enumerate(self.perturbations):
            s += &#39;\tPerturbation {}:\n&#39; \
                &#39;\t\tindicator: {}\n&#39;.format(i, perturbation.indicator.cluster_bool_array())
        logging.info(s)

    def _make_idx_for_clusters(self):
        &#39;&#39;&#39;Creates a dictionary that maps the cluster id to the
        rows that correspond to each ASV in the cluster.

        We cannot cast this with numba because it does not support Fortran style
        raveling :(.

        Returns
        -------
        dict: int -&gt; np.ndarray
            Maps the cluster ID to the row indices corresponding to it
        &#39;&#39;&#39;
        clusters = [np.asarray(oidxs, dtype=int).reshape(-1,1) \
            for oidxs in self.clustering.toarray()]
        n_dts=self.G.data.n_dts_for_replicate

        d = {}
        cids = self.clustering.order

        for cidx,cid in enumerate(cids):
            a = np.zeros(len(clusters[cidx]) * self.total_dts, dtype=int)
            i = 0
            for ridx in range(self.n_replicates):
                idxs = np.zeros(
                    (len(clusters[cidx]),
                    self.n_dts_for_replicate[ridx]), int)
                idxs = idxs + clusters[cidx]
                idxs = idxs + self.ndts_bias[ridx]
                idxs = idxs + self.replicate_bias[ridx]
                idxs = idxs.ravel(&#39;F&#39;)
                l = len(idxs)
                a[i:i+l] = idxs
                i += l

            d[cid] = a
        
        if self.G.data.zero_inflation_transition_policy is not None:
            # We need to convert the indices that are meant from no zero inflation to 
            # ones that take into account zero inflation - use the array from 
            # `data.Data._setrows_to_include_zero_inflation`. If the index should be
            # included, then we subtract the number of indexes that are previously off
            # before that index. If it should not be included then we exclude it
            prevoff_arr = self.G.data.off_previously_arr_zero_inflation
            rows_to_include = self.G.data.zero_inflation_transition_policy
            for cid in d:
                arr = d[cid]
                new_arr = np.zeros(len(arr), dtype=int)
                n = 0
                for i, idx in enumerate(arr):
                    if rows_to_include[idx]:
                        new_arr[n] = idx - prevoff_arr[i]
                        n += 1
                new_arr = new_arr[:n]
        return d

    # @profile
    def make_rel_params(self):
        &#39;&#39;&#39;We make the parameters needed to update the relative log-likelihod.
        This function is called once at the beginning of the update.

        THIS ASSUMES THAT EACH PERTURBATION CLUSTERS ARE DEFINED BY THE SAME CLUSTERS
            - To make this separate, make a higher level list for each perturbation index
              for each individual perturbation

        Parameters that we create with this function
        --------------------------------------------
        ys : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the observation matrix that it
            corresponds to (only the ASVs in the target cluster). This 
            array already has the growth and self-interactions subtracted
            out:
                $ \frac{log(x_{k+1}) - log(x_{k})}{dt} - a_{1,k} - a_{2,k}x_{k} $
        process_precs : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the vector of the process precision
            that corresponds to the target cluster (only the ASVs in the target
            cluster). This is a 1D array that corresponds to the diagonal of what
            would be the precision matrix.
        interactionXs : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the design matrix for the interactions
            going into that cluster. We pre-index it with the rows and columns
        prior_prec_interaction : dict (int -&gt; np.ndarray)
            Maps the target cluster id to to the diagonal of the prior precision 
            for the interaction values.
        prior_mean_interaction : dict (int -&gt; np.ndarray)
            Maps the target cluster id to to the diagonal of the prior mean 
            for the interaction values.
        prior_ll_ons : np.ndarray
            Prior log likelihood of a positive indicator. These are separate for each
            perturbation.
        prior_ll_offs : np.ndarray
            Prior log likelihood of the negative indicator. These are separate for each
            perturbation.
        priorvar_logdet_diffs : np.ndarray
            This is the prior variance log determinant that we add when the indicator
            is positive. This is different for each perturbation.
        perturbationsXs : dict (int -&gt; np.ndarray)
            Maps the target cluster id to the design matrix that corresponds to 
            the on perturbations of the target clusters. This is preindexed by the 
            rows but not the columns - the columns assume that all of the perturbations
            are on and we index the ones that we want.
        prior_prec_perturbations : np.ndarray
            This is the prior precision of the magnitude for each of the perturbations. Use
            the perturbation index to get the value
        prior_mean_perturbations : np.ndarray
            This is the prior mean of the magnitude for each one of the perturbations. Use
            the perturbation index to get the value
        &#39;&#39;&#39;
        row_idxs = self._make_idx_for_clusters()

        # Create ys
        self.ys = {}
        y = self.G.data.construct_lhs(keys=[
            STRNAMES.SELF_INTERACTION_VALUE, STRNAMES.GROWTH_VALUE],
            kwargs_dict={STRNAMES.GROWTH_VALUE:{&#39;with_perturbations&#39;: False}})
        for tcid in self.clustering.order:
            self.ys[tcid] = y[row_idxs[tcid], :]

        # Create process_precs
        self.process_precs = {}
        process_prec_diag = self.G[STRNAMES.PROCESSVAR].prec
        for tcid in self.clustering.order:
            self.process_precs[tcid] = process_prec_diag[row_idxs[tcid]]

        # Make interactionXs
        self.interactionXs = {}
        interactions = self.G[STRNAMES.INTERACTIONS_OBJ]
        XM_master = self.G.data.design_matrices[STRNAMES.CLUSTER_INTERACTION_VALUE].toarray()
        for tcid in self.clustering.order:
            cols = []
            for i, interaction in enumerate(interactions.iter_valid()):
                if interaction.target_cid == tcid:
                    if interaction.indicator:
                        cols.append(i)
            cols = np.asarray(cols, dtype=int)
            self.interactionXs[tcid] = pl.util.fast_index(M=XM_master, 
                rows=row_idxs[tcid], cols=cols)

        # Make prior parameters for interactions
        self.prior_prec_interaction = 1/self.G[STRNAMES.PRIOR_VAR_INTERACTIONS].value
        self.prior_mean_interaction = self.G[STRNAMES.PRIOR_MEAN_INTERACTIONS].value

        # Make the perturbation parameters
        self.prior_ll_ons = []
        self.prior_ll_offs = []
        self.priorvar_logdet_diffs = []
        self.prior_prec_perturbations = []
        self.prior_mean_perturbations = []

        for perturbation in self.G.perturbations:
            prob_on = perturbation.probability.value
            self.prior_ll_ons.append(np.log(prob_on))
            self.prior_ll_offs.append(np.log(1 - prob_on))
            
            self.priorvar_logdet_diffs.append(
                np.log(perturbation.magnitude.prior.var.value))

            self.prior_prec_perturbations.append( 
                1/perturbation.magnitude.prior.var.value)

            self.prior_mean_perturbations.append(
                perturbation.magnitude.prior.mean.value)

        # Make perturbation matrices
        self.perturbationsXs = {}
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build(build=True, 
            build_for_neg_ind=True)
        Xpert_master = self.G.data.design_matrices[STRNAMES.PERT_VALUE].toarray()
        for tcid in self.clustering.order:
            self.perturbationsXs[tcid] = Xpert_master[row_idxs[tcid], :]

        self.n_clusters = len(self.clustering.order)
        self.clustering_order = self.clustering.order

        self.col2pidxcidx = []
        for pidx in range(len(self.perturbations)):
            for cidx in range(len(self.clustering.order)):
                self.col2pidxcidx.append((pidx, cidx))

        self.arr = []
        for perturbation in self.perturbations:
            self.arr = np.append(
                self.arr, 
                perturbation.indicator.cluster_bool_array())
        self.arr = np.asarray(self.arr, dtype=bool)

    # @profile
    def update_relative(self):
        &#39;&#39;&#39;Update each perturbation indicator for the given cluster by
        calculating the realtive loglikelihoods of it being on/off as
        supposed to as is. Because this is a relative loglikelihood, we
        only need to take into account the following parameters of the
        model:
            - Only the ASVs in the cluster in question
            - Only the perturbations for that cluster
            - Only the interactions going into the cluster

        Because these matrices are considerably smaller and considered &#39;dense&#39;, we
        do the operations in numpy instead of scipy sparse.

        We permute the order that the indices are updated for more robust mixing
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return
        start_time = time.time()

        self.make_rel_params()

        # Iterate over each perturbation indicator variable
        iidxs = npr.permutation(len(self.arr))
        for iidx in iidxs:
            self.update_single_idx_fast(idx=iidx)

        # Set the perturbation indicators from arr
        i = 0
        for perturbation in self.perturbations:
            for cid in self.clustering.order:
                perturbation.indicator.value[cid] = self.arr[i]
                i += 1

        # rebuild the growth design matrix
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()
        self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()
        self._time_taken = time.time() - start_time

    # @profile
    def update_single_idx_fast(self, idx):
        &#39;&#39;&#39;Do a Gibbs step for a single cluster
        &#39;&#39;&#39;
        pidx, cidx = self.col2pidxcidx[idx]

        prior_ll_on = self.prior_ll_ons[pidx]
        prior_ll_off = self.prior_ll_offs[pidx]

        d_on = self.calculate_relative_marginal_loglikelihood(idx=idx, val=True)
        d_off = self.calculate_relative_marginal_loglikelihood(idx=idx, val=False)

        ll_on = d_on + prior_ll_on
        ll_off = d_off + prior_ll_off
        dd = [ll_off, ll_on]

        # print(&#39;\nindicator&#39;, idx)
        # print(&#39;fast\n\ttotal: {}\n\tbeta_logdet_diff: {}\n\t&#39; \
        #     &#39;priorvar_logdet_diff: {}\n\tbEb_diff: {}\n\t&#39; \
        #     &#39;bEbprior_diff: {}&#39;.format(
        #         ll_on - ll_off,
        #         d_on[&#39;beta_logdet&#39;] - d_off[&#39;beta_logdet&#39;],
        #         d_on[&#39;priorvar_logdet&#39;] - d_off[&#39;priorvar_logdet&#39;],
        #         d_on[&#39;bEb&#39;] - d_off[&#39;bEb&#39;],
        #         d_on[&#39;bEbprior&#39;] - d_off[&#39;bEbprior&#39;]))
        # self.update_single_idx_slow(idx)

        res = bool(sample_categorical_log(dd))
        self.arr[idx] = res

    # @profile
    def calculate_relative_marginal_loglikelihood(self, idx, val):
        &#39;&#39;&#39;Calculate the relative marginal loglikelihood of switching the `idx`&#39;th index
        of the perturbation matrix to `val`

        Parameters
        ----------
        idx : int
            This is the index of the indicator we are sampling
        val : bool
            This is the value we are testing it at.

        Returns
        -------
        float
        &#39;&#39;&#39;
        # Create and get the data
        self.arr[idx] = val
        pidx, cidx = self.col2pidxcidx[idx]
        tcid = self.clustering_order[cidx]

        y = self.ys[tcid]
        process_prec = self.process_precs[tcid]
        X = self.interactionXs[tcid]

        prior_mean = []
        prior_prec_diag = []
        cols = []
        for temp_pidx in range(len(self.perturbations)):
            col = int(cidx + temp_pidx * self.n_clusters)
            if self.arr[col]:
                cols.append(col)
                prior_mean.append(self.prior_mean_perturbations[temp_pidx])
                prior_prec_diag.append(self.prior_prec_perturbations[temp_pidx])
        Xpert = self.perturbationsXs[tcid][:, cols]

        if Xpert.shape[1] + X.shape[1] == 0:
            # return {
            #     &#39;ret&#39;: 0,
            #     &#39;beta_logdet&#39;: 0,
            #     &#39;priorvar_logdet&#39;: 0,
            #     &#39;bEb&#39;: 0,
            #     &#39;bEbprior&#39;: 0}
            return 0

        prior_mean = np.append(
            prior_mean,
            np.full(X.shape[1], self.prior_mean_interaction))
        prior_prec_diag = np.append(
            prior_prec_diag,
            np.full(X.shape[1], self.prior_prec_interaction))
        X = np.hstack((Xpert, X))
        prior_prec = np.diag(prior_prec_diag)
        pm = (prior_prec_diag * prior_mean).reshape(-1,1)

        # Do the marginalization
        a = X.T * process_prec
        beta_prec = (a @ X) + prior_prec
        beta_cov = pinv(beta_prec, self)
        beta_mean = beta_cov @ ((a @ y) + pm )

        bEb = (beta_mean.T @ beta_prec @ beta_mean)[0,0]
        try:
            beta_logdet = log_det(beta_cov, self)
        except:
            logging.critical(&#39;Crashed in log_det&#39;)
            logging.critical(&#39;beta_cov:\n{}&#39;.format(beta_cov))
            logging.critical(&#39;prior_prec\n{}&#39;.format(prior_prec))
            raise
        
        if val:
            bEbprior = (self.prior_mean_perturbations[pidx]**2) * \
                self.prior_prec_perturbations[pidx]
            priorvar_logdet = self.priorvar_logdet_diffs[pidx]
        else:
            bEbprior = 0
            priorvar_logdet = 0

        ll2 = 0.5 * (beta_logdet - priorvar_logdet)
        ll3 = 0.5 * (bEb - bEbprior)

        # return {
        #     &#39;ret&#39;: ll2+ll3,
        #     &#39;beta_logdet&#39;: beta_logdet,
        #     &#39;priorvar_logdet&#39;: priorvar_logdet,
        #     &#39;bEb&#39;: bEb,
        #     &#39;bEbprior&#39;: bEbprior}
        return ll2 + ll3        

    # @profile
    def update_slow(self):
        &#39;&#39;&#39;Update each cluster indicator variable for the perturbation
        &#39;&#39;&#39;
        start_time = time.time()

        if self.sample_iter &lt; self.delay:
            return

        n_clusters = len(self.clustering.order)
        n_perturbations = len(self.perturbations)
        idxs = npr.permutation(int(n_clusters*n_perturbations))
        for idx in idxs:
            self.update_single_idx_slow(idx=idx)

        # rebuild the growth design matrix
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()
        self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()
        self._time_taken = time.time() - start_time

    # @profile
    def update_single_idx_slow(self, idx):
        &#39;&#39;&#39;Do a Gibbs step for a single cluster and perturbation

        Parameters
        ----------
        This is the index of the indicator in vectorized form
        &#39;&#39;&#39;
        cidx = idx % self.G.data.n_asvs
        cid = self.clustering.order[cidx]
        
        pidx = idx // self.G.data.n_asvs
        perturbation = self.perturbations[pidx]

        d_on = self.calculate_marginal_loglikelihood(cid=cid, val=True,
            perturbation=perturbation)
        d_off = self.calculate_marginal_loglikelihood(cid=cid, val=False,
            perturbation=perturbation)

        prior_ll_on = np.log(perturbation.probability.value)
        prior_ll_off = np.log(1 - perturbation.probability.value)

        ll_on = d_on[&#39;ret&#39;] + prior_ll_on
        ll_off = d_off[&#39;ret&#39;] + prior_ll_off

        # print(&#39;slow\n\ttotal: {}\n\tbeta_logdet_diff: {}\n\t&#39; \
        #     &#39;priorvar_logdet_diff: {}\n\tbEb_diff: {}\n\t&#39; \
        #     &#39;bEbprior_diff: {}&#39;.format(
        #         ll_on - ll_off,
        #         d_on[&#39;beta_logdet&#39;] - d_off[&#39;beta_logdet&#39;],
        #         d_on[&#39;priorvar_logdet&#39;] - d_off[&#39;priorvar_logdet&#39;],
        #         d_on[&#39;bEb&#39;] - d_off[&#39;bEb&#39;],
        #         d_on[&#39;bEbprior&#39;] - d_off[&#39;bEbprior&#39;]))

        dd = [ll_off, ll_on]

        res = bool(sample_categorical_log(dd))
        if perturbation.indicator.value[cid] != res:
            perturbation.indicator.value[cid] = res
            self.G.data.design_matrices[STRNAMES.PERT_VALUE].build()

    # @profile
    def calculate_marginal_loglikelihood(self, cid, val, perturbation):
        &#39;&#39;&#39;Calculate the log marginal likelihood with the perturbations integrated
        out
        &#39;&#39;&#39;
        # Set parameters
        perturbation.indicator.value[cid] = val
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()

        # Make matrices
        rhs = [STRNAMES.PERT_VALUE, STRNAMES.CLUSTER_INTERACTION_VALUE]
        lhs = [STRNAMES.GROWTH_VALUE, STRNAMES.SELF_INTERACTION_VALUE]
        X = self.G.data.construct_rhs(keys=rhs)
        y = self.G.data.construct_lhs(keys=lhs, 
            kwargs_dict={STRNAMES.GROWTH_VALUE:{&#39;with_perturbations&#39;: False}})
        
        if X.shape[1] == 0:
            return {
            &#39;ret&#39;: 0,
            &#39;beta_logdet&#39;: 0,
            &#39;priorvar_logdet&#39;: 0,
            &#39;bEb&#39;: 0,
            &#39;bEbprior&#39;: 0}

        process_prec = self.G[STRNAMES.PROCESSVAR].build_matrix(cov=False, sparse=False)
        prior_prec = build_prior_covariance(G=self.G, cov=False, order=rhs, sparse=False)
        prior_var = build_prior_covariance(G=self.G, cov=True, order=rhs, sparse=False)
        prior_mean = build_prior_mean(G=self.G, order=rhs, shape=(-1,1))

        # Calculate the posterior
        beta_prec = X.T @ process_prec @ X + prior_prec
        beta_cov = pinv(beta_prec, self)
        beta_mean = beta_cov @ ( X.T @ process_prec @ y + prior_prec @ prior_mean )
        beta_mean = np.asarray(beta_mean).reshape(-1,1)

        # Perform the marginalization
        try:
            beta_logdet = log_det(beta_cov, self)
        except:
            logging.critical(&#39;Crashed in log_det&#39;)
            logging.critical(&#39;beta_cov:\n{}&#39;.format(beta_cov))
            logging.critical(&#39;prior_prec\n{}&#39;.format(prior_prec))
            raise
        priorvar_logdet = log_det(prior_var, self)
        ll2 = 0.5 * (beta_logdet - priorvar_logdet)

        a = np.asarray(prior_mean.T @ prior_prec @ prior_mean)[0,0]
        b = np.asarray(beta_mean.T @ beta_prec @ beta_mean)[0,0]
        ll3 = -0.5 * (a  - b)

        return {
            &#39;ret&#39;: ll2+ll3,
            &#39;beta_logdet&#39;: beta_logdet,
            &#39;priorvar_logdet&#39;: priorvar_logdet,
            &#39;bEb&#39;: b,
            &#39;bEbprior&#39;: a}

    def total_on(self):
        n = 0
        for perturbation in self.perturbations:
            n += perturbation.indicator.num_on_clusters()
        return n</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="pylab/base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.perturbations.PerturbationIndicators.sample_iter"><code class="name">var <span class="ident">sample_iter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_iter(self):
    return self.perturbations[0].sample_iter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.perturbations.PerturbationIndicators.add_init_value"><code class="name flex">
<span>def <span class="ident">add_init_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the initialization value. This is called by <code>pylab.inference.BaseMCMC.run</code>
when first updating the variable. User should not use this function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_init_value(self):
    &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
    when first updating the variable. User should not use this function
    &#39;&#39;&#39;
    if self.need_to_trace:
        for perturbation in self.perturbations:
            perturbation.add_init_value()</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.add_trace"><code class="name flex">
<span>def <span class="ident">add_trace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Only trace if perturbation indicators are being learned and the
perturbation value is not being learned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trace(self):
    &#39;&#39;&#39;Only trace if perturbation indicators are being learned and the
    perturbation value is not being learned
    &#39;&#39;&#39;
    if self.need_to_trace:
        for perturbation in self.perturbations:
            perturbation.add_trace()</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.calculate_marginal_loglikelihood"><code class="name flex">
<span>def <span class="ident">calculate_marginal_loglikelihood</span></span>(<span>self, cid, val, perturbation)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the log marginal likelihood with the perturbations integrated
out</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_marginal_loglikelihood(self, cid, val, perturbation):
    &#39;&#39;&#39;Calculate the log marginal likelihood with the perturbations integrated
    out
    &#39;&#39;&#39;
    # Set parameters
    perturbation.indicator.value[cid] = val
    self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()

    # Make matrices
    rhs = [STRNAMES.PERT_VALUE, STRNAMES.CLUSTER_INTERACTION_VALUE]
    lhs = [STRNAMES.GROWTH_VALUE, STRNAMES.SELF_INTERACTION_VALUE]
    X = self.G.data.construct_rhs(keys=rhs)
    y = self.G.data.construct_lhs(keys=lhs, 
        kwargs_dict={STRNAMES.GROWTH_VALUE:{&#39;with_perturbations&#39;: False}})
    
    if X.shape[1] == 0:
        return {
        &#39;ret&#39;: 0,
        &#39;beta_logdet&#39;: 0,
        &#39;priorvar_logdet&#39;: 0,
        &#39;bEb&#39;: 0,
        &#39;bEbprior&#39;: 0}

    process_prec = self.G[STRNAMES.PROCESSVAR].build_matrix(cov=False, sparse=False)
    prior_prec = build_prior_covariance(G=self.G, cov=False, order=rhs, sparse=False)
    prior_var = build_prior_covariance(G=self.G, cov=True, order=rhs, sparse=False)
    prior_mean = build_prior_mean(G=self.G, order=rhs, shape=(-1,1))

    # Calculate the posterior
    beta_prec = X.T @ process_prec @ X + prior_prec
    beta_cov = pinv(beta_prec, self)
    beta_mean = beta_cov @ ( X.T @ process_prec @ y + prior_prec @ prior_mean )
    beta_mean = np.asarray(beta_mean).reshape(-1,1)

    # Perform the marginalization
    try:
        beta_logdet = log_det(beta_cov, self)
    except:
        logging.critical(&#39;Crashed in log_det&#39;)
        logging.critical(&#39;beta_cov:\n{}&#39;.format(beta_cov))
        logging.critical(&#39;prior_prec\n{}&#39;.format(prior_prec))
        raise
    priorvar_logdet = log_det(prior_var, self)
    ll2 = 0.5 * (beta_logdet - priorvar_logdet)

    a = np.asarray(prior_mean.T @ prior_prec @ prior_mean)[0,0]
    b = np.asarray(beta_mean.T @ beta_prec @ beta_mean)[0,0]
    ll3 = -0.5 * (a  - b)

    return {
        &#39;ret&#39;: ll2+ll3,
        &#39;beta_logdet&#39;: beta_logdet,
        &#39;priorvar_logdet&#39;: priorvar_logdet,
        &#39;bEb&#39;: b,
        &#39;bEbprior&#39;: a}</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.calculate_relative_marginal_loglikelihood"><code class="name flex">
<span>def <span class="ident">calculate_relative_marginal_loglikelihood</span></span>(<span>self, idx, val)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the relative marginal loglikelihood of switching the <code>idx</code>'th index
of the perturbation matrix to <code>val</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>idx</code></strong> :&ensp;<code>int</code></dt>
<dd>This is the index of the indicator we are sampling</dd>
<dt><strong><code>val</code></strong> :&ensp;<code>bool</code></dt>
<dd>This is the value we are testing it at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_relative_marginal_loglikelihood(self, idx, val):
    &#39;&#39;&#39;Calculate the relative marginal loglikelihood of switching the `idx`&#39;th index
    of the perturbation matrix to `val`

    Parameters
    ----------
    idx : int
        This is the index of the indicator we are sampling
    val : bool
        This is the value we are testing it at.

    Returns
    -------
    float
    &#39;&#39;&#39;
    # Create and get the data
    self.arr[idx] = val
    pidx, cidx = self.col2pidxcidx[idx]
    tcid = self.clustering_order[cidx]

    y = self.ys[tcid]
    process_prec = self.process_precs[tcid]
    X = self.interactionXs[tcid]

    prior_mean = []
    prior_prec_diag = []
    cols = []
    for temp_pidx in range(len(self.perturbations)):
        col = int(cidx + temp_pidx * self.n_clusters)
        if self.arr[col]:
            cols.append(col)
            prior_mean.append(self.prior_mean_perturbations[temp_pidx])
            prior_prec_diag.append(self.prior_prec_perturbations[temp_pidx])
    Xpert = self.perturbationsXs[tcid][:, cols]

    if Xpert.shape[1] + X.shape[1] == 0:
        # return {
        #     &#39;ret&#39;: 0,
        #     &#39;beta_logdet&#39;: 0,
        #     &#39;priorvar_logdet&#39;: 0,
        #     &#39;bEb&#39;: 0,
        #     &#39;bEbprior&#39;: 0}
        return 0

    prior_mean = np.append(
        prior_mean,
        np.full(X.shape[1], self.prior_mean_interaction))
    prior_prec_diag = np.append(
        prior_prec_diag,
        np.full(X.shape[1], self.prior_prec_interaction))
    X = np.hstack((Xpert, X))
    prior_prec = np.diag(prior_prec_diag)
    pm = (prior_prec_diag * prior_mean).reshape(-1,1)

    # Do the marginalization
    a = X.T * process_prec
    beta_prec = (a @ X) + prior_prec
    beta_cov = pinv(beta_prec, self)
    beta_mean = beta_cov @ ((a @ y) + pm )

    bEb = (beta_mean.T @ beta_prec @ beta_mean)[0,0]
    try:
        beta_logdet = log_det(beta_cov, self)
    except:
        logging.critical(&#39;Crashed in log_det&#39;)
        logging.critical(&#39;beta_cov:\n{}&#39;.format(beta_cov))
        logging.critical(&#39;prior_prec\n{}&#39;.format(prior_prec))
        raise
    
    if val:
        bEbprior = (self.prior_mean_perturbations[pidx]**2) * \
            self.prior_prec_perturbations[pidx]
        priorvar_logdet = self.priorvar_logdet_diffs[pidx]
    else:
        bEbprior = 0
        priorvar_logdet = 0

    ll2 = 0.5 * (beta_logdet - priorvar_logdet)
    ll3 = 0.5 * (bEb - bEbprior)

    # return {
    #     &#39;ret&#39;: ll2+ll3,
    #     &#39;beta_logdet&#39;: beta_logdet,
    #     &#39;priorvar_logdet&#39;: priorvar_logdet,
    #     &#39;bEb&#39;: bEb,
    #     &#39;bEbprior&#39;: bEbprior}
    return ll2 + ll3        </code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, value_option, p=None, delay=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the based on the passed in option.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>value_option (str)</dt>
<dt>Different ways to initialize the values. Options:</dt>
<dt>'auto', 'all-off'</dt>
<dt>Turn all of the indicators off</dt>
<dt>'all-on'</dt>
<dt>Turn all the indicators on</dt>
<dt>'random'</dt>
<dt>Randomly assign the indicator with probability <code>p</code></dt>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Only required if <code>value_option</code> == 'random'</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code></dt>
<dd>How many Gibbs steps to delay updating the values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, value_option, p=None, delay=0):
    &#39;&#39;&#39;Initialize the based on the passed in option.

    Parameters
    ----------
    value_option (str)
        Different ways to initialize the values. Options:
            &#39;auto&#39;, &#39;all-off&#39;
                Turn all of the indicators off
            &#39;all-on&#39;
                Turn all the indicators on
            &#39;random&#39;
                Randomly assign the indicator with probability `p`
    p : float
        Only required if `value_option` == &#39;random&#39;
    delay : int
        How many Gibbs steps to delay updating the values
    &#39;&#39;&#39;
    # print(&#39;in pert ind&#39;)
    if not pl.isint(delay):
        raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
    if delay &lt; 0:
        raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
    self.delay = delay

    for perturbation in self.perturbations:
        perturbation.indicator.set_signal_when_clusters_change(True)
    self.clustering = self.G.perturbations[0].indicator.clustering

    # Set the value
    if not pl.isstr(value_option):
        raise ValueError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
    if value_option in [&#39;all-off&#39;, &#39;auto&#39;]:
        value = False
    elif value_option == &#39;all-on&#39;:
        value = True
    elif value_option == &#39;random&#39;:
        if not pl.isfloat(p):
            raise TypeError(&#39;`p` ({}) must be a float&#39;.format(type(p)))
        if p &lt; 0 or p &gt; 1:
            raise ValueError(&#39;`p` ({}) must be [0,1]&#39;.format(p))
    else:
        raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))
    for perturbation in self.perturbations:
        for cid in perturbation.clustering.clusters:
            if value_option == &#39;random&#39;:
                perturbation.indicator.value[cid] = bool(pl.random.bernoulli.sample(p))
            else:
                perturbation.indicator.value[cid] = value

    # These are for the function `self._make_idx_for_clusters`
    self.ndts_bias = []
    self.n_replicates = self.G.data.n_replicates
    self.n_perturbations = len(self.G.perturbations)
    self.n_dts_for_replicate = self.G.data.n_dts_for_replicate
    self.total_dts = np.sum(self.n_dts_for_replicate)
    self.replicate_bias = np.zeros(self.n_replicates, dtype=int)
    self.n_asvs = len(self.G.data.asvs)
    for ridx in range(1, self.n_replicates):
        self.replicate_bias[ridx] = self.replicate_bias[ridx-1] + \
            self.n_asvs * self.n_dts_for_replicate[ridx - 1]
    for ridx in range(self.G.data.n_replicates):
        self.ndts_bias.append(
            np.arange(0, self.G.data.n_dts_for_replicate[ridx] * self.n_asvs, self.n_asvs))

    s = &#39;Perturbation indicator initialization results:\n&#39;
    for i, perturbation in enumerate(self.perturbations):
        s += &#39;\tPerturbation {}:\n&#39; \
            &#39;\t\tindicator: {}\n&#39;.format(i, perturbation.indicator.cluster_bool_array())
    logging.info(s)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.make_rel_params"><code class="name flex">
<span>def <span class="ident">make_rel_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>We make the parameters needed to update the relative log-likelihod.
This function is called once at the beginning of the update.</p>
<p>THIS ASSUMES THAT EACH PERTURBATION CLUSTERS ARE DEFINED BY THE SAME CLUSTERS
- To make this separate, make a higher level list for each perturbation index
for each individual perturbation</p>
<h2 id="parameters-that-we-create-with-this-function">Parameters That We Create With This Function</h2>
<p>ys : dict (int -&gt; np.ndarray)
Maps the target cluster id to the observation matrix that it
corresponds to (only the ASVs in the target cluster). This
array already has the growth and self-interactions subtracted
out:
$
rac{log(x_{k+1}) - log(x_{k})}{dt} - a_{1,k} - a_{2,k}x_{k} $
process_precs : dict (int -&gt; np.ndarray)
Maps the target cluster id to the vector of the process precision
that corresponds to the target cluster (only the ASVs in the target
cluster). This is a 1D array that corresponds to the diagonal of what
would be the precision matrix.
interactionXs : dict (int -&gt; np.ndarray)
Maps the target cluster id to the design matrix for the interactions
going into that cluster. We pre-index it with the rows and columns
prior_prec_interaction : dict (int -&gt; np.ndarray)
Maps the target cluster id to to the diagonal of the prior precision
for the interaction values.
prior_mean_interaction : dict (int -&gt; np.ndarray)
Maps the target cluster id to to the diagonal of the prior mean
for the interaction values.
prior_ll_ons : np.ndarray
Prior log likelihood of a positive indicator. These are separate for each
perturbation.
prior_ll_offs : np.ndarray
Prior log likelihood of the negative indicator. These are separate for each
perturbation.
priorvar_logdet_diffs : np.ndarray
This is the prior variance log determinant that we add when the indicator
is positive. This is different for each perturbation.
perturbationsXs : dict (int -&gt; np.ndarray)
Maps the target cluster id to the design matrix that corresponds to
the on perturbations of the target clusters. This is preindexed by the
rows but not the columns - the columns assume that all of the perturbations
are on and we index the ones that we want.
prior_prec_perturbations : np.ndarray
This is the prior precision of the magnitude for each of the perturbations. Use
the perturbation index to get the value
prior_mean_perturbations : np.ndarray
This is the prior mean of the magnitude for each one of the perturbations. Use
the perturbation index to get the value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_rel_params(self):
    &#39;&#39;&#39;We make the parameters needed to update the relative log-likelihod.
    This function is called once at the beginning of the update.

    THIS ASSUMES THAT EACH PERTURBATION CLUSTERS ARE DEFINED BY THE SAME CLUSTERS
        - To make this separate, make a higher level list for each perturbation index
          for each individual perturbation

    Parameters that we create with this function
    --------------------------------------------
    ys : dict (int -&gt; np.ndarray)
        Maps the target cluster id to the observation matrix that it
        corresponds to (only the ASVs in the target cluster). This 
        array already has the growth and self-interactions subtracted
        out:
            $ \frac{log(x_{k+1}) - log(x_{k})}{dt} - a_{1,k} - a_{2,k}x_{k} $
    process_precs : dict (int -&gt; np.ndarray)
        Maps the target cluster id to the vector of the process precision
        that corresponds to the target cluster (only the ASVs in the target
        cluster). This is a 1D array that corresponds to the diagonal of what
        would be the precision matrix.
    interactionXs : dict (int -&gt; np.ndarray)
        Maps the target cluster id to the design matrix for the interactions
        going into that cluster. We pre-index it with the rows and columns
    prior_prec_interaction : dict (int -&gt; np.ndarray)
        Maps the target cluster id to to the diagonal of the prior precision 
        for the interaction values.
    prior_mean_interaction : dict (int -&gt; np.ndarray)
        Maps the target cluster id to to the diagonal of the prior mean 
        for the interaction values.
    prior_ll_ons : np.ndarray
        Prior log likelihood of a positive indicator. These are separate for each
        perturbation.
    prior_ll_offs : np.ndarray
        Prior log likelihood of the negative indicator. These are separate for each
        perturbation.
    priorvar_logdet_diffs : np.ndarray
        This is the prior variance log determinant that we add when the indicator
        is positive. This is different for each perturbation.
    perturbationsXs : dict (int -&gt; np.ndarray)
        Maps the target cluster id to the design matrix that corresponds to 
        the on perturbations of the target clusters. This is preindexed by the 
        rows but not the columns - the columns assume that all of the perturbations
        are on and we index the ones that we want.
    prior_prec_perturbations : np.ndarray
        This is the prior precision of the magnitude for each of the perturbations. Use
        the perturbation index to get the value
    prior_mean_perturbations : np.ndarray
        This is the prior mean of the magnitude for each one of the perturbations. Use
        the perturbation index to get the value
    &#39;&#39;&#39;
    row_idxs = self._make_idx_for_clusters()

    # Create ys
    self.ys = {}
    y = self.G.data.construct_lhs(keys=[
        STRNAMES.SELF_INTERACTION_VALUE, STRNAMES.GROWTH_VALUE],
        kwargs_dict={STRNAMES.GROWTH_VALUE:{&#39;with_perturbations&#39;: False}})
    for tcid in self.clustering.order:
        self.ys[tcid] = y[row_idxs[tcid], :]

    # Create process_precs
    self.process_precs = {}
    process_prec_diag = self.G[STRNAMES.PROCESSVAR].prec
    for tcid in self.clustering.order:
        self.process_precs[tcid] = process_prec_diag[row_idxs[tcid]]

    # Make interactionXs
    self.interactionXs = {}
    interactions = self.G[STRNAMES.INTERACTIONS_OBJ]
    XM_master = self.G.data.design_matrices[STRNAMES.CLUSTER_INTERACTION_VALUE].toarray()
    for tcid in self.clustering.order:
        cols = []
        for i, interaction in enumerate(interactions.iter_valid()):
            if interaction.target_cid == tcid:
                if interaction.indicator:
                    cols.append(i)
        cols = np.asarray(cols, dtype=int)
        self.interactionXs[tcid] = pl.util.fast_index(M=XM_master, 
            rows=row_idxs[tcid], cols=cols)

    # Make prior parameters for interactions
    self.prior_prec_interaction = 1/self.G[STRNAMES.PRIOR_VAR_INTERACTIONS].value
    self.prior_mean_interaction = self.G[STRNAMES.PRIOR_MEAN_INTERACTIONS].value

    # Make the perturbation parameters
    self.prior_ll_ons = []
    self.prior_ll_offs = []
    self.priorvar_logdet_diffs = []
    self.prior_prec_perturbations = []
    self.prior_mean_perturbations = []

    for perturbation in self.G.perturbations:
        prob_on = perturbation.probability.value
        self.prior_ll_ons.append(np.log(prob_on))
        self.prior_ll_offs.append(np.log(1 - prob_on))
        
        self.priorvar_logdet_diffs.append(
            np.log(perturbation.magnitude.prior.var.value))

        self.prior_prec_perturbations.append( 
            1/perturbation.magnitude.prior.var.value)

        self.prior_mean_perturbations.append(
            perturbation.magnitude.prior.mean.value)

    # Make perturbation matrices
    self.perturbationsXs = {}
    self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build(build=True, 
        build_for_neg_ind=True)
    Xpert_master = self.G.data.design_matrices[STRNAMES.PERT_VALUE].toarray()
    for tcid in self.clustering.order:
        self.perturbationsXs[tcid] = Xpert_master[row_idxs[tcid], :]

    self.n_clusters = len(self.clustering.order)
    self.clustering_order = self.clustering.order

    self.col2pidxcidx = []
    for pidx in range(len(self.perturbations)):
        for cidx in range(len(self.clustering.order)):
            self.col2pidxcidx.append((pidx, cidx))

    self.arr = []
    for perturbation in self.perturbations:
        self.arr = np.append(
            self.arr, 
            perturbation.indicator.cluster_bool_array())
    self.arr = np.asarray(self.arr, dtype=bool)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.set_trace"><code class="name flex">
<span>def <span class="ident">set_trace</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Only trace if perturbation indicators are being learned and the
perturbation value is not being learned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trace(self, *args, **kwargs):
    &#39;&#39;&#39;Only trace if perturbation indicators are being learned and the
    perturbation value is not being learned
    &#39;&#39;&#39;
    if self.need_to_trace:
        for perturbation in self.perturbations:
            perturbation.set_trace(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.total_on"><code class="name flex">
<span>def <span class="ident">total_on</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_on(self):
    n = 0
    for perturbation in self.perturbations:
        n += perturbation.indicator.num_on_clusters()
    return n</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.update_relative"><code class="name flex">
<span>def <span class="ident">update_relative</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update each perturbation indicator for the given cluster by
calculating the realtive loglikelihoods of it being on/off as
supposed to as is. Because this is a relative loglikelihood, we
only need to take into account the following parameters of the
model:
- Only the ASVs in the cluster in question
- Only the perturbations for that cluster
- Only the interactions going into the cluster</p>
<p>Because these matrices are considerably smaller and considered 'dense', we
do the operations in numpy instead of scipy sparse.</p>
<p>We permute the order that the indices are updated for more robust mixing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_relative(self):
    &#39;&#39;&#39;Update each perturbation indicator for the given cluster by
    calculating the realtive loglikelihoods of it being on/off as
    supposed to as is. Because this is a relative loglikelihood, we
    only need to take into account the following parameters of the
    model:
        - Only the ASVs in the cluster in question
        - Only the perturbations for that cluster
        - Only the interactions going into the cluster

    Because these matrices are considerably smaller and considered &#39;dense&#39;, we
    do the operations in numpy instead of scipy sparse.

    We permute the order that the indices are updated for more robust mixing
    &#39;&#39;&#39;
    if self.sample_iter &lt; self.delay:
        return
    start_time = time.time()

    self.make_rel_params()

    # Iterate over each perturbation indicator variable
    iidxs = npr.permutation(len(self.arr))
    for iidx in iidxs:
        self.update_single_idx_fast(idx=iidx)

    # Set the perturbation indicators from arr
    i = 0
    for perturbation in self.perturbations:
        for cid in self.clustering.order:
            perturbation.indicator.value[cid] = self.arr[i]
            i += 1

    # rebuild the growth design matrix
    self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()
    self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()
    self._time_taken = time.time() - start_time</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.update_single_idx_fast"><code class="name flex">
<span>def <span class="ident">update_single_idx_fast</span></span>(<span>self, idx)</span>
</code></dt>
<dd>
<div class="desc"><p>Do a Gibbs step for a single cluster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_single_idx_fast(self, idx):
    &#39;&#39;&#39;Do a Gibbs step for a single cluster
    &#39;&#39;&#39;
    pidx, cidx = self.col2pidxcidx[idx]

    prior_ll_on = self.prior_ll_ons[pidx]
    prior_ll_off = self.prior_ll_offs[pidx]

    d_on = self.calculate_relative_marginal_loglikelihood(idx=idx, val=True)
    d_off = self.calculate_relative_marginal_loglikelihood(idx=idx, val=False)

    ll_on = d_on + prior_ll_on
    ll_off = d_off + prior_ll_off
    dd = [ll_off, ll_on]

    # print(&#39;\nindicator&#39;, idx)
    # print(&#39;fast\n\ttotal: {}\n\tbeta_logdet_diff: {}\n\t&#39; \
    #     &#39;priorvar_logdet_diff: {}\n\tbEb_diff: {}\n\t&#39; \
    #     &#39;bEbprior_diff: {}&#39;.format(
    #         ll_on - ll_off,
    #         d_on[&#39;beta_logdet&#39;] - d_off[&#39;beta_logdet&#39;],
    #         d_on[&#39;priorvar_logdet&#39;] - d_off[&#39;priorvar_logdet&#39;],
    #         d_on[&#39;bEb&#39;] - d_off[&#39;bEb&#39;],
    #         d_on[&#39;bEbprior&#39;] - d_off[&#39;bEbprior&#39;]))
    # self.update_single_idx_slow(idx)

    res = bool(sample_categorical_log(dd))
    self.arr[idx] = res</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.update_single_idx_slow"><code class="name flex">
<span>def <span class="ident">update_single_idx_slow</span></span>(<span>self, idx)</span>
</code></dt>
<dd>
<div class="desc"><p>Do a Gibbs step for a single cluster and perturbation</p>
<h2 id="parameters">Parameters</h2>
<p>This is the index of the indicator in vectorized form</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_single_idx_slow(self, idx):
    &#39;&#39;&#39;Do a Gibbs step for a single cluster and perturbation

    Parameters
    ----------
    This is the index of the indicator in vectorized form
    &#39;&#39;&#39;
    cidx = idx % self.G.data.n_asvs
    cid = self.clustering.order[cidx]
    
    pidx = idx // self.G.data.n_asvs
    perturbation = self.perturbations[pidx]

    d_on = self.calculate_marginal_loglikelihood(cid=cid, val=True,
        perturbation=perturbation)
    d_off = self.calculate_marginal_loglikelihood(cid=cid, val=False,
        perturbation=perturbation)

    prior_ll_on = np.log(perturbation.probability.value)
    prior_ll_off = np.log(1 - perturbation.probability.value)

    ll_on = d_on[&#39;ret&#39;] + prior_ll_on
    ll_off = d_off[&#39;ret&#39;] + prior_ll_off

    # print(&#39;slow\n\ttotal: {}\n\tbeta_logdet_diff: {}\n\t&#39; \
    #     &#39;priorvar_logdet_diff: {}\n\tbEb_diff: {}\n\t&#39; \
    #     &#39;bEbprior_diff: {}&#39;.format(
    #         ll_on - ll_off,
    #         d_on[&#39;beta_logdet&#39;] - d_off[&#39;beta_logdet&#39;],
    #         d_on[&#39;priorvar_logdet&#39;] - d_off[&#39;priorvar_logdet&#39;],
    #         d_on[&#39;bEb&#39;] - d_off[&#39;bEb&#39;],
    #         d_on[&#39;bEbprior&#39;] - d_off[&#39;bEbprior&#39;]))

    dd = [ll_off, ll_on]

    res = bool(sample_categorical_log(dd))
    if perturbation.indicator.value[cid] != res:
        perturbation.indicator.value[cid] = res
        self.G.data.design_matrices[STRNAMES.PERT_VALUE].build()</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationIndicators.update_slow"><code class="name flex">
<span>def <span class="ident">update_slow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update each cluster indicator variable for the perturbation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_slow(self):
    &#39;&#39;&#39;Update each cluster indicator variable for the perturbation
    &#39;&#39;&#39;
    start_time = time.time()

    if self.sample_iter &lt; self.delay:
        return

    n_clusters = len(self.clustering.order)
    n_perturbations = len(self.perturbations)
    idxs = npr.permutation(int(n_clusters*n_perturbations))
    for idx in idxs:
        self.update_single_idx_slow(idx=idx)

    # rebuild the growth design matrix
    self.G.data.design_matrices[STRNAMES.PERT_VALUE].M.build()
    self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()
    self._time_taken = time.time() - start_time</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.graph.Node.add_child" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_parent" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_prior" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_undirected" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.degree" href="pylab/graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.delete" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.get_adjacent_keys" href="pylab/graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.load" href="pylab/base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.metropolis" href="pylab/graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.save" href="pylab/base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.set_save_location" href="pylab/base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.perturbations.PerturbationMagnitudes"><code class="flex name class">
<span>class <span class="ident">PerturbationMagnitudes</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>These update the perturbation values jointly.</p>
<p>Parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerturbationMagnitudes(pl.variables.Normal):
    &#39;&#39;&#39;These update the perturbation values jointly.
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        &#39;&#39;&#39;Parameters
        &#39;&#39;&#39;

        kwargs[&#39;name&#39;] = STRNAMES.PERT_VALUE
        pl.variables.Normal.__init__(self, mean=None, var=None, dtype=float, **kwargs)
        self.perturbations = self.G.perturbations

    def __str__(self):
        s = &#39;Perturbation Magnitudes (multiplicative)&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\t perturbation {}: {}&#39;.format(
                perturbation.name, perturbation.cluster_array(only_pos_ind=True))
        return s

    def __len__(self):
        &#39;&#39;&#39;Return the number of on indicators
        &#39;&#39;&#39;
        n = 0
        for perturbation in self.perturbations:
            n += perturbation.indicator.num_on_clusters()
        return n

    def set_values(self, arr, use_indicators=True):
        &#39;&#39;&#39;Set the values of the perturbation of them stacked one on top of each other

        Parameters
        ----------
        arr : np.ndarray
            Values for all of the perturbations in order
        use_indicators : bool
            If True, the values only refer to the on indicators
        &#39;&#39;&#39;
        i = 0
        for perturbation in self.perturbations:
            l = perturbation.indicator.num_on_clusters()
            perturbation.set_values_from_array(values=arr[i:i+l],
                use_indicators=use_indicators)
            i += l

    def update_str(self):
        return

    @property
    def sample_iter(self):
        return self.perturbations[0].sample_iter

    def initialize(self, value_option, value=None, mean=None, var=None, delay=0):
        &#39;&#39;&#39;Initialize the prior and the value of the perturbation. We assume that
        each perturbation has the same hyperparameters for the prior

        Parameters
        ----------
        value_option : str
            How to initialize the values. Options:
                &#39;manual&#39;
                    Set the value manually, `value` must also be specified
                &#39;zero&#39;
                    Set all the values to zero.
                &#39;auto&#39;, &#39;prior-mean&#39;
                    Initialize to the same value as the prior mean
        delay : int, None
            How many MCMC iterations to delay the update of the values.
        mean, var, value : int, float, array
            - Only necessary if any of the options are &#39;manual&#39;
        &#39;&#39;&#39;
        if delay is None:
            delay = 0
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay
        for perturbation in self.perturbations:
            perturbation.magnitude.set_signal_when_clusters_change(True)

        # Set the value of the perturbations
        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            for pidx, perturbation in enumerate(self.perturbations):
                v = value[pidx]
                for cidx, val in enumerate(v):
                    cid = perturbation.clustering.order[cidx]
                    perturbation.indicator.value[cid] = not np.isnan(val)
                    perturbation.magnitude.value[cid] = val if not np.isnan(val) else 0

        elif value_option == &#39;zero&#39;:
            for perturbation in self.perturbations:
                for cid in perturbation.clustering.order:
                    perturbation.magnitude.value[cid] = 0
        elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
            for perturbation in self.perturbations:
                mean = perturbation.magnitude.prior.mean.value
                for cid in perturbation.clustering.order:
                    perturbation.magnitude.value[cid] = mean
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))


        s = &#39;Perturbation magnitude initialization results:\n&#39;
        for perturbation in self.perturbations:
            if perturbation.name is not None:
                a = perturbation.name
            s += &#39;\tPerturbation {}:\n&#39; \
                &#39;\t\tvalue: {}\n&#39;.format(a, perturbation.magnitude.cluster_array())
        logging.info(s)

    def update(self):
        &#39;&#39;&#39;Update with a gibbs step jointly
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return

        n_on = [perturbation.indicator.num_on_clusters() for perturbation in \
            self.perturbations]
        
        if n_on == 0:
            return

        rhs = [STRNAMES.PERT_VALUE]
        lhs = [
            STRNAMES.GROWTH_VALUE,
            STRNAMES.SELF_INTERACTION_VALUE,
            STRNAMES.CLUSTER_INTERACTION_VALUE]
        X = self.G.data.construct_rhs(keys=rhs, toarray=True)
        y = self.G.data.construct_lhs(keys=lhs,
            kwargs_dict={STRNAMES.GROWTH_VALUE:{
                &#39;with_perturbations&#39;:False}})

        process_prec = self.G[STRNAMES.PROCESSVAR].prec
        prior_prec = build_prior_covariance(G=self.G, cov=False, order=rhs, sparse=False)

        prior_mean = build_prior_mean(G=self.G, order=rhs).reshape(-1,1)

        a = X.T * process_prec
        prec = a @ X + prior_prec
        cov = pinv(prec, self)
        mean = np.asarray(cov @ (a @ y + prior_prec @ prior_mean)).ravel()

        # print(&#39;\n\ny\n&#39;,np.hstack((y, self.G.data.lhs.vector.reshape(-1,1))))
        # print(self.G[STRNAMES.CLUSTER_INTERACTION_VALUE].value)
        # print(self.G[STRNAMES.GROWTH_VALUE].value)
        # print(self.G[STRNAMES.SELF_INTERACTION_VALUE].value)

        self.mean.value = mean
        self.var.value = np.diag(cov)
        value = self.sample()

        if np.any(np.isnan(value)):
            logging.critical(&#39;mean: {}&#39;.format(self.mean.value))
            logging.critical(&#39;var: {}&#39;.format(self.var.value))
            logging.critical(&#39;value: {}&#39;.format(self.value))
            logging.critical(&#39;prior mean: {}&#39;.format(prior_mean.ravel()))
            raise ValueError(&#39;`Values in {} are nan: {}&#39;.format(self.name, self.value))

        i = 0
        for pidx, perturbation in enumerate(self.perturbations):
            perturbation.set_values_from_array(value[i:i+n_on[pidx]], use_indicators=True)
            i += n_on[pidx]

        # Rebuild the design matrix
        self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()

    def asarray(self):
        &#39;&#39;&#39;Get an array of the perturbation magnitudes
        &#39;&#39;&#39;
        a = []
        for perturbation in self.perturbations:
            a.append(perturbation.cluster_array(only_pos_ind=True))
        return np.asarray(list(itertools.chain.from_iterable(a)))

    def toarray(self):
        return self.asarray()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Normal" href="pylab/variables.html#mdsine2.pylab.variables.Normal">Normal</a></li>
<li><a title="mdsine2.pylab.variables.Variable" href="pylab/variables.html#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="pylab/base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="pylab/base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.perturbations.PerturbationMagnitudes.sample_iter"><code class="name">var <span class="ident">sample_iter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_iter(self):
    return self.perturbations[0].sample_iter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.perturbations.PerturbationMagnitudes.asarray"><code class="name flex">
<span>def <span class="ident">asarray</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an array of the perturbation magnitudes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asarray(self):
    &#39;&#39;&#39;Get an array of the perturbation magnitudes
    &#39;&#39;&#39;
    a = []
    for perturbation in self.perturbations:
        a.append(perturbation.cluster_array(only_pos_ind=True))
    return np.asarray(list(itertools.chain.from_iterable(a)))</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationMagnitudes.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, value_option, value=None, mean=None, var=None, delay=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the prior and the value of the perturbation. We assume that
each perturbation has the same hyperparameters for the prior</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value_option</code></strong> :&ensp;<code>str</code></dt>
<dd>How to initialize the values. Options:
'manual'
Set the value manually, <code>value</code> must also be specified
'zero'
Set all the values to zero.
'auto', 'prior-mean'
Initialize to the same value as the prior mean</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int, None</code></dt>
<dd>How many MCMC iterations to delay the update of the values.</dd>
<dt><strong><code>mean</code></strong>, <strong><code>var</code></strong>, <strong><code>value</code></strong> :&ensp;<code>int, float, array</code></dt>
<dd>
<ul>
<li>Only necessary if any of the options are 'manual'</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, value_option, value=None, mean=None, var=None, delay=0):
    &#39;&#39;&#39;Initialize the prior and the value of the perturbation. We assume that
    each perturbation has the same hyperparameters for the prior

    Parameters
    ----------
    value_option : str
        How to initialize the values. Options:
            &#39;manual&#39;
                Set the value manually, `value` must also be specified
            &#39;zero&#39;
                Set all the values to zero.
            &#39;auto&#39;, &#39;prior-mean&#39;
                Initialize to the same value as the prior mean
    delay : int, None
        How many MCMC iterations to delay the update of the values.
    mean, var, value : int, float, array
        - Only necessary if any of the options are &#39;manual&#39;
    &#39;&#39;&#39;
    if delay is None:
        delay = 0
    if not pl.isint(delay):
        raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
    if delay &lt; 0:
        raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
    self.delay = delay
    for perturbation in self.perturbations:
        perturbation.magnitude.set_signal_when_clusters_change(True)

    # Set the value of the perturbations
    if not pl.isstr(value_option):
        raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
    if value_option == &#39;manual&#39;:
        for pidx, perturbation in enumerate(self.perturbations):
            v = value[pidx]
            for cidx, val in enumerate(v):
                cid = perturbation.clustering.order[cidx]
                perturbation.indicator.value[cid] = not np.isnan(val)
                perturbation.magnitude.value[cid] = val if not np.isnan(val) else 0

    elif value_option == &#39;zero&#39;:
        for perturbation in self.perturbations:
            for cid in perturbation.clustering.order:
                perturbation.magnitude.value[cid] = 0
    elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
        for perturbation in self.perturbations:
            mean = perturbation.magnitude.prior.mean.value
            for cid in perturbation.clustering.order:
                perturbation.magnitude.value[cid] = mean
    else:
        raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))


    s = &#39;Perturbation magnitude initialization results:\n&#39;
    for perturbation in self.perturbations:
        if perturbation.name is not None:
            a = perturbation.name
        s += &#39;\tPerturbation {}:\n&#39; \
            &#39;\t\tvalue: {}\n&#39;.format(a, perturbation.magnitude.cluster_array())
    logging.info(s)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationMagnitudes.set_values"><code class="name flex">
<span>def <span class="ident">set_values</span></span>(<span>self, arr, use_indicators=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the values of the perturbation of them stacked one on top of each other</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Values for all of the perturbations in order</dd>
<dt><strong><code>use_indicators</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, the values only refer to the on indicators</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_values(self, arr, use_indicators=True):
    &#39;&#39;&#39;Set the values of the perturbation of them stacked one on top of each other

    Parameters
    ----------
    arr : np.ndarray
        Values for all of the perturbations in order
    use_indicators : bool
        If True, the values only refer to the on indicators
    &#39;&#39;&#39;
    i = 0
    for perturbation in self.perturbations:
        l = perturbation.indicator.num_on_clusters()
        perturbation.set_values_from_array(values=arr[i:i+l],
            use_indicators=use_indicators)
        i += l</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationMagnitudes.toarray"><code class="name flex">
<span>def <span class="ident">toarray</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toarray(self):
    return self.asarray()</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationMagnitudes.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update with a gibbs step jointly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#39;&#39;&#39;Update with a gibbs step jointly
    &#39;&#39;&#39;
    if self.sample_iter &lt; self.delay:
        return

    n_on = [perturbation.indicator.num_on_clusters() for perturbation in \
        self.perturbations]
    
    if n_on == 0:
        return

    rhs = [STRNAMES.PERT_VALUE]
    lhs = [
        STRNAMES.GROWTH_VALUE,
        STRNAMES.SELF_INTERACTION_VALUE,
        STRNAMES.CLUSTER_INTERACTION_VALUE]
    X = self.G.data.construct_rhs(keys=rhs, toarray=True)
    y = self.G.data.construct_lhs(keys=lhs,
        kwargs_dict={STRNAMES.GROWTH_VALUE:{
            &#39;with_perturbations&#39;:False}})

    process_prec = self.G[STRNAMES.PROCESSVAR].prec
    prior_prec = build_prior_covariance(G=self.G, cov=False, order=rhs, sparse=False)

    prior_mean = build_prior_mean(G=self.G, order=rhs).reshape(-1,1)

    a = X.T * process_prec
    prec = a @ X + prior_prec
    cov = pinv(prec, self)
    mean = np.asarray(cov @ (a @ y + prior_prec @ prior_mean)).ravel()

    # print(&#39;\n\ny\n&#39;,np.hstack((y, self.G.data.lhs.vector.reshape(-1,1))))
    # print(self.G[STRNAMES.CLUSTER_INTERACTION_VALUE].value)
    # print(self.G[STRNAMES.GROWTH_VALUE].value)
    # print(self.G[STRNAMES.SELF_INTERACTION_VALUE].value)

    self.mean.value = mean
    self.var.value = np.diag(cov)
    value = self.sample()

    if np.any(np.isnan(value)):
        logging.critical(&#39;mean: {}&#39;.format(self.mean.value))
        logging.critical(&#39;var: {}&#39;.format(self.var.value))
        logging.critical(&#39;value: {}&#39;.format(self.value))
        logging.critical(&#39;prior mean: {}&#39;.format(prior_mean.ravel()))
        raise ValueError(&#39;`Values in {} are nan: {}&#39;.format(self.name, self.value))

    i = 0
    for pidx, perturbation in enumerate(self.perturbations):
        perturbation.set_values_from_array(value[i:i+n_on[pidx]], use_indicators=True)
        i += n_on[pidx]

    # Rebuild the design matrix
    self.G.data.design_matrices[STRNAMES.GROWTH_VALUE].build_with_perturbations()</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationMagnitudes.update_str"><code class="name flex">
<span>def <span class="ident">update_str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_str(self):
    return</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Normal" href="pylab/variables.html#mdsine2.pylab.variables.Normal">Normal</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Normal.T" href="pylab/variables.html#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_child" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_init_value" href="pylab/variables.html#mdsine2.pylab.variables.Variable.add_init_value">add_init_value</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_parent" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_prior" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_undirected" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.cdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.degree" href="pylab/graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.delete" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.get_adjacent_keys" href="pylab/graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.get_iter" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.get_trace_from_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.load" href="pylab/base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.logcdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.logpdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.metropolis" href="pylab/graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.overwrite_entire_trace_on_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.pdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.sample" href="pylab/variables.html#mdsine2.pylab.variables.Normal.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.save" href="pylab/base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.set_save_location" href="pylab/base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.set_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.set_value_shape" href="pylab/variables.html#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.perturbations.PerturbationProbabilities"><code class="flex name class">
<span>class <span class="ident">PerturbationProbabilities</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the probability for a positive interaction for a perturbation</p>
<p>Parameters</p>
<p>prior (pl.variables.Beta)
- prior probability
pert_n (int)
- This is the perturbation number that it corresponds to
**kwargs
- Other options like graph, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PerturbationProbabilities(pl.Node):
    &#39;&#39;&#39;This is the probability for a positive interaction for a perturbation
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        &#39;&#39;&#39;Parameters

        prior (pl.variables.Beta)
            - prior probability
        pert_n (int)
            - This is the perturbation number that it corresponds to
        **kwargs
            - Other options like graph, value
        &#39;&#39;&#39;
        kwargs[&#39;name&#39;] = STRNAMES.PERT_INDICATOR_PROB
        pl.Node.__init__(self, **kwargs)
        self.perturbations = self.G.perturbations

    def __str__(self):
        s = &#39;Perturbation Indicator probabilities&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\tperturbation {}: {}&#39;.format(
                perturbation.name,
                perturbation.probability.value)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].probability.sample_iter

    def initialize(self, value_option, hyperparam_option, a=None, b=None, value=None,
        N=&#39;auto&#39;, delay=0):
        &#39;&#39;&#39;Initialize the hyperparameters of the prior and the value. Each
        perturbation has the same prior.

        Parameters
        ----------
        value_option : str
            How to initialize the values. Options:
                &#39;manual&#39;
                    Set the value manually, `value` must also be specified
                &#39;auto&#39;, &#39;prior-mean&#39;
                    Initialize the value as the prior mean
        hyperparam_option : str
            How to initialize `a` and `b`. Options:
                &#39;manual&#39;
                    Set the value manually. `a` and `b` must also be specified
                &#39;weak-agnostic&#39; or &#39;auto&#39;
                    a=b=0.5
                &#39;strong-dense&#39;
                    a = N, N are the expected number of clusters
                    b = 0.5
                &#39;strong-sparse&#39;
                    a = 0.5
                    b = N, N are the expected number of clusters
                &#39;very-strong-sparse&#39;
                    a = 0.5
                    b = N, N are the expected number of ASVs
        N : str, int
            This is the number of clusters to set the hyperparam options to 
            (if they are dependent on the number of cluster). If &#39;auto&#39;, set to the expected number
            of clusters from a dirichlet process. Else use this number (must be an int).
        delay : int
            How many MCMC iterations to delay starting the update of the variable
        value, a, b : int, float
            User specified values
            Only necessary if `hyperparam_option` == &#39;manual&#39;
        &#39;&#39;&#39;
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        # Set the hyper-parameters
        if not pl.isstr(hyperparam_option):
            raise ValueError(&#39;`hyperparam_option` ({}) must be a str&#39;.format(type(hyperparam_option)))
        if hyperparam_option == &#39;manual&#39;:
            if (not pl.isnumeric(a)) or (not pl.isnumeric(b)):
                raise TypeError(&#39;If `hyperparam_option` is &#34;manual&#34; then `a` ({})&#39; \
                    &#39; and `b` ({}) must be numerics&#39;.format(type(a), type(b)))
        elif hyperparam_option in [&#39;auto&#39;, &#39;weak-agnostic&#39;]:
            a = 0.5
            b = 0.5
        elif hyperparam_option == &#39;strong-dense&#39;:
            if pl.isstr(N):
                if N == &#39;auto&#39;:
                    N = expected_n_clusters(G=self.G)
                else:
                    raise ValueError(&#39;`N` ({}) nto recognized&#39;.format(N))
            elif pl.isint(N):
                if N &lt; 0:
                    raise ValueError(&#39;`N` ({}) must be positive&#39;.format(N))
            else:
                raise TypeError(&#39;`N` ({}) type not recognized&#39;.format(type(N)))
            a = N
            b = 0.5
        elif hyperparam_option == &#39;strong-sparse&#39;:
            if pl.isstr(N):
                if N == &#39;auto&#39;:
                    N = expected_n_clusters(G=self.G)
                else:
                    raise ValueError(&#39;`N` ({}) nto recognized&#39;.format(N))
            elif pl.isint(N):
                if N &lt; 0:
                    raise ValueError(&#39;`N` ({}) must be positive&#39;.format(N))
            else:
                raise TypeError(&#39;`N` ({}) type not recognized&#39;.format(type(N)))
            a = 0.5
            b = N
        elif hyperparam_option == &#39;very-strong-sparse&#39;:
            N = self.G.data.n_asvs
            a = 0.5
            b = N
        else:
            raise ValueError(&#39;`hyperparam_option` ({}) not recognized&#39;.format(hyperparam_option))
        for perturbation in self.perturbations:
            perturbation.probability.prior.a.override_value(a)
            perturbation.probability.prior.b.override_value(b)

        # Set the value
        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            if not pl.isnumeric(value):
                raise TypeError(&#39;If `value_option` is &#34;manual&#34; then `value` ({})&#39; \
                    &#39; must be a numeric&#39;.format(type(value)))
            for perturbation in self.perturbations:
                perturbation.probability.value = value
        elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
            for perturbation in self.perturbations:
                perturbation.probability.value = perturbation.probability.prior.mean()
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))

        s = &#39;Perturbation indicator probability initialization results:\n&#39;
        for i, perturbation in enumerate(self.perturbations):
            s += &#39;\tPerturbation {}:\n&#39; \
                &#39;\t\tprior a: {}\n&#39; \
                &#39;\t\tprior b: {}\n&#39; \
                &#39;\t\tvalue: {}\n&#39;.format(i,
                    perturbation.probability.prior.a.value,
                    perturbation.probability.prior.b.value,
                    perturbation.probability.value)
        logging.info(s)

    def update(self):
        &#39;&#39;&#39;Update according to how many positive and negative indicators there
        are
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return
        for perturbation in self.perturbations:
            num_pos = perturbation.indicator.num_on_clusters()
            num_neg = len(perturbation.clustering.clusters) - num_pos
            perturbation.probability.a.value = perturbation.probability.prior.a.value + num_pos
            perturbation.probability.b.value = perturbation.probability.prior.b.value + num_neg
            perturbation.probability.sample()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.probability.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.probability.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="pylab/base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.perturbations.PerturbationProbabilities.sample_iter"><code class="name">var <span class="ident">sample_iter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_iter(self):
    return self.perturbations[0].probability.sample_iter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.perturbations.PerturbationProbabilities.add_init_value"><code class="name flex">
<span>def <span class="ident">add_init_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the initialization value. This is called by <code>pylab.inference.BaseMCMC.run</code>
when first updating the variable. User should not use this function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_init_value(self):
    &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
    when first updating the variable. User should not use this function
    &#39;&#39;&#39;
    for perturbation in self.perturbations:
        perturbation.add_init_value()</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationProbabilities.add_trace"><code class="name flex">
<span>def <span class="ident">add_trace</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_trace(self, *args, **kwargs):
    for perturbation in self.perturbations:
        perturbation.probability.add_trace(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationProbabilities.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, value_option, hyperparam_option, a=None, b=None, value=None, N='auto', delay=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the hyperparameters of the prior and the value. Each
perturbation has the same prior.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value_option</code></strong> :&ensp;<code>str</code></dt>
<dd>How to initialize the values. Options:
'manual'
Set the value manually, <code>value</code> must also be specified
'auto', 'prior-mean'
Initialize the value as the prior mean</dd>
<dt><strong><code>hyperparam_option</code></strong> :&ensp;<code>str</code></dt>
<dd>How to initialize <code>a</code> and <code>b</code>. Options:
'manual'
Set the value manually. <code>a</code> and <code>b</code> must also be specified
'weak-agnostic' or 'auto'
a=b=0.5
'strong-dense'
a = N, N are the expected number of clusters
b = 0.5
'strong-sparse'
a = 0.5
b = N, N are the expected number of clusters
'very-strong-sparse'
a = 0.5
b = N, N are the expected number of ASVs</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>str, int</code></dt>
<dd>This is the number of clusters to set the hyperparam options to
(if they are dependent on the number of cluster). If 'auto', set to the expected number
of clusters from a dirichlet process. Else use this number (must be an int).</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code></dt>
<dd>How many MCMC iterations to delay starting the update of the variable</dd>
<dt><strong><code>value</code></strong>, <strong><code>a</code></strong>, <strong><code>b</code></strong> :&ensp;<code>int, float</code></dt>
<dd>User specified values
Only necessary if <code>hyperparam_option</code> == 'manual'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, value_option, hyperparam_option, a=None, b=None, value=None,
    N=&#39;auto&#39;, delay=0):
    &#39;&#39;&#39;Initialize the hyperparameters of the prior and the value. Each
    perturbation has the same prior.

    Parameters
    ----------
    value_option : str
        How to initialize the values. Options:
            &#39;manual&#39;
                Set the value manually, `value` must also be specified
            &#39;auto&#39;, &#39;prior-mean&#39;
                Initialize the value as the prior mean
    hyperparam_option : str
        How to initialize `a` and `b`. Options:
            &#39;manual&#39;
                Set the value manually. `a` and `b` must also be specified
            &#39;weak-agnostic&#39; or &#39;auto&#39;
                a=b=0.5
            &#39;strong-dense&#39;
                a = N, N are the expected number of clusters
                b = 0.5
            &#39;strong-sparse&#39;
                a = 0.5
                b = N, N are the expected number of clusters
            &#39;very-strong-sparse&#39;
                a = 0.5
                b = N, N are the expected number of ASVs
    N : str, int
        This is the number of clusters to set the hyperparam options to 
        (if they are dependent on the number of cluster). If &#39;auto&#39;, set to the expected number
        of clusters from a dirichlet process. Else use this number (must be an int).
    delay : int
        How many MCMC iterations to delay starting the update of the variable
    value, a, b : int, float
        User specified values
        Only necessary if `hyperparam_option` == &#39;manual&#39;
    &#39;&#39;&#39;
    if not pl.isint(delay):
        raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
    if delay &lt; 0:
        raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
    self.delay = delay

    # Set the hyper-parameters
    if not pl.isstr(hyperparam_option):
        raise ValueError(&#39;`hyperparam_option` ({}) must be a str&#39;.format(type(hyperparam_option)))
    if hyperparam_option == &#39;manual&#39;:
        if (not pl.isnumeric(a)) or (not pl.isnumeric(b)):
            raise TypeError(&#39;If `hyperparam_option` is &#34;manual&#34; then `a` ({})&#39; \
                &#39; and `b` ({}) must be numerics&#39;.format(type(a), type(b)))
    elif hyperparam_option in [&#39;auto&#39;, &#39;weak-agnostic&#39;]:
        a = 0.5
        b = 0.5
    elif hyperparam_option == &#39;strong-dense&#39;:
        if pl.isstr(N):
            if N == &#39;auto&#39;:
                N = expected_n_clusters(G=self.G)
            else:
                raise ValueError(&#39;`N` ({}) nto recognized&#39;.format(N))
        elif pl.isint(N):
            if N &lt; 0:
                raise ValueError(&#39;`N` ({}) must be positive&#39;.format(N))
        else:
            raise TypeError(&#39;`N` ({}) type not recognized&#39;.format(type(N)))
        a = N
        b = 0.5
    elif hyperparam_option == &#39;strong-sparse&#39;:
        if pl.isstr(N):
            if N == &#39;auto&#39;:
                N = expected_n_clusters(G=self.G)
            else:
                raise ValueError(&#39;`N` ({}) nto recognized&#39;.format(N))
        elif pl.isint(N):
            if N &lt; 0:
                raise ValueError(&#39;`N` ({}) must be positive&#39;.format(N))
        else:
            raise TypeError(&#39;`N` ({}) type not recognized&#39;.format(type(N)))
        a = 0.5
        b = N
    elif hyperparam_option == &#39;very-strong-sparse&#39;:
        N = self.G.data.n_asvs
        a = 0.5
        b = N
    else:
        raise ValueError(&#39;`hyperparam_option` ({}) not recognized&#39;.format(hyperparam_option))
    for perturbation in self.perturbations:
        perturbation.probability.prior.a.override_value(a)
        perturbation.probability.prior.b.override_value(b)

    # Set the value
    if not pl.isstr(value_option):
        raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
    if value_option == &#39;manual&#39;:
        if not pl.isnumeric(value):
            raise TypeError(&#39;If `value_option` is &#34;manual&#34; then `value` ({})&#39; \
                &#39; must be a numeric&#39;.format(type(value)))
        for perturbation in self.perturbations:
            perturbation.probability.value = value
    elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
        for perturbation in self.perturbations:
            perturbation.probability.value = perturbation.probability.prior.mean()
    else:
        raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))

    s = &#39;Perturbation indicator probability initialization results:\n&#39;
    for i, perturbation in enumerate(self.perturbations):
        s += &#39;\tPerturbation {}:\n&#39; \
            &#39;\t\tprior a: {}\n&#39; \
            &#39;\t\tprior b: {}\n&#39; \
            &#39;\t\tvalue: {}\n&#39;.format(i,
                perturbation.probability.prior.a.value,
                perturbation.probability.prior.b.value,
                perturbation.probability.value)
    logging.info(s)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationProbabilities.set_trace"><code class="name flex">
<span>def <span class="ident">set_trace</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_trace(self, *args, **kwargs):
    for perturbation in self.perturbations:
        perturbation.probability.set_trace(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PerturbationProbabilities.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update according to how many positive and negative indicators there
are</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#39;&#39;&#39;Update according to how many positive and negative indicators there
    are
    &#39;&#39;&#39;
    if self.sample_iter &lt; self.delay:
        return
    for perturbation in self.perturbations:
        num_pos = perturbation.indicator.num_on_clusters()
        num_neg = len(perturbation.clustering.clusters) - num_pos
        perturbation.probability.a.value = perturbation.probability.prior.a.value + num_pos
        perturbation.probability.b.value = perturbation.probability.prior.b.value + num_neg
        perturbation.probability.sample()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.graph.Node.add_child" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_parent" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_prior" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.add_undirected" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.degree" href="pylab/graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.delete" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.get_adjacent_keys" href="pylab/graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.load" href="pylab/base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.metropolis" href="pylab/graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.save" href="pylab/base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.graph.Node.set_save_location" href="pylab/base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.perturbations.PriorMeanPerturbationSingle"><code class="flex name class">
<span>class <span class="ident">PriorMeanPerturbationSingle</span></span>
<span>(</span><span>prior, perturbation, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Scalar normal variable parameterized by the mean and variance</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mean</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the mean of the distribution</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>float, int</code></dt>
<dd>This is the variance of the distribution</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>These are extra parameters for the Node class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriorMeanPerturbationSingle(pl.variables.Normal):
    
    def __init__(self, prior, perturbation, **kwargs):

        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_MEAN_PERT + &#39;_&#39; + perturbation.name
        pl.variables.Normal.__init__(self, mean=None, var=None, dtype=float, **kwargs)
        self.add_prior(prior)
        self.perturbation = perturbation

    def initialize(self, value_option, mean_option, var_option, value=None,
        mean=None, var=None, delay=0):
        &#39;&#39;&#39;Initialize the hyperparameters

        Parameters
        ----------
        value_option : str
            How to set the value. Options:
                &#39;zero&#39;
                    Set to zero
                &#39;prior-mean&#39;, &#39;auto&#39;
                    Set to the mean of the prior
                &#39;manual&#39;
                    Specify with the `value` parameter
        mean_option : str
            How to set the mean of the prior
                &#39;zero&#39;, &#39;auto&#39;
                    Set to zero
                &#39;manual&#39;
                    Set with the `mean` parameter
        var_option : str
            &#39;diffuse&#39;, &#39;auto&#39;
                Variance is set to 10e4
            &#39;tight&#39;
                Variance is set to 1e2
            &#39;manual&#39;
                Set with the `var` parameter
        value, mean, var : float
            These are only necessary if we specify manual for any of the other 
            options
        delay : int
            How much to delay the start of the update during inference
        &#39;&#39;&#39;
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        # Set the mean
        if not pl.isstr(mean_option):
            raise TypeError(&#39;`mean_option` ({}) must be a str&#39;.format(type(mean_option)))
        if mean_option == &#39;manual&#39;:
            if not pl.isnumeric(mean):
                raise TypeError(&#39;`mean` ({}) must be a numeric&#39;.format(type(mean)))
        elif mean_option in [&#39;zero&#39;, &#39;auto&#39;]:
            mean = 0
        else:
            raise ValueError(&#39;`mean_option` ({}) not recognized&#39;.format(mean_option))
        self.prior.mean.override_value(mean)

        # Set the variance
        if not pl.isstr(var_option):
            raise TypeError(&#39;`var_option` ({}) must be a str&#39;.format(type(var_option)))
        if var_option == &#39;manual&#39;:
            if not pl.isnumeric(var):
                raise TypeError(&#39;`var` ({}) must be a numeric&#39;.format(type(var)))
            if var &lt;= 0:
                raise ValueError(&#39;`var` ({}) must be positive&#39;.format(var))
        elif var_option in [&#39;diffuse&#39;, &#39;auto&#39;]:
            var = 1e4
        elif var_option == &#39;tight&#39;:
            var = 1e2
        else:
            raise ValueError(&#39;`var_option` ({}) not recognized&#39;.format(var_option))
        self.prior.var.override_value(var)

        # Set the value
        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            if not pl.isnumeric(value):
                raise TypeError(&#39;`value` ({}) must be a numeric&#39;.format(type(value)))
        elif value_option in [&#39;prior-mean&#39;, &#39;auto&#39;]:
            value = self.prior.mean.value
        elif value_option == &#39;zero&#39;:
            value = 0
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))
        self.value = value
        
    def update(self):
        &#39;&#39;&#39;Update using a Gibbs update
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return

        x = self.perturbation.cluster_array(only_pos_ind=True)
        prec = 1/self.perturbation.magnitude.prior.var.value

        prior_prec = 1/self.prior.var.value
        prior_mean = self.prior.mean.value

        self.var.value = 1/(prior_prec + (len(x)*prec))
        self.mean.value = self.var.value * ((prior_mean * prior_prec) + (np.sum(x)*prec))
        self.sample()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Normal" href="pylab/variables.html#mdsine2.pylab.variables.Normal">Normal</a></li>
<li><a title="mdsine2.pylab.variables.Variable" href="pylab/variables.html#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="pylab/base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="pylab/base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.perturbations.PriorMeanPerturbationSingle.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, value_option, mean_option, var_option, value=None, mean=None, var=None, delay=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the hyperparameters</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value_option</code></strong> :&ensp;<code>str</code></dt>
<dd>How to set the value. Options:
'zero'
Set to zero
'prior-mean', 'auto'
Set to the mean of the prior
'manual'
Specify with the <code>value</code> parameter</dd>
<dt><strong><code>mean_option</code></strong> :&ensp;<code>str</code></dt>
<dd>How to set the mean of the prior
'zero', 'auto'
Set to zero
'manual'
Set with the <code>mean</code> parameter</dd>
<dt><strong><code>var_option</code></strong> :&ensp;<code>str</code></dt>
<dd>'diffuse', 'auto'
Variance is set to 10e4
'tight'
Variance is set to 1e2
'manual'
Set with the <code>var</code> parameter</dd>
<dt><strong><code>value</code></strong>, <strong><code>mean</code></strong>, <strong><code>var</code></strong> :&ensp;<code>float</code></dt>
<dd>These are only necessary if we specify manual for any of the other
options</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code></dt>
<dd>How much to delay the start of the update during inference</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, value_option, mean_option, var_option, value=None,
    mean=None, var=None, delay=0):
    &#39;&#39;&#39;Initialize the hyperparameters

    Parameters
    ----------
    value_option : str
        How to set the value. Options:
            &#39;zero&#39;
                Set to zero
            &#39;prior-mean&#39;, &#39;auto&#39;
                Set to the mean of the prior
            &#39;manual&#39;
                Specify with the `value` parameter
    mean_option : str
        How to set the mean of the prior
            &#39;zero&#39;, &#39;auto&#39;
                Set to zero
            &#39;manual&#39;
                Set with the `mean` parameter
    var_option : str
        &#39;diffuse&#39;, &#39;auto&#39;
            Variance is set to 10e4
        &#39;tight&#39;
            Variance is set to 1e2
        &#39;manual&#39;
            Set with the `var` parameter
    value, mean, var : float
        These are only necessary if we specify manual for any of the other 
        options
    delay : int
        How much to delay the start of the update during inference
    &#39;&#39;&#39;
    if not pl.isint(delay):
        raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
    if delay &lt; 0:
        raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
    self.delay = delay

    # Set the mean
    if not pl.isstr(mean_option):
        raise TypeError(&#39;`mean_option` ({}) must be a str&#39;.format(type(mean_option)))
    if mean_option == &#39;manual&#39;:
        if not pl.isnumeric(mean):
            raise TypeError(&#39;`mean` ({}) must be a numeric&#39;.format(type(mean)))
    elif mean_option in [&#39;zero&#39;, &#39;auto&#39;]:
        mean = 0
    else:
        raise ValueError(&#39;`mean_option` ({}) not recognized&#39;.format(mean_option))
    self.prior.mean.override_value(mean)

    # Set the variance
    if not pl.isstr(var_option):
        raise TypeError(&#39;`var_option` ({}) must be a str&#39;.format(type(var_option)))
    if var_option == &#39;manual&#39;:
        if not pl.isnumeric(var):
            raise TypeError(&#39;`var` ({}) must be a numeric&#39;.format(type(var)))
        if var &lt;= 0:
            raise ValueError(&#39;`var` ({}) must be positive&#39;.format(var))
    elif var_option in [&#39;diffuse&#39;, &#39;auto&#39;]:
        var = 1e4
    elif var_option == &#39;tight&#39;:
        var = 1e2
    else:
        raise ValueError(&#39;`var_option` ({}) not recognized&#39;.format(var_option))
    self.prior.var.override_value(var)

    # Set the value
    if not pl.isstr(value_option):
        raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
    if value_option == &#39;manual&#39;:
        if not pl.isnumeric(value):
            raise TypeError(&#39;`value` ({}) must be a numeric&#39;.format(type(value)))
    elif value_option in [&#39;prior-mean&#39;, &#39;auto&#39;]:
        value = self.prior.mean.value
    elif value_option == &#39;zero&#39;:
        value = 0
    else:
        raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))
    self.value = value</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorMeanPerturbationSingle.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update using a Gibbs update</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#39;&#39;&#39;Update using a Gibbs update
    &#39;&#39;&#39;
    if self.sample_iter &lt; self.delay:
        return

    x = self.perturbation.cluster_array(only_pos_ind=True)
    prec = 1/self.perturbation.magnitude.prior.var.value

    prior_prec = 1/self.prior.var.value
    prior_mean = self.prior.mean.value

    self.var.value = 1/(prior_prec + (len(x)*prec))
    self.mean.value = self.var.value * ((prior_mean * prior_prec) + (np.sum(x)*prec))
    self.sample()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Normal" href="pylab/variables.html#mdsine2.pylab.variables.Normal">Normal</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Normal.T" href="pylab/variables.html#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_child" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_init_value" href="pylab/variables.html#mdsine2.pylab.variables.Variable.add_init_value">add_init_value</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_parent" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_prior" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.add_undirected" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.cdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.cdf">cdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.degree" href="pylab/graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.delete" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.get_adjacent_keys" href="pylab/graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.get_iter" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.get_trace_from_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.load" href="pylab/base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.logcdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.logcdf">logcdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.logpdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.metropolis" href="pylab/graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.overwrite_entire_trace_on_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.pdf" href="pylab/variables.html#mdsine2.pylab.variables.Normal.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.sample" href="pylab/variables.html#mdsine2.pylab.variables.Normal.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.save" href="pylab/base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.set_save_location" href="pylab/base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.set_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Normal.set_value_shape" href="pylab/variables.html#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.perturbations.PriorMeanPerturbations"><code class="flex name class">
<span>class <span class="ident">PriorMeanPerturbations</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Agglomerates the prior variances of the magnitudes for the perturbations.</p>
<p>All perturbations get the same hyperparameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriorMeanPerturbations(pl.Variable):
    &#39;&#39;&#39;Agglomerates the prior variances of the magnitudes for the perturbations.

    All perturbations get the same hyperparameters
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_MEAN_PERT
        pl.Variable.__init__(self, **kwargs)
        self.perturbations = self.G.perturbations

        if self.perturbations is None:
            raise TypeError(&#39;Only instantiate this object if there are perturbations&#39;)

    def __str__(self):
        s = &#39;Perturbation Magnitude Prior Means&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\tperturbation {}: {}&#39;.format(
                perturbation.name,
                perturbation.magnitude.prior.mean.value)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].magnitude.prior.mean.sample_iter

    def initialize(self, **kwargs):
        &#39;&#39;&#39;Every prior variance on the perturbations gets the same hyperparameters
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.initialize(**kwargs)

    def update(self):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.update()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.mean.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()

    def get_single_value_of_perts(self):
        &#39;&#39;&#39;Get the variance for each perturbation
        &#39;&#39;&#39;
        return np.asarray([p.magnitude.prior.mean.value for p in self.perturbations])

    def toarray(self, only_pos_ind=True):
        &#39;&#39;&#39;Return the diagonal of the prior variances stacked up in order

        Parameters
        ----------
        only_pos_ind : bool
            If True, only put in the values for the positively indicated clusters
            for each perturbation

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        ret = []
        for perturbation in self.perturbations:
            if only_pos_ind:
                n = perturbation.indicator.num_on_clusters()
            else:
                n = len(perturbation.clustering)
            ret = np.append(
                ret,
                np.ones(n, dtype=float)*perturbation.magnitude.prior.var.value)
        return ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="pylab/variables.html#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="pylab/base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="pylab/base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.perturbations.PriorMeanPerturbations.sample_iter"><code class="name">var <span class="ident">sample_iter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_iter(self):
    return self.perturbations[0].magnitude.prior.mean.sample_iter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.perturbations.PriorMeanPerturbations.get_single_value_of_perts"><code class="name flex">
<span>def <span class="ident">get_single_value_of_perts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the variance for each perturbation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_single_value_of_perts(self):
    &#39;&#39;&#39;Get the variance for each perturbation
    &#39;&#39;&#39;
    return np.asarray([p.magnitude.prior.mean.value for p in self.perturbations])</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorMeanPerturbations.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Every prior variance on the perturbations gets the same hyperparameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, **kwargs):
    &#39;&#39;&#39;Every prior variance on the perturbations gets the same hyperparameters
    &#39;&#39;&#39;
    for perturbation in self.perturbations:
        perturbation.magnitude.prior.mean.initialize(**kwargs)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorMeanPerturbations.toarray"><code class="name flex">
<span>def <span class="ident">toarray</span></span>(<span>self, only_pos_ind=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the diagonal of the prior variances stacked up in order</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>only_pos_ind</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, only put in the values for the positively indicated clusters
for each perturbation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toarray(self, only_pos_ind=True):
    &#39;&#39;&#39;Return the diagonal of the prior variances stacked up in order

    Parameters
    ----------
    only_pos_ind : bool
        If True, only put in the values for the positively indicated clusters
        for each perturbation

    Returns
    -------
    np.ndarray
    &#39;&#39;&#39;
    ret = []
    for perturbation in self.perturbations:
        if only_pos_ind:
            n = perturbation.indicator.num_on_clusters()
        else:
            n = len(perturbation.clustering)
        ret = np.append(
            ret,
            np.ones(n, dtype=float)*perturbation.magnitude.prior.var.value)
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorMeanPerturbations.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    for perturbation in self.perturbations:
        perturbation.magnitude.prior.mean.update()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="pylab/variables.html#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="pylab/variables.html#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_init_value" href="pylab/variables.html#mdsine2.pylab.variables.Variable.add_init_value">add_init_value</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="pylab/graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="pylab/graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="pylab/base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="pylab/graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="pylab/base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="pylab/base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="pylab/variables.html#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.perturbations.PriorVarPerturbationSingle"><code class="flex name class">
<span>class <span class="ident">PriorVarPerturbationSingle</span></span>
<span>(</span><span>prior, perturbation, value=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the posterior of the prior variance of regression coefficients
for the interaction (off diagonal) variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriorVarPerturbationSingle(pl.variables.SICS):
    &#39;&#39;&#39;This is the posterior of the prior variance of regression coefficients
    for the interaction (off diagonal) variables
    &#39;&#39;&#39;
    def __init__(self, prior, perturbation, value=None, **kwargs):

        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_VAR_PERT + &#39;_&#39; + perturbation.name
        pl.variables.SICS.__init__(self, value=value, dtype=float, **kwargs)
        self.add_prior(prior)
        self.perturbation = perturbation

    def initialize(self, value_option, dof_option, scale_option, value=None,
        dof=None, scale=None, delay=0):
        &#39;&#39;&#39;Initialize the hyperparameters of the perturbation prior variance based on the
        passed in option

        Parameters
        ----------
        value_option : str
            - Initialize the value based on the specified option
            - Options
                &#39;manual&#39;
                    Set the value manually, `value` must also be specified
                &#39;auto&#39;, &#39;prior-mean&#39;
                    Set the value to the mean of the prior
                &#39;tight&#39;
                    value = 10^2
                &#39;diffuse&#39;
                    value = 10^4
        scale_option : str
            Initialize the scale of the prior
            Options
                &#39;manual&#39;
                    Set the value manually, `scale` must also be specified
                &#39;auto&#39;, &#39;diffuse&#39;
                    Set so that the mean of the distribution is 10^4
                &#39;tight&#39;
                    Set so that the mean of the distribution is 10^2
        dof_option : str
            Initialize the dof of the parameter
            Options:
                &#39;manual&#39;: Set the value with the parameter `dof`
                &#39;diffuse&#39;: Set the value to 2.5
                &#39;strong&#39;: Set the value to the expected number of interactions
                &#39;auto&#39;: Set to diffuse
        dof, scale : int, float
            User specified values
            Only necessary if  any of the options are &#39;manual&#39;
        &#39;&#39;&#39;
        if not pl.isint(delay):
            raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
        if delay &lt; 0:
            raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
        self.delay = delay

        if not pl.isstr(dof_option):
            raise TypeError(&#39;`dof_option` ({}) must be a str&#39;.format(type(dof_option)))
        if dof_option == &#39;manual&#39;:
            if not pl.isnumeric(dof):
                raise TypeError(&#39;`dof` ({}) must be a numeric&#39;.format(type(dof)))
            if dof &lt; 0:
                raise ValueError(&#39;`dof` ({}) must be &gt; 0 for it to be a valid prior&#39;.format(shape))
        elif dof_option in [&#39;diffuse&#39;, &#39;auto&#39;]:
            dof = 2.5
        elif dof_option == &#39;strong&#39;:
            dof = expected_n_clusters(G=self.G)
        else:
            raise ValueError(&#39;`dof_option` ({}) not recognized&#39;.format(dof_option))
        self.prior.dof.override_value(dof)

        if not pl.isstr(scale_option):
            raise TypeError(&#39;`scale_option` ({}) must be a str&#39;.format(type(scale_option)))
        if scale_option == &#39;manual&#39;:
            if not pl.isnumeric(scale):
                raise TypeError(&#39;`scale` ({}) must be a numeric&#39;.format(type(scale)))
            if scale &lt; 0:
                raise ValueError(&#39;`scale` ({}) must be &gt; 0 for it to be a valid prior&#39;.format(scale))
        elif scale_option in [&#39;auto&#39;, &#39;diffuse&#39;]:
            # Calculate the mean to be 10
            scale = 1e4 * (self.prior.dof.value - 2) / self.prior.dof.value
        elif scale_option == &#39;tight&#39;:
            scale = 100 * (self.prior.dof.value - 2) / self.prior.dof.value
        else:
            raise ValueError(&#39;`scale_option` ({}) not recognized&#39;.format(scale_option))
        self.prior.scale.override_value(scale)

        if not pl.isstr(value_option):
            raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
        if value_option == &#39;manual&#39;:
            if not pl.isnumeric(value):
                raise ValueError(&#39;`value` ({}) must be numeric (float,int)&#39;.format(value.__class__))
            self.value = value
        elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
            self.value = self.prior.mean()
        elif value_option == &#39;diffuse&#39;:
            self.value = 1e4
        elif value_option == &#39;tight&#39;:
            self.value = 1e2
        else:
            raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))

        logging.info(&#39;Prior Variance Interactions initialization results:\n&#39; \
            &#39;\tprior dof: {}\n&#39; \
            &#39;\tprior scale: {}\n&#39; \
            &#39;\tvalue: {}&#39;.format(
                self.prior.dof.value, self.prior.scale.value, self.value))

    # @profile
    def update(self):
        &#39;&#39;&#39;Calculate the posterior of the prior variance
        &#39;&#39;&#39;
        if self.sample_iter &lt; self.delay:
            return

        x = self.perturbation.cluster_array(only_pos_ind=True)
        mu = self.perturbation.magnitude.prior.mean.value

        se = np.sum(np.square(x - mu))
        n = len(x)

        self.dof.value = self.prior.dof.value + n
        self.scale.value = ((self.prior.scale.value * self.prior.dof.value) + \
           se)/self.dof.value
        self.sample()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.SICS" href="pylab/variables.html#mdsine2.pylab.variables.SICS">SICS</a></li>
<li><a title="mdsine2.pylab.variables.Variable" href="pylab/variables.html#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="pylab/base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="pylab/base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
<li>mdsine2.pylab.variables._RandomBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.perturbations.PriorVarPerturbationSingle.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, value_option, dof_option, scale_option, value=None, dof=None, scale=None, delay=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the hyperparameters of the perturbation prior variance based on the
passed in option</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value_option</code></strong> :&ensp;<code>str</code></dt>
<dd>
<ul>
<li>Initialize the value based on the specified option</li>
<li>Options
'manual'
Set the value manually, <code>value</code> must also be specified
'auto', 'prior-mean'
Set the value to the mean of the prior
'tight'
value = 10^2
'diffuse'
value = 10^4</li>
</ul>
</dd>
<dt><strong><code>scale_option</code></strong> :&ensp;<code>str</code></dt>
<dd>Initialize the scale of the prior
Options
'manual'
Set the value manually, <code>scale</code> must also be specified
'auto', 'diffuse'
Set so that the mean of the distribution is 10^4
'tight'
Set so that the mean of the distribution is 10^2</dd>
<dt><strong><code>dof_option</code></strong> :&ensp;<code>str</code></dt>
<dd>Initialize the dof of the parameter
Options:
'manual': Set the value with the parameter <code>dof</code>
'diffuse': Set the value to 2.5
'strong': Set the value to the expected number of interactions
'auto': Set to diffuse</dd>
<dt><strong><code>dof</code></strong>, <strong><code>scale</code></strong> :&ensp;<code>int, float</code></dt>
<dd>User specified values
Only necessary if
any of the options are 'manual'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, value_option, dof_option, scale_option, value=None,
    dof=None, scale=None, delay=0):
    &#39;&#39;&#39;Initialize the hyperparameters of the perturbation prior variance based on the
    passed in option

    Parameters
    ----------
    value_option : str
        - Initialize the value based on the specified option
        - Options
            &#39;manual&#39;
                Set the value manually, `value` must also be specified
            &#39;auto&#39;, &#39;prior-mean&#39;
                Set the value to the mean of the prior
            &#39;tight&#39;
                value = 10^2
            &#39;diffuse&#39;
                value = 10^4
    scale_option : str
        Initialize the scale of the prior
        Options
            &#39;manual&#39;
                Set the value manually, `scale` must also be specified
            &#39;auto&#39;, &#39;diffuse&#39;
                Set so that the mean of the distribution is 10^4
            &#39;tight&#39;
                Set so that the mean of the distribution is 10^2
    dof_option : str
        Initialize the dof of the parameter
        Options:
            &#39;manual&#39;: Set the value with the parameter `dof`
            &#39;diffuse&#39;: Set the value to 2.5
            &#39;strong&#39;: Set the value to the expected number of interactions
            &#39;auto&#39;: Set to diffuse
    dof, scale : int, float
        User specified values
        Only necessary if  any of the options are &#39;manual&#39;
    &#39;&#39;&#39;
    if not pl.isint(delay):
        raise TypeError(&#39;`delay` ({}) must be an int&#39;.format(type(delay)))
    if delay &lt; 0:
        raise ValueError(&#39;`delay` ({}) must be &gt;= 0&#39;.format(delay))
    self.delay = delay

    if not pl.isstr(dof_option):
        raise TypeError(&#39;`dof_option` ({}) must be a str&#39;.format(type(dof_option)))
    if dof_option == &#39;manual&#39;:
        if not pl.isnumeric(dof):
            raise TypeError(&#39;`dof` ({}) must be a numeric&#39;.format(type(dof)))
        if dof &lt; 0:
            raise ValueError(&#39;`dof` ({}) must be &gt; 0 for it to be a valid prior&#39;.format(shape))
    elif dof_option in [&#39;diffuse&#39;, &#39;auto&#39;]:
        dof = 2.5
    elif dof_option == &#39;strong&#39;:
        dof = expected_n_clusters(G=self.G)
    else:
        raise ValueError(&#39;`dof_option` ({}) not recognized&#39;.format(dof_option))
    self.prior.dof.override_value(dof)

    if not pl.isstr(scale_option):
        raise TypeError(&#39;`scale_option` ({}) must be a str&#39;.format(type(scale_option)))
    if scale_option == &#39;manual&#39;:
        if not pl.isnumeric(scale):
            raise TypeError(&#39;`scale` ({}) must be a numeric&#39;.format(type(scale)))
        if scale &lt; 0:
            raise ValueError(&#39;`scale` ({}) must be &gt; 0 for it to be a valid prior&#39;.format(scale))
    elif scale_option in [&#39;auto&#39;, &#39;diffuse&#39;]:
        # Calculate the mean to be 10
        scale = 1e4 * (self.prior.dof.value - 2) / self.prior.dof.value
    elif scale_option == &#39;tight&#39;:
        scale = 100 * (self.prior.dof.value - 2) / self.prior.dof.value
    else:
        raise ValueError(&#39;`scale_option` ({}) not recognized&#39;.format(scale_option))
    self.prior.scale.override_value(scale)

    if not pl.isstr(value_option):
        raise TypeError(&#39;`value_option` ({}) must be a str&#39;.format(type(value_option)))
    if value_option == &#39;manual&#39;:
        if not pl.isnumeric(value):
            raise ValueError(&#39;`value` ({}) must be numeric (float,int)&#39;.format(value.__class__))
        self.value = value
    elif value_option in [&#39;auto&#39;, &#39;prior-mean&#39;]:
        self.value = self.prior.mean()
    elif value_option == &#39;diffuse&#39;:
        self.value = 1e4
    elif value_option == &#39;tight&#39;:
        self.value = 1e2
    else:
        raise ValueError(&#39;`value_option` ({}) not recognized&#39;.format(value_option))

    logging.info(&#39;Prior Variance Interactions initialization results:\n&#39; \
        &#39;\tprior dof: {}\n&#39; \
        &#39;\tprior scale: {}\n&#39; \
        &#39;\tvalue: {}&#39;.format(
            self.prior.dof.value, self.prior.scale.value, self.value))</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorVarPerturbationSingle.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the posterior of the prior variance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#39;&#39;&#39;Calculate the posterior of the prior variance
    &#39;&#39;&#39;
    if self.sample_iter &lt; self.delay:
        return

    x = self.perturbation.cluster_array(only_pos_ind=True)
    mu = self.perturbation.magnitude.prior.mean.value

    se = np.sum(np.square(x - mu))
    n = len(x)

    self.dof.value = self.prior.dof.value + n
    self.scale.value = ((self.prior.scale.value * self.prior.dof.value) + \
       se)/self.dof.value
    self.sample()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.SICS" href="pylab/variables.html#mdsine2.pylab.variables.SICS">SICS</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.SICS.T" href="pylab/variables.html#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.add_child" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.add_init_value" href="pylab/variables.html#mdsine2.pylab.variables.Variable.add_init_value">add_init_value</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.add_parent" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.add_prior" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.add_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.add_undirected" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.degree" href="pylab/graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.delete" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.get_adjacent_keys" href="pylab/graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.get_iter" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.get_trace_from_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.load" href="pylab/base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.logpdf" href="pylab/variables.html#mdsine2.pylab.variables.SICS.logpdf">logpdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.metropolis" href="pylab/graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.overwrite_entire_trace_on_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.pdf" href="pylab/variables.html#mdsine2.pylab.variables.SICS.pdf">pdf</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.sample" href="pylab/variables.html#mdsine2.pylab.variables.SICS.sample">sample</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.save" href="pylab/base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.set_save_location" href="pylab/base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.set_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.SICS.set_value_shape" href="pylab/variables.html#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mdsine2.perturbations.PriorVarPerturbations"><code class="flex name class">
<span>class <span class="ident">PriorVarPerturbations</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Agglomerates the prior variances of the magnitudes for the perturbations.</p>
<p>All perturbations get the same hyperparameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PriorVarPerturbations(pl.Variable):
    &#39;&#39;&#39;Agglomerates the prior variances of the magnitudes for the perturbations.

    All perturbations get the same hyperparameters
    &#39;&#39;&#39;
    def __init__(self, **kwargs):
        kwargs[&#39;name&#39;] = STRNAMES.PRIOR_VAR_PERT
        pl.Variable.__init__(self, **kwargs)
        self.perturbations = self.G.perturbations

        if self.perturbations is None:
            raise TypeError(&#39;Only instantiate this object if there are perturbations&#39;)

    def __str__(self):
        s = &#39;Perturbation Magnitude Prior Variances&#39;
        for perturbation in self.perturbations:
            s += &#39;\n\tperturbation {}: {}&#39;.format(
                perturbation.name,
                perturbation.magnitude.prior.var.value)
        return s

    @property
    def sample_iter(self):
        return self.perturbations[0].magnitude.prior.var.sample_iter

    def initialize(self, **kwargs):
        &#39;&#39;&#39;Every prior variance on the perturbations gets the same hyperparameters
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.initialize(**kwargs)

    def update(self):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.update()

    def set_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.set_trace(*args, **kwargs)

    def add_trace(self, *args, **kwargs):
        for perturbation in self.perturbations:
            perturbation.magnitude.prior.var.add_trace(*args, **kwargs)

    def add_init_value(self):
        &#39;&#39;&#39;Set the initialization value. This is called by `pylab.inference.BaseMCMC.run`
        when first updating the variable. User should not use this function
        &#39;&#39;&#39;
        for perturbation in self.perturbations:
            perturbation.add_init_value()

    def get_single_value_of_perts(self):
        &#39;&#39;&#39;Get the variance for each perturbation
        &#39;&#39;&#39;
        return np.asarray([p.magnitude.prior.var.value for p in self.perturbations])

    def diag(self, only_pos_ind=True):
        &#39;&#39;&#39;Return the diagonal of the prior variances stacked up in order

        Parameters
        ----------
        only_pos_ind : bool
            If True, only put in the values for the positively indicated clusters
            for each perturbation

        Returns
        -------
        np.ndarray
        &#39;&#39;&#39;
        ret = []
        for perturbation in self.perturbations:
            if only_pos_ind:
                n = perturbation.indicator.num_on_clusters()
            else:
                n = len(perturbation.clustering)
            ret = np.append(
                ret,
                np.ones(n, dtype=float)*perturbation.magnitude.prior.var.value)
        return ret</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mdsine2.pylab.variables.Variable" href="pylab/variables.html#mdsine2.pylab.variables.Variable">Variable</a></li>
<li><a title="mdsine2.pylab.graph.Node" href="pylab/graph.html#mdsine2.pylab.graph.Node">Node</a></li>
<li><a title="mdsine2.pylab.graph.BaseNode" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode">BaseNode</a></li>
<li><a title="mdsine2.pylab.base.Saveable" href="pylab/base.html#mdsine2.pylab.base.Saveable">Saveable</a></li>
<li>mdsine2.pylab.variables._BaseArithmeticClass</li>
<li><a title="mdsine2.pylab.base.Traceable" href="pylab/base.html#mdsine2.pylab.base.Traceable">Traceable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="mdsine2.perturbations.PriorVarPerturbations.sample_iter"><code class="name">var <span class="ident">sample_iter</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample_iter(self):
    return self.perturbations[0].magnitude.prior.var.sample_iter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mdsine2.perturbations.PriorVarPerturbations.diag"><code class="name flex">
<span>def <span class="ident">diag</span></span>(<span>self, only_pos_ind=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the diagonal of the prior variances stacked up in order</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>only_pos_ind</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, only put in the values for the positively indicated clusters
for each perturbation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diag(self, only_pos_ind=True):
    &#39;&#39;&#39;Return the diagonal of the prior variances stacked up in order

    Parameters
    ----------
    only_pos_ind : bool
        If True, only put in the values for the positively indicated clusters
        for each perturbation

    Returns
    -------
    np.ndarray
    &#39;&#39;&#39;
    ret = []
    for perturbation in self.perturbations:
        if only_pos_ind:
            n = perturbation.indicator.num_on_clusters()
        else:
            n = len(perturbation.clustering)
        ret = np.append(
            ret,
            np.ones(n, dtype=float)*perturbation.magnitude.prior.var.value)
    return ret</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorVarPerturbations.get_single_value_of_perts"><code class="name flex">
<span>def <span class="ident">get_single_value_of_perts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the variance for each perturbation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_single_value_of_perts(self):
    &#39;&#39;&#39;Get the variance for each perturbation
    &#39;&#39;&#39;
    return np.asarray([p.magnitude.prior.var.value for p in self.perturbations])</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorVarPerturbations.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Every prior variance on the perturbations gets the same hyperparameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, **kwargs):
    &#39;&#39;&#39;Every prior variance on the perturbations gets the same hyperparameters
    &#39;&#39;&#39;
    for perturbation in self.perturbations:
        perturbation.magnitude.prior.var.initialize(**kwargs)</code></pre>
</details>
</dd>
<dt id="mdsine2.perturbations.PriorVarPerturbations.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    for perturbation in self.perturbations:
        perturbation.magnitude.prior.var.update()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mdsine2.pylab.variables.Variable" href="pylab/variables.html#mdsine2.pylab.variables.Variable">Variable</a></b></code>:
<ul class="hlist">
<li><code><a title="mdsine2.pylab.variables.Variable.T" href="pylab/variables.html#mdsine2.pylab.variables.Variable.T">T</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_child" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_child">add_child</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_init_value" href="pylab/variables.html#mdsine2.pylab.variables.Variable.add_init_value">add_init_value</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_parent" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_parent">add_parent</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_prior" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_prior">add_prior</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.add_undirected" href="pylab/graph.html#mdsine2.pylab.graph.Node.add_undirected">add_undirected</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.degree" href="pylab/graph.html#mdsine2.pylab.graph.Node.degree">degree</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.delete" href="pylab/graph.html#mdsine2.pylab.graph.BaseNode.delete">delete</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_adjacent_keys" href="pylab/graph.html#mdsine2.pylab.graph.Node.get_adjacent_keys">get_adjacent_keys</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_iter" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_iter">get_iter</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.get_trace_from_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.get_trace_from_disk">get_trace_from_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.load" href="pylab/base.html#mdsine2.pylab.base.Saveable.load">load</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.metropolis" href="pylab/graph.html#mdsine2.pylab.graph.Node.metropolis">metropolis</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.overwrite_entire_trace_on_disk" href="pylab/base.html#mdsine2.pylab.base.Traceable.overwrite_entire_trace_on_disk">overwrite_entire_trace_on_disk</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.save" href="pylab/base.html#mdsine2.pylab.base.Saveable.save">save</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_save_location" href="pylab/base.html#mdsine2.pylab.base.Saveable.set_save_location">set_save_location</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_trace" href="pylab/base.html#mdsine2.pylab.base.Traceable.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.pylab.variables.Variable.set_value_shape" href="pylab/variables.html#mdsine2.pylab.variables.Variable.set_value_shape">set_value_shape</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdsine2" href="index.html">mdsine2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdsine2.perturbations.PerturbationIndicators" href="#mdsine2.perturbations.PerturbationIndicators">PerturbationIndicators</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.add_init_value" href="#mdsine2.perturbations.PerturbationIndicators.add_init_value">add_init_value</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.add_trace" href="#mdsine2.perturbations.PerturbationIndicators.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.calculate_marginal_loglikelihood" href="#mdsine2.perturbations.PerturbationIndicators.calculate_marginal_loglikelihood">calculate_marginal_loglikelihood</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.calculate_relative_marginal_loglikelihood" href="#mdsine2.perturbations.PerturbationIndicators.calculate_relative_marginal_loglikelihood">calculate_relative_marginal_loglikelihood</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.initialize" href="#mdsine2.perturbations.PerturbationIndicators.initialize">initialize</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.make_rel_params" href="#mdsine2.perturbations.PerturbationIndicators.make_rel_params">make_rel_params</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.sample_iter" href="#mdsine2.perturbations.PerturbationIndicators.sample_iter">sample_iter</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.set_trace" href="#mdsine2.perturbations.PerturbationIndicators.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.total_on" href="#mdsine2.perturbations.PerturbationIndicators.total_on">total_on</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.update_relative" href="#mdsine2.perturbations.PerturbationIndicators.update_relative">update_relative</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.update_single_idx_fast" href="#mdsine2.perturbations.PerturbationIndicators.update_single_idx_fast">update_single_idx_fast</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.update_single_idx_slow" href="#mdsine2.perturbations.PerturbationIndicators.update_single_idx_slow">update_single_idx_slow</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationIndicators.update_slow" href="#mdsine2.perturbations.PerturbationIndicators.update_slow">update_slow</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.perturbations.PerturbationMagnitudes" href="#mdsine2.perturbations.PerturbationMagnitudes">PerturbationMagnitudes</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.perturbations.PerturbationMagnitudes.asarray" href="#mdsine2.perturbations.PerturbationMagnitudes.asarray">asarray</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationMagnitudes.initialize" href="#mdsine2.perturbations.PerturbationMagnitudes.initialize">initialize</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationMagnitudes.sample_iter" href="#mdsine2.perturbations.PerturbationMagnitudes.sample_iter">sample_iter</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationMagnitudes.set_values" href="#mdsine2.perturbations.PerturbationMagnitudes.set_values">set_values</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationMagnitudes.toarray" href="#mdsine2.perturbations.PerturbationMagnitudes.toarray">toarray</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationMagnitudes.update" href="#mdsine2.perturbations.PerturbationMagnitudes.update">update</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationMagnitudes.update_str" href="#mdsine2.perturbations.PerturbationMagnitudes.update_str">update_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.perturbations.PerturbationProbabilities" href="#mdsine2.perturbations.PerturbationProbabilities">PerturbationProbabilities</a></code></h4>
<ul class="two-column">
<li><code><a title="mdsine2.perturbations.PerturbationProbabilities.add_init_value" href="#mdsine2.perturbations.PerturbationProbabilities.add_init_value">add_init_value</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationProbabilities.add_trace" href="#mdsine2.perturbations.PerturbationProbabilities.add_trace">add_trace</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationProbabilities.initialize" href="#mdsine2.perturbations.PerturbationProbabilities.initialize">initialize</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationProbabilities.sample_iter" href="#mdsine2.perturbations.PerturbationProbabilities.sample_iter">sample_iter</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationProbabilities.set_trace" href="#mdsine2.perturbations.PerturbationProbabilities.set_trace">set_trace</a></code></li>
<li><code><a title="mdsine2.perturbations.PerturbationProbabilities.update" href="#mdsine2.perturbations.PerturbationProbabilities.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.perturbations.PriorMeanPerturbationSingle" href="#mdsine2.perturbations.PriorMeanPerturbationSingle">PriorMeanPerturbationSingle</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.perturbations.PriorMeanPerturbationSingle.initialize" href="#mdsine2.perturbations.PriorMeanPerturbationSingle.initialize">initialize</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorMeanPerturbationSingle.update" href="#mdsine2.perturbations.PriorMeanPerturbationSingle.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.perturbations.PriorMeanPerturbations" href="#mdsine2.perturbations.PriorMeanPerturbations">PriorMeanPerturbations</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.perturbations.PriorMeanPerturbations.get_single_value_of_perts" href="#mdsine2.perturbations.PriorMeanPerturbations.get_single_value_of_perts">get_single_value_of_perts</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorMeanPerturbations.initialize" href="#mdsine2.perturbations.PriorMeanPerturbations.initialize">initialize</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorMeanPerturbations.sample_iter" href="#mdsine2.perturbations.PriorMeanPerturbations.sample_iter">sample_iter</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorMeanPerturbations.toarray" href="#mdsine2.perturbations.PriorMeanPerturbations.toarray">toarray</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorMeanPerturbations.update" href="#mdsine2.perturbations.PriorMeanPerturbations.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.perturbations.PriorVarPerturbationSingle" href="#mdsine2.perturbations.PriorVarPerturbationSingle">PriorVarPerturbationSingle</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.perturbations.PriorVarPerturbationSingle.initialize" href="#mdsine2.perturbations.PriorVarPerturbationSingle.initialize">initialize</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorVarPerturbationSingle.update" href="#mdsine2.perturbations.PriorVarPerturbationSingle.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mdsine2.perturbations.PriorVarPerturbations" href="#mdsine2.perturbations.PriorVarPerturbations">PriorVarPerturbations</a></code></h4>
<ul class="">
<li><code><a title="mdsine2.perturbations.PriorVarPerturbations.diag" href="#mdsine2.perturbations.PriorVarPerturbations.diag">diag</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorVarPerturbations.get_single_value_of_perts" href="#mdsine2.perturbations.PriorVarPerturbations.get_single_value_of_perts">get_single_value_of_perts</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorVarPerturbations.initialize" href="#mdsine2.perturbations.PriorVarPerturbations.initialize">initialize</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorVarPerturbations.sample_iter" href="#mdsine2.perturbations.PriorVarPerturbations.sample_iter">sample_iter</a></code></li>
<li><code><a title="mdsine2.perturbations.PriorVarPerturbations.update" href="#mdsine2.perturbations.PriorVarPerturbations.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>